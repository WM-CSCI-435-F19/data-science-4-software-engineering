# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/5.3_utils.plotting.ipynb (unless otherwise specified).

__all__ = ['plot_err_freqs', 'plot_distances_boxplot', 'plot_metrics_stats_bars', 'boxplot_for_error_stats']

# Cell

import numpy as np
import pandas as pd

import plotly.graph_objects as go
from typing import Dict, Optional, List, Tuple

from .visualization import save_plotly_fig
from ..exp.metrics_java import metrics_categories

from ..codexplainer.utils import *
from .statistics import *

# Cell

def plot_err_freqs(freqs_data: Dict, set_name: str,
                   out_path: str,  file_name: str,
                   show: Optional[bool]=True, export: Optional[bool]=True):
    # Order by frequencies
    freqs = { k: v for k, v in sorted(freqs_data.items(), key=lambda item: item[1]) }
    x = list(freqs.keys())
    y = [v for _,v in freqs.items()]

    fig = go.Figure(
        data=[go.Bar(x=x, y=y)],
        layout_title_text=f"Error frequency for {set_name}"
    )

    if show:
        fig.show()
    if export:
        save_plotly_fig(fig, out_path, file_name)

# Cell

def plot_distances_boxplot(dataset: pd.DataFrame,
                           set1_name: str, set2_name: str,
                           out_path: str, file_name: str,
                           log_scale: Optional[bool]=False,
                           metrics_categories: Optional[Dict]=None,
                           measure: Optional[str]="Distance",
                           show: Optional[bool]=True,
                           export: Optional[bool]=False):
    """
    Function for plotting distances betwen 2 sets
    according to a set of dimensions (e.g. errors, SE metrics)
    """
    if metrics_categories is not None:
        n_rows = 4
        n_cols = 2
        height = 1.0/n_rows
        fig = make_subplots(
                rows=n_rows, cols=n_cols,
                subplot_titles=list(metrics_categories.keys()),
                row_heights=[height for _ in range(n_rows)]

              )

        for i, category in enumerate(metrics_categories):
            current_row = int(i / n_cols) + 1
            current_col = (i % n_cols) + 1

            metrics = metrics_categories[category]
            data = dataset[metrics].values

            box_width = 0.1 if len(metrics) < 4 else None
            for m in metrics:
                x = dataset[m].values
                fig.add_trace(
                    go.Box(
                        y=x, name=m, showlegend=False,
                        boxpoints='suspectedoutliers',
                        width=box_width
                    ),
                    row=current_row, col=current_col
                )

        fig.update_layout(
            title_text=f"JS_{measure}_{set1_name}-vs-{set2_name}",
            hovermode=False, height=1600, width=900,
            #boxgap=0.2,boxgroupgap=0.2
        )

        fig.update_yaxes(range=[0, 1])

        if show:
            fig.show()
        if export:
            save_plotly_fig(fig, out_path, file_name)
    else:
        # Split individual plots by batches
        dims = list(dataset.columns)
        n_dims = len(dims)

        n_rows=2
        n_cols=2
        fig = make_subplots(rows=n_rows, cols=n_cols)

        # Iterate through dimensions batch-wise
        bs = 10
        res = n_dims % bs
        batches = int(n_dims / bs)

        for i in range(batches):
            batch_dims = dims[(i*bs):((i+1)*bs)]

            current_row = int(i / n_cols) + 1
            current_col = (i % n_cols) + 1

            for d in batch_dims:
                x = dataset[d].values
                fig.add_trace(
                    go.Box(x=x, name=d, showlegend=False),
                    row=current_row, col=current_col
                )

        # Plot remaining data (not covered in the full-batches processed so far)
        remaining_dims = dims[-res:]
        for d in remaining_dims:
            x = dataset[d].values
            fig.add_trace(
                go.Box(x=x, name=d, showlegend=False),
                row=2, col=2
            )

        fig.update_xaxes(range=[0, 1])

        if log_scale:
            fig.update_layout(xaxis_type="log")

        fig.update_layout(hovermode=False)

        if show:
            fig.show()
        if export:
            save_plotly_fig(fig, out_path, file_name)

# Cell

def plot_metrics_stats_bars(tbl_metrics_data_set1: pd.DataFrame,
                            tbl_metrics_data_set2: pd.DataFrame,
                            set1_name: str, set2_name: str,
                            out_path: str, file_name: str,
                            dims: List, measures: Optional[List[str]]=['mean'],
                            show: Optional[bool]=True, export: Optional[bool]=False,
                            metrics_categories: Optional[List]=None,
                            log_scale: Optional[bool]=True):
    """
    Function for plotting bars showing the statistics (e.g mean, std, median) behavior of
    gathered SE metrics throughout a series of experiments
    """
    for measure in measures:
        df1 = tbl_metrics_data_set1[measure]
        df2 = tbl_metrics_data_set2[measure]

        if metrics_categories is not None:
            for category, metrics_list in metrics_categories.items():
                y = df1.describe()[metrics_list].loc['mean'].values
                fig = go.Figure()
                # Configure bars length
                # in order to visualize multiple metrics
                # in a similar plot
                width_val = 0.1 if len(metrics_list) < 4 else 0.3
                width_setting = [width_val] * len(metrics_list)
                fig.add_trace(
                    go.Bar(
                        x=y, y=metrics_list,
                        textposition='auto',
                        orientation='h',
                        name=set1_name,
                        marker=go.bar.Marker(color='rgb(227, 183, 161)'),
                        width=width_setting,
                        hoverinfo='skip'
                    )
                )

                y = df2.describe()[metrics_list].loc['mean'].values

                fig.add_trace(
                    go.Bar(
                        x=y, y=metrics_list,
                        textposition='auto',
                        orientation='h',
                        name=set2_name,
                        marker=go.bar.Marker(color='rgb(76, 114, 176)'),
                        width=width_setting,
                        hoverinfo='skip'
                    )
                )

#                 fig.update_xaxes(range=[0, 1])
                fig_title = f"{set1_name}_{set2_name}_{measure}-{category}"
                if log_scale:
                    fig.update_layout(
                        xaxis_type="log",
                        title=fig_title,
                        width=600, height=400,
                        bargap=0.30,bargroupgap=0.0

                    )
                if show:
                    fig.show()
                if export:
                    full_name = f"{file_name}-{fig_title}"
                    save_plotly_fig(fig, out_path, full_name)
        else:
            fig = make_subplots(
                rows=2, cols=1
            )

            dims = list(set(list(df1.columns) + list(df2.columns)))
            y = df1.describe()[dims].loc['mean'].values
            metric_set1 = y[:19]
            metric_set2 = y[19:]

            dims_set1 = dims[:19]
            dims_set2 = dims[19:]
#             print(y)

            # First half
            # ---------------------------------------------
            fig.add_trace(
                go.Bar(
                    x=metric_set1, y=dims_set1,
                    textposition='auto',
                    orientation='h',
                    name=set1_name,
                    marker=go.bar.Marker(color='rgb(227, 183, 161)')
                ),
                row=1, col=1
            )

            fig.add_trace(
                go.Bar(
                    x=metric_set2, y=dims_set2,
                    textposition='auto',
                    orientation='h',
                    name=set1_name,
                    marker=go.bar.Marker(color='rgb(227, 183, 161)')
                ),
                row=2, col=1
            )

            # ---------------------------------------------
            # Second half
            # ---------------------------------------------
            y = df2.describe()[dims].loc['mean'].values
#             print(y)
            metric_set1 = y[:19]
            metric_set2 = y[19:]

            dims_set1 = dims[:19]
            dims_set2 = dims[19:]

            fig.add_trace(
                go.Bar(
                    x=metric_set1, y=dims_set1,
                    textposition='auto',
                    orientation='h',
                    name=set2_name,
                    marker=go.bar.Marker(color='rgb(76, 114, 176)')
                ),
                row=1, col=1
            )

            fig.add_trace(
                go.Bar(
                    x=metric_set2, y=dims_set2,
                    textposition='auto',
                    orientation='h',
                    name=set2_name,
                    marker=go.bar.Marker(color='rgb(76, 114, 176)')
                ),
                row=2, col=1
            )

            # ---------------------------------------------

            fig.update_layout(height=1200, width=800)

            if log_scale:
                fig.update_layout(xaxis_type="log")

            if show:
                fig.show()
            if export:
                save_plotly_fig(fig, out_path, file_name)

# Cell

def boxplot_for_error_stats(dataset1: pd.DataFrame, dataset2: pd.DataFrame,
                            ds1_name: str, ds2_name: str, out_path: str, file_name: str,
                            batches: Optional[bool]=True, log_scale: Optional[bool]=False,
                            show: Optional[bool]=True, export: Optional[bool]=False):
    """
    Function for plotting stats (e.g. mean, std, median) behavior of
    gathered errors throughout a series of experiments
    """
    dims = list(set(list(dataset1.columns) + list(dataset1.columns)))
    n_dims = len(dims)
    if batches:
        bs = 5
        res = n_dims % bs
        batches = int(n_dims / bs)

        for i in range(batches):
            err_dims = dims[(i*bs):((i+1)*bs)]
            fig = go.Figure()
            for d in err_dims:
                x1 = dataset1[d]
                x2 = dataset2[d]
                fig.add_trace(
                    go.Box(x=x1, name=f"{ds1_name}-{d}")
                )
                fig.add_trace(go.Box(x=x2, name=f"{ds2_name}-{d}")
                )

            if log_scale:
                fig.update_layout(xaxis_type="log")

            if show:
                fig.show()
            if export:
                save_plotly_fig(fig, out_path, file_name)

        # Plot remaining
        err_dims = dims[-res:]
        fig = go.Figure()
        for d in err_dims:
            x1 = dataset1[d]
            x2 = dataset2[d]
            fig.add_trace(
                go.Box(x=x1, name=f"{ds1_name}-{d}")
            )
            fig.add_trace(
                go.Box(x=x2, name=f"{ds2_name}-{d}")
            )

        if log_scale:
            fig.update_layout(xaxis_type="log")

        if show:
                fig.show()
        if export:
            save_plotly_fig(fig, out_path, file_name)

    else:
        print('Plotting all stats in one figure.')
        fig = go.Figure()

        for d in dims:
            x1 = dataset1[d]
            x2 = dataset2[d]

            fig.add_trace(
                go.Box(x=x1, name=f"{ds1_name}-{d}")
            )

            fig.add_trace(
                go.Box(x=x2, name=f"{ds2_name}-{d}")
            )

        if log_scale:
            fig.update_layout(xaxis_type="log")

        if show:
            fig.show()
        if export:
            save_plotly_fig(fig, out_path, file_name)