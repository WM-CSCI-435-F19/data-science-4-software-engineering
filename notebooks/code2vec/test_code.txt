protected final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) {\n        final Observer<? super V> observer = downstream;\n        final SimplePlainQueue<U> q = queue;\n\n        if (wip.get() == 0 && wip.compareAndSet(0, 1)) {\n            if (q.isEmpty()) {\n                accept(observer, value);\n                if (leave(-1) == 0) {\n                    return;\n                }\n            } else {\n                q.offer(value);\n            }\n        } else {\n            q.offer(value);\n            if (!enter()) {\n                return;\n            }\n        }\n        QueueDrainHelper.drainLoop(q, observer, delayError, disposable, this);\n    }
@CheckReturnValue\n    @NonNull\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Observable<T> amb(Iterable<? extends ObservableSource<? extends T>> sources) {\n        ObjectHelper.requireNonNull(sources, "sources is null");\n        return RxJavaPlugins.onAssembly(new ObservableAmb<T>(null, sources));\n    }
@SuppressWarnings("unchecked")\n    @CheckReturnValue\n    @NonNull\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Observable<T> ambArray(ObservableSource<? extends T>... sources) {\n        ObjectHelper.requireNonNull(sources, "sources is null");\n        int len = sources.length;\n        if (len == 0) {\n            return empty();\n        }\n        if (len == 1) {\n            return (Observable<T>)wrap(sources[0]);\n        }\n        return RxJavaPlugins.onAssembly(new ObservableAmb<T>(sources, null));\n    }