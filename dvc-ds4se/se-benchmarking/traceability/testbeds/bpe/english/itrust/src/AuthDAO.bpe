▁p ackage ▁edu . nc su . cs c . itrust . dao . mysql ; ▁import ▁java . sql . Connection ; ▁import ▁java . sql . P reparedStatement ; ▁import ▁java . sql . ResultSet ; ▁import ▁java . sql . SQLException ; ▁import ▁edu . nc su . cs c . itrust . DBUtil ; ▁import ▁edu . nc su . cs c . itrust . RandomPassword ; ▁import ▁edu . nc su . cs c . itrust . dao . DAOFactory ; ▁import ▁edu . nc su . cs c . itrust . enums . Role ; ▁import ▁edu . nc su . cs c . itrust . exception . DBException ; ▁import ▁edu . nc su . cs c . itrust . exception . iTrustException ; ▁/** ▁* ▁AuthDAO ▁is ▁for ▁anything ▁that ▁has ▁to ▁do ▁with ▁authentication . ▁Mo st ▁methods ▁access ▁the ▁user s ▁table . ▁* ▁* ▁DAO ▁stand s ▁for ▁Database ▁Access ▁Object . ▁All ▁DAOs ▁are ▁intended ▁to ▁be ▁ref lections ▁of ▁the ▁database , ▁that ▁is , ▁* ▁one ▁DAO ▁per ▁table ▁in ▁the ▁database ▁( most ▁of ▁the ▁time ) . ▁For ▁more ▁comple x ▁sets ▁of ▁queries , ▁extra ▁DAOs ▁are ▁* ▁added . ▁DAOs ▁can ▁assume ▁that ▁all ▁data ▁has ▁been ▁validated ▁and ▁is ▁correct . ▁* ▁* ▁DAOs ▁should ▁n ever ▁have ▁setter s ▁or ▁any ▁other ▁parameter ▁to ▁the ▁constructor ▁than ▁a ▁factory . ▁All ▁DAOs ▁should ▁be ▁* ▁accessed ▁by ▁DAOFactory ▁( @ see ▁ {@ link ▁DAOFactory }) ▁and ▁every ▁DAO ▁should ▁have ▁a ▁factory ▁- ▁for ▁obtain ing ▁JDBC ▁* ▁connections ▁and / or ▁access ing ▁other ▁DAOs . ▁* ▁* ▁@ author ▁Andy ▁* ▁*/ ▁public ▁class ▁AuthDAO ▁{ ▁public ▁static ▁final ▁long ▁LOG IN _ TIMEOUT ▁= ▁15 ▁* ▁60 ▁* ▁1000; / / ▁15 ▁min ▁private ▁DAOFactory ▁factory ; ▁/** ▁* ▁The ▁typical ▁constructor . ▁* ▁@ param ▁factory ▁The ▁ {@ link ▁DAOFactory } ▁associate d ▁with ▁this ▁DAO , ▁which ▁is ▁used ▁for ▁obtain ing ▁SQL ▁connections , ▁etc . ▁*/ ▁public ▁AuthDAO ( DAOFactory ▁factory ) ▁{ ▁this . factory ▁= ▁factory ; ▁} ▁/** ▁* ▁Add ▁a ▁particular ▁user ▁to ▁the ▁system . ▁Do es ▁not ▁add ▁user - sp ec if ic ▁information ▁( e . g . ▁Patient ▁or ▁HCP ) . ▁* ▁Init i ally ▁sets ▁security ▁question ▁to ▁a ▁random ▁set ▁of ▁characters , ▁so ▁that ▁no body ▁should ▁be ▁ able ▁to ▁ gu es s ▁* ▁its ▁value . ▁* ▁* ▁@ param ▁mid ▁The ▁user ' s ▁MID ▁as ▁a ▁Long . ▁* ▁@ param ▁role ▁The ▁role ▁of ▁the ▁user ▁as ▁a ▁Role ▁enum ▁ {@ link ▁Role } ▁* ▁@ param ▁password ▁The ▁password ▁for ▁the ▁new ▁user . ▁* ▁@ return ▁A ▁string ▁representing ▁the ▁new ly ▁added ▁randomly - generated ▁password . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁String ▁add User ( Long ▁mid , ▁Role ▁role , ▁String ▁password ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁pstmt ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁pstmt ▁= ▁conn ▁ . prepare Statement (" INSERT ▁INT O ▁User s ▁( MID , ▁ PASSWORD , ▁ RO LE , ▁sQuestion , ▁sAnswer ) ▁VALUES ▁ (?,?,?,?,? )"); ▁pstmt . s etLong ( 1, ▁mid ); ▁pstmt . set String (2, ▁password ); ▁pstmt . set String ( 3, ▁role . to String ()); ▁pstmt . set String ( 4, ▁" Enter ▁the ▁random ▁password ▁given ▁in ▁your ▁account ▁email "); ▁String ▁pwd ▁= ▁RandomPassword . get RandomPassword (); ▁pstmt . set String (5, ▁pwd ); ▁pstmt . execute Update (); ▁return ▁pwd ; ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁pstmt ); ▁} ▁} ▁/** ▁* ▁ Reset ▁the ▁security ▁question ▁and ▁answer ▁for ▁a ▁particular ▁user ▁* ▁* ▁@ param ▁question ▁The ▁security ▁question ▁as ▁a ▁string . ▁* ▁@ param ▁answer ▁The ▁security ▁answer ▁as ▁a ▁string . ▁* ▁@ param ▁mid ▁The ▁MID ▁of ▁the ▁user ▁as ▁a ▁long . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁void ▁set SecurityQuestion Answer ( String ▁question , ▁String ▁answer , ▁long ▁mid ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁pstmt ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁pstmt ▁= ▁conn . prepare Statement (" UPDATE ▁User s ▁SET ▁sQuestion ▁= ▁? , ▁sAnswer ▁= ▁? ▁ WH ERE ▁MID ▁= ▁? "); ▁pstmt . set String ( 1, ▁question ); ▁pstmt . set String (2, ▁answer ); ▁pstmt . s etLong ( 3, ▁mid ); ▁pstmt . execute Update (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁pstmt ); ▁} ▁} ▁/** ▁* ▁Returns ▁the ▁user ▁name ▁of ▁a ▁user ▁from ▁just ▁the ▁MID ▁* ▁* ▁@ param ▁mid ▁The ▁MID ▁of ▁the ▁user ▁to ▁get ▁the ▁name ▁of . ▁* ▁@ return ▁The ▁user ' s ▁name ▁as ▁a ▁String . ▁* ▁@ throw s ▁DBException ▁* ▁@ throw s ▁iTrustException ▁*/ ▁public ▁String ▁ getUserName ( long ▁mid ) ▁throw s ▁DBException , ▁iTrustException ▁{ ▁Role ▁role ▁= ▁ getUserRole ( mid ); ▁switch ▁( role ) ▁{ ▁case ▁HCP : ▁case ▁PHA : ▁case ▁ ADMIN : ▁case ▁UAP : ▁case ▁ER : ▁return ▁factory . get PersonnelDAO (). getName ( mid ); ▁case ▁ PATIENT : ▁return ▁factory . get PatientDAO (). getName ( mid ); ▁case ▁TEST ER : ▁return ▁String . value Of ( mid ); ▁default : ▁throw ▁new ▁iTrustException (" Role ▁" ▁+ ▁role ▁+ ▁" ▁not ▁supported "); ▁} ▁} ▁/** ▁* ▁Returns ▁the ▁role ▁of ▁a ▁particular ▁MID ▁* ▁* ▁@ param ▁mid ▁The ▁MID ▁of ▁the ▁user ▁to ▁look ▁up . ▁* ▁@ return ▁The ▁ {@ link ▁Role } ▁of ▁the ▁user ▁as ▁an ▁enum . ▁* ▁@ throw s ▁DBException ▁* ▁@ throw s ▁iTrustException ▁*/ ▁public ▁Role ▁ getUserRole ( long ▁mid ) ▁throw s ▁DBException , ▁iTrustException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁pstmt ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁pstmt ▁= ▁conn . prepare Statement (" SEL ECT ▁role ▁FROM ▁User s ▁ WH ERE ▁MID =?" ); ▁pstmt . s etLong ( 1, ▁mid ); ▁ResultSet ▁rs ; ▁rs ▁= ▁pstmt . execute Query (); ▁if ▁( rs . next ()) ▁{ ▁return ▁Role . parse ( rs . get String (" role ")); ▁} ▁else ▁{ ▁throw ▁new ▁iTrustException (" User ▁does ▁not ▁exist "); ▁} ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁pstmt ); ▁} ▁} ▁/** ▁* ▁Change ▁the ▁password ▁of ▁a ▁particular ▁user ▁* ▁* ▁@ param ▁mid ▁The ▁MID ▁of ▁the ▁user ▁who se ▁password ▁we ▁are ▁ c ha ng ing . ▁* ▁@ param ▁password ▁The ▁new ▁password . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁void ▁ resetPassword ( long ▁mid , ▁String ▁password ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" UPDATE ▁User s ▁SET ▁password =? ▁ WH ERE ▁MID =?" ); ▁ps . set String ( 1, ▁password ); ▁ps . s etLong (2, ▁mid ); ▁ps . execute Update (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁the ▁security ▁question ▁for ▁a ▁particular ▁user . ▁* ▁* ▁@ param ▁mid ▁The ▁MID ▁of ▁the ▁user ▁we ▁are ▁look ing ▁up . ▁* ▁@ return ▁The ▁security ▁question ▁of ▁the ▁user ▁we ▁are ▁look ing ▁up . ▁* ▁@ throw s ▁iTrustException ▁*/ ▁public ▁String ▁get SecurityQuestion ( long ▁mid ) ▁throw s ▁iTrustException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁sQuestion ▁FROM ▁User s ▁ WH ERE ▁MID =?" ); ▁ps . s etLong ( 1, ▁mid ); ▁ResultSet ▁r ▁= ▁ps . execute Query (); ▁if ▁( r . next ()) ▁return ▁r . get String (" s Question "); ▁else ▁throw ▁new ▁iTrustException (" No ▁security ▁question ▁set ▁for ▁MID : ▁" ▁+ ▁mid ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁the ▁security ▁answer ▁of ▁a ▁particular ▁user ▁* ▁* ▁@ param ▁mid ▁The ▁MID ▁of ▁the ▁user ▁we ▁are ▁look ing ▁up . ▁* ▁@ return ▁The ▁security ▁answer ▁as ▁a ▁String . ▁* ▁@ throw s ▁iTrustException ▁*/ ▁public ▁String ▁get S ecurityAnswer ( long ▁mid ) ▁throw s ▁iTrustException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁sAnswer ▁FROM ▁User s ▁ WH ERE ▁MID =?" ); ▁ps . s etLong ( 1, ▁mid ); ▁ResultSet ▁r ▁= ▁ps . execute Query (); ▁if ▁( r . next ()) ▁return ▁r . get String (" s Answer "); ▁else ▁throw ▁new ▁iTrustException (" No ▁security ▁answer ▁set ▁for ▁MID ▁" ▁+ ▁mid ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Record ▁a ▁login ▁failure , ▁which ▁black list s ▁the ▁ipAddress . ▁Use s ▁the ▁database ▁table ▁like ▁a ▁hash ▁table ▁where ▁* ▁the ▁key ▁is ▁the ▁user ' s ▁IP ▁address . ▁If ▁the ▁user ' s ▁IP ▁address ▁is ▁not ▁in ▁the ▁table , ▁a ▁row ▁with ▁" 1" ▁is ▁* ▁added . ▁* ▁* ▁@ param ▁ipAddr ▁The ▁IP ▁address ▁of ▁the ▁user ▁as ▁a ▁String . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁void ▁record LoginFailure ( String ▁ipAddr ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn ▁ . prepare Statement (" UPDATE ▁LoginFailures ▁SET ▁ Failure Count = Failure Count +1, ▁ lastFailure = CURRENT _ TIME STA M P ▁ WH ERE ▁ IPAddress =?" ); ▁// . prepare Statement (" INSERT ▁INT O ▁LoginFailures ▁VALUES (?,? , ? )"); ▁ps . set String ( 1, ▁ipAddr ); ▁// ps . set Int (2, ▁failures ); ▁// ps . setDate ( 3, ▁Calendar . get Instance (). getTime ()); ▁int ▁num Updated ▁= ▁ps . execute Update (); ▁if ▁( num Updated ▁== ▁0) ▁// ▁if ▁there ▁was n ' t ▁an ▁empty ▁row ▁to ▁begin ▁with ▁insert LoginFailure Row ( ipAddr , ▁1, ▁conn ); / / ▁now ▁they ▁have ▁a ▁row ▁AND ▁a ▁str i k e ▁against ▁// ▁' em ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Record ▁a ▁reset ▁password ▁failure , ▁which ▁black list s ▁the ▁ipAddress . ▁Use s ▁the ▁database ▁table ▁like ▁a ▁hash ▁* ▁table ▁where ▁the ▁key ▁is ▁the ▁user ' s ▁IP ▁address . ▁If ▁the ▁user ' s ▁IP ▁address ▁is ▁not ▁in ▁the ▁table , ▁a ▁row ▁with ▁* ▁" 1" ▁is ▁added . ▁* ▁* ▁@ param ▁ipAddr ▁The ▁IP ▁address ▁of ▁the ▁user ▁as ▁a ▁String . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁void ▁record ResetPassword Failure ( String ▁ipAddr ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn ▁ . prepare Statement (" UPDATE ▁ResetPassword Failures ▁SET ▁failure count = fail u re count +1 ▁ WH ERE ▁ ip address =?" ); ▁ps . set String ( 1, ▁ipAddr ); ▁int ▁num Updated ▁= ▁ps . execute Update (); ▁if ▁( num Updated ▁== ▁0) ▁// ▁if ▁there ▁was n ' t ▁an ▁empty ▁row ▁to ▁begin ▁with ▁insert ResetPassword Row ( ipAddr , ▁1, ▁conn ); / / ▁now ▁they ▁have ▁a ▁row ▁AND ▁a ▁str i k e ▁against ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁the ▁number ▁of ▁failures ▁from ▁reset ting ▁a ▁password , ▁given ▁an ▁IP ▁address . ▁* ▁* ▁@ param ▁ipAddr ▁An ▁IP ▁address ▁for ▁the ▁associate d ▁attempt ▁as ▁a ▁String . ▁* ▁@ return ▁An ▁int ▁representing ▁the ▁number ▁of ▁failures . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁int ▁get ResetPassword Failures ( String ▁ipAddr ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁ResetPassword Failures ▁ WH ERE ▁IP ADDRESS =?" ); ▁ps . set String ( 1, ▁ipAddr ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁if ▁( rs . next ()) ▁{ ▁// ▁if ▁we ' re ▁more ▁than ▁X ▁minutes ▁out , ▁clear ▁the ▁failure ▁count ▁if ▁( System . current Time M illi s () ▁- ▁rs . get Timestamp (" lastFailure "). getTime () ▁> ▁LOG IN _ TIMEOUT ) ▁{ ▁update Reset Failures To Zero ( ipAddr , ▁conn ); ▁return ▁0; ▁} ▁else ▁{ ▁return ▁rs . getInt (" fail u re Count "); ▁} ▁} ▁else ▁{ ▁insert ResetPassword Row ( ipAddr , ▁0, ▁conn ); ▁return ▁0; ▁} ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁the ▁number ▁of ▁failures ▁from ▁login ▁failures ▁a ▁password , ▁given ▁an ▁IP ▁address . ▁* ▁* ▁@ param ▁ipAddr ▁The ▁IP ▁address ▁for ▁this ▁attempt ▁as ▁a ▁String . ▁* ▁@ return ▁An ▁int ▁representing ▁the ▁number ▁of ▁failures ▁which ▁have ▁occured . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁int ▁get LoginFailure s ( String ▁ipAddr ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁LoginFailures ▁ WH ERE ▁IP ADDRESS =?" ); ▁ps . set String ( 1, ▁ipAddr ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁if ▁( rs . next ()) ▁{ ▁// ▁if ▁we ' re ▁more ▁than ▁X ▁minutes ▁out , ▁clear ▁the ▁failure ▁count ▁if ▁( System . current Time M illi s () ▁- ▁rs . get Timestamp (" lastFailure "). getTime () ▁> ▁LOG IN _ TIMEOUT ) ▁{ ▁update Failures To Zero ( ipAddr , ▁conn ); ▁return ▁0; ▁} ▁else ▁{ ▁return ▁rs . getInt (" fail u re Count "); ▁} ▁} ▁else ▁{ ▁insert LoginFailure Row ( ipAddr , ▁0, ▁conn ); ▁return ▁0; ▁} ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁private ▁void ▁insert LoginFailure Row ( String ▁ipAddr , ▁int ▁failureCount , ▁ Connection ▁conn ) ▁throw s ▁DBException , ▁SQLException ▁{ ▁P reparedStatement ▁ps ▁= ▁conn ▁ . prepare Statement (" INSERT ▁INT O ▁LoginFailures ( IPAddress , ▁failureCount ) ▁VALUES (?,? )"); ▁ps . set String ( 1, ▁ipAddr ); ▁ps . set Int (2, ▁failureCount ); ▁ps . execute Update (); ▁} ▁private ▁void ▁insert ResetPassword Row ( String ▁ipAddr , ▁int ▁failureCount , ▁ Connection ▁conn ) ▁throw s ▁DBException , ▁SQLException ▁{ ▁P reparedStatement ▁ps ▁= ▁conn ▁ . prepare Statement (" INSERT ▁INT O ▁ResetPassword Failures ( IPAddress , ▁failureCount ) ▁VALUES (?,? )"); ▁ps . set String ( 1, ▁ipAddr ); ▁ps . set Int (2, ▁failureCount ); ▁ps . execute Update (); ▁} ▁private ▁void ▁update Failures To Zero ( String ▁ipAddr , ▁ Connection ▁conn ) ▁throw s ▁DBException , ▁SQLException ▁{ ▁P reparedStatement ▁ps ▁= ▁conn ▁ . prepare Statement (" UPDATE ▁LoginFailures ▁SET ▁failureCount =0 ▁ WH ERE ▁ IPAddress =?" ); ▁ps . set String ( 1, ▁ipAddr ); ▁ps . execute Update (); ▁} ▁public ▁void ▁reset LoginFailure s To Zero ( String ▁ipAddr ) ▁throw s ▁DBException , ▁SQLException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try { ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn ▁ . prepare Statement (" UPDATE ▁LoginFailures ▁SET ▁failureCount =0 ▁ WH ERE ▁ IPAddress =?" ); ▁ps . set String ( 1, ▁ipAddr ); ▁ps . execute Update (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁private ▁void ▁update Reset Failures To Zero ( String ▁ipAddr , ▁ Connection ▁conn ) ▁throw s ▁DBException , ▁SQLException ▁{ ▁P reparedStatement ▁ps ▁= ▁conn ▁ . prepare Statement (" UPDATE ▁ResetPassword Failures ▁SET ▁failureCount =0 ▁ WH ERE ▁ IPAddress =?" ); ▁ps . set String ( 1, ▁ipAddr ); ▁ps . execute Update (); ▁} ▁/** ▁* ▁Check ▁that ▁a ▁user ▁ actually ▁exists . ▁* ▁* ▁@ param ▁mid ▁* ▁@ return ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁boolean ▁check User E xists ( long ▁mid ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁User s ▁ WH ERE ▁MID =?" ); ▁ps . s etLong ( 1, ▁mid ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁rs . next (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁}