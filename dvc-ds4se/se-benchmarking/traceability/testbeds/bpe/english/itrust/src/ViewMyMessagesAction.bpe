▁p ackage ▁edu . nc su . cs c . itrust . action ; ▁import ▁java . sql . SQLException ; ▁import ▁java . text . DateFormat ; ▁import ▁java . text . ParseException ; ▁import ▁java . text . SimpleDateFormat ; ▁import ▁java . util . ArrayList ; ▁import ▁java . util . Calendar ; ▁import ▁java . util . Date ; ▁import ▁java . util . List ; ▁import ▁edu . nc su . cs c . itrust . beans . MessageBean ; ▁import ▁edu . nc su . cs c . itrust . dao . DAOFactory ; ▁import ▁edu . nc su . cs c . itrust . dao . mysql . MessageDAO ; ▁import ▁edu . nc su . cs c . itrust . dao . mysql . PatientDAO ; ▁import ▁edu . nc su . cs c . itrust . dao . mysql . PersonnelDAO ; ▁import ▁edu . nc su . cs c . itrust . exception . DBException ; ▁import ▁edu . nc su . cs c . itrust . exception . iTrustException ; ▁/** ▁* ▁ Action ▁class ▁for ▁ViewMyMessages . jsp ▁* ▁*/ ▁public ▁class ▁ViewMyMessages Action ▁{ ▁private ▁long ▁loggedInMID ; ▁private ▁PatientDAO ▁patientDAO ; ▁private ▁PersonnelDAO ▁personnelDAO ; ▁private ▁MessageDAO ▁messageDAO ; ▁/** ▁* ▁Set ▁up ▁defaults ▁* ▁* ▁@ param ▁factory ▁The ▁DAOFactory ▁used ▁to ▁create ▁the ▁DAOs ▁used ▁in ▁this ▁action . ▁* ▁@ param ▁loggedInMID ▁The ▁MID ▁of ▁the ▁user ▁who ▁is ▁viewing ▁the ir ▁messages . ▁*/ ▁public ▁ViewMyMessages Action ( DAOFactory ▁factory , ▁long ▁loggedInMID ) ▁{ ▁this . loggedInMID ▁= ▁loggedInMID ; ▁this . patientDAO ▁= ▁factory . get PatientDAO (); ▁this . personnelDAO ▁= ▁factory . get PersonnelDAO (); ▁this . message DAO ▁= ▁factory . get MessageDAO (); ▁} ▁/** ▁* ▁Get s ▁all ▁the ▁messages ▁for ▁the ▁logged ▁in ▁user ▁* ▁* ▁@ return ▁a ▁list ▁of ▁all ▁the ▁user ' s ▁messages ▁* ▁@ throw s ▁SQLException ▁*/ ▁public ▁List < MessageBean > ▁ getAllMyMessages () ▁throw s ▁SQLException ▁{ ▁return ▁messageDAO . getMessage s For ( loggedInMID ); ▁} ▁/** ▁* ▁Get s ▁all ▁the ▁messages ▁for ▁the ▁logged ▁in ▁user ▁and ▁sort s ▁by ▁ascending ▁time ▁* ▁* ▁@ return ▁a ▁list ▁of ▁all ▁the ▁user ' s ▁messages ▁* ▁@ throw s ▁SQLException ▁*/ ▁public ▁List < MessageBean > ▁ getAllMyMessages Time Ascending () ▁throw s ▁SQLException ▁{ ▁return ▁messageDAO . getMessage s Time Ascending ( loggedInMID ); ▁} ▁/** ▁* ▁Get s ▁all ▁the ▁messages ▁for ▁the ▁logged ▁in ▁user ▁and ▁sort s ▁names ▁in ▁ascending ▁order ▁* ▁* ▁@ return ▁a ▁list ▁of ▁all ▁the ▁user ' s ▁messages ▁* ▁@ throw s ▁SQLException ▁*/ ▁public ▁List < MessageBean > ▁ getAllMyMessages Name Ascending () ▁throw s ▁SQLException ▁{ ▁return ▁messageDAO . getMessagesName Ascending ( loggedInMID ); ▁} ▁/** ▁* ▁Get s ▁all ▁the ▁messages ▁for ▁the ▁logged ▁in ▁user ▁and ▁sort s ▁name ▁in ▁descending ▁order ▁* ▁* ▁@ return ▁a ▁list ▁of ▁all ▁the ▁user ' s ▁messages ▁* ▁@ throw s ▁SQLException ▁*/ ▁public ▁List < MessageBean > ▁ getAllMyMessages Name Descending () ▁throw s ▁SQLException ▁{ ▁return ▁messageDAO . getMessagesName Descending ( loggedInMID ); ▁} ▁/** ▁* ▁Get s ▁all ▁the ▁sent ▁messages ▁for ▁the ▁logged ▁in ▁user ▁* ▁* ▁@ return ▁a ▁list ▁of ▁all ▁the ▁user ' s ▁sent ▁messages ▁* ▁@ throw s ▁SQLException ▁*/ ▁public ▁List < MessageBean > ▁getAll MySentMessages () ▁throw s ▁SQLException ▁{ ▁return ▁messageDAO . getMessagesFrom ( loggedInMID ); ▁} ▁/** ▁* ▁Get s ▁all ▁the ▁messages ▁for ▁the ▁logged ▁in ▁user ▁and ▁sort s ▁by ▁ascending ▁time ▁* ▁* ▁@ return ▁a ▁list ▁of ▁all ▁the ▁user ' s ▁messages ▁* ▁@ throw s ▁SQLException ▁*/ ▁public ▁List < MessageBean > ▁getAll MySentMessages Time Ascending () ▁throw s ▁SQLException ▁{ ▁return ▁messageDAO . getMessagesFrom Time Ascending ( loggedInMID ); ▁} ▁/** ▁* ▁Get s ▁all ▁the ▁messages ▁for ▁the ▁logged ▁in ▁user ▁and ▁sort s ▁names ▁in ▁ascending ▁order ▁* ▁* ▁@ return ▁a ▁list ▁of ▁all ▁the ▁user ' s ▁messages ▁* ▁@ throw s ▁SQLException ▁*/ ▁public ▁List < MessageBean > ▁ getAllMy SentMessagesName Ascending () ▁throw s ▁SQLException ▁{ ▁return ▁messageDAO . get MessagesFromName Ascending ( loggedInMID ); ▁} ▁/** ▁* ▁Get s ▁all ▁the ▁messages ▁for ▁the ▁logged ▁in ▁user ▁and ▁sort s ▁name ▁in ▁descending ▁order ▁* ▁* ▁@ return ▁a ▁list ▁of ▁all ▁the ▁user ' s ▁messages ▁* ▁@ throw s ▁SQLException ▁*/ ▁public ▁List < MessageBean > ▁ getAllMy SentMessagesName Descending () ▁throw s ▁SQLException ▁{ ▁return ▁messageDAO . get MessagesFromName Descending ( loggedInMID ); ▁} ▁public ▁String ▁validate And Create Filter ( String ▁filter ) ▁{ ▁String [ ] ▁f ▁= ▁filter . spl it (",", ▁-1) ; ▁DateFormat ▁format ▁= ▁new ▁ SimpleDateFormat (" MM / dd / yyyy "); ▁Date ▁ s ▁= ▁null ; ▁Date ▁e n ▁= ▁null ; ▁try ▁{ ▁if (! f [4 ] . equals ("")) ▁ s ▁= ▁format . parse ( f [4 ] ); ▁if (! f [5 ] . equals ("")) ▁e n ▁= ▁format . parse ( f [5 ] ); ▁if ( s != null ▁&& ▁e n != null ▁&& ▁e n . before ( s )) ▁{ ▁return ▁" Error : ▁The ▁end ▁date ▁cannot ▁be ▁before ▁the ▁start ▁date . "; ▁} ▁} ▁catch ( Exception ▁e ) ▁{ ▁return ▁" Error : ▁A ▁date ▁was ▁not ▁formatt ed ▁correctly , ▁p lease ▁enter ▁dates ▁as ▁ MM / DD / YYYY "; ▁} ▁for ( int ▁i =0; ▁i < f . length ; ▁i ++) ▁{ ▁f [ i ] = f [ i ] . replace ("\ " ", ▁" "); ▁f [ i ] = f [ i ] . replace ("< "," "); ▁f [ i ] = f [ i ] . replace (" > "," "); ▁} ▁String ▁nf ▁= ▁f [0 ] +"," + f [1 ] +"," + f [2 ] +"," + f [3 ] +"," + f [4 ] +"," + f [5 ] ; ▁return ▁nf ; ▁} ▁/** ▁* ▁Get s ▁a ▁list ▁of ▁messages ▁for ▁a ▁user ▁based ▁on ▁the ir ▁filter ▁criteria . ▁* ▁* ▁@ param ▁messages ▁List ▁of ▁all ▁of ▁a ▁user ' s ▁MessageBeans ▁* ▁@ param ▁filter ▁String ▁containing ▁a ▁user ' s ▁filter ▁criteria . ▁* ▁@ return ▁a ▁List ▁of ▁MessageBeans ▁that ▁ me et ▁the ▁criteria ▁of ▁the ▁filter . ▁* ▁@ throw s ▁iTrustException ▁* ▁@ throw s ▁ParseException ▁*/ ▁public ▁List < MessageBean > ▁filter Messages ( List < MessageBean > ▁messages , ▁String ▁filter ) ▁throw s ▁iTrustException , ▁ParseException ▁{ ▁List < MessageBean > ▁filtered ▁= ▁new ▁ArrayList < MessageBean > (); ▁String [ ] ▁f ▁= ▁filter . spl it (",", ▁-1) ; ▁for ( MessageBean ▁m ▁: ▁messages ) ▁{ ▁/** ▁* ▁Check ▁the ▁sender ▁filter ▁field . ▁* ▁Ex clude ▁if ▁this ▁MessageBean ▁does ▁not ▁match ▁the ▁* ▁requested ▁sender , ▁if ▁one ▁is ▁specified . ▁*/ ▁if (! f [0 ] . equals ("")) ▁{ ▁if (! this . getName ( m . get From ()). equals I gnore Case ( f [0 ] )) ▁continue ; ▁} ▁/** ▁* ▁Check ▁the ▁subject ▁filter ▁field . ▁* ▁Ex clude ▁if ▁this ▁MessageBean ▁does ▁not ▁match ▁the ▁* ▁requested ▁subject , ▁if ▁one ▁is ▁specified . ▁*/ ▁if (! f [1 ] . equals ("")) ▁{ ▁if (! m . get Subject (). equals I gnore Case ( f [1 ] )) ▁continue ; ▁} ▁/** ▁* ▁Check ▁the ▁body ▁of ▁the ▁message ▁for ▁certain ▁words . ▁* ▁Ex clude ▁if ▁this ▁MessageBean ▁if ▁it ▁does ▁not ▁contain ▁* ▁ th ose ▁words ▁in ▁the ▁message ▁body . ▁*/ ▁if (! f [2 ] . equals ("")) ▁{ ▁if (! m . get Subject (). to Lower Case (). contains ( f [2 ] . to Lower Case ()) ▁&& ▁! m . getBody (). to Lower Case (). contains ( f [2 ] . to Lower Case ())) ▁continue ; ▁} ▁/** ▁* ▁Check ▁the ▁body ▁of ▁the ▁message ▁for ▁certain ▁words . ▁* ▁Ex clude ▁if ▁this ▁MessageBean ▁if ▁it ▁does ▁contain ▁* ▁ th ose ▁words ▁in ▁the ▁message ▁body . ▁*/ ▁if (! f [3 ] . equals ("")) ▁{ ▁if ( m . get Subject (). to Lower Case (). contains ( f [3 ] . to Lower Case ()) ▁|| ▁m . getBody (). to Lower Case (). contains ( f [3 ] . to Lower Case ())) ▁continue ; ▁} ▁/** ▁* ▁Check ▁the ▁start ▁date ▁filter ▁field . ▁* ▁Ex clude ▁if ▁this ▁MessageBean ▁was ▁not ▁sent ▁after ▁* ▁this ▁date . ▁*/ ▁if (! f [4 ] . equals ("")) ▁{ ▁DateFormat ▁format ▁= ▁new ▁ SimpleDateFormat (" MM / dd / yyyy "); ▁Date ▁ s ▁= ▁format . parse ( f [4 ] ); ▁if ( s . after ( m . getSen tDate ())) ▁continue ; ▁} ▁/** ▁* ▁Check ▁the ▁end ▁date ▁filter ▁field . ▁* ▁Ex clude ▁if ▁this ▁MessageBean ▁was ▁not ▁sent ▁before ▁* ▁this ▁date . ▁*/ ▁if (! f [5 ] . equals ("")) ▁{ ▁DateFormat ▁format ▁= ▁new ▁ SimpleDateFormat (" MM / dd / yyyy "); ▁Date ▁ s ▁= ▁format . parse ( f [5 ] ); ▁Calendar ▁ c ▁= ▁Calendar . get Instance (); ▁ c . setTime ( s ); ▁ c . add ( Calendar . DAY _ OF _ MONTH , ▁1); ▁ s ▁= ▁ c . getTime (); ▁if ( s . before ( m . getSen tDate ())) ▁continue ; ▁} ▁/** ▁* ▁If ▁the ▁message ▁has ▁not ▁been ▁eliminate d ▁by ▁any ▁* ▁of ▁the ▁filter ▁fields , ▁add ▁it ▁to ▁the ▁new ▁list ▁* ▁of ▁messages . ▁*/ ▁filtered . add ( m ); ▁} ▁return ▁filtered ; ▁} ▁/** ▁* ▁Get s ▁a ▁patient ' s ▁name ▁from ▁the ir ▁MID ▁* ▁* ▁@ param ▁mid ▁the ▁MID ▁of ▁the ▁patient ▁* ▁@ return ▁the ▁patient ' s ▁name ▁* ▁@ throw s ▁iTrustException ▁*/ ▁public ▁String ▁getName ( long ▁mid ) ▁throw s ▁iTrustException ▁{ ▁if ( mid ▁< ▁ 700000000 0 L ) ▁return ▁patientDAO . getName ( mid ); ▁else ▁return ▁personnelDAO . getName ( mid ); ▁} ▁/** ▁* ▁Get s ▁a ▁personnel ' s ▁name ▁from ▁the ir ▁MID ▁* ▁* ▁@ param ▁mid ▁the ▁MID ▁of ▁the ▁personnel ▁* ▁@ return ▁the ▁personnel ' s ▁name ▁* ▁@ throw s ▁iTrustException ▁*/ ▁public ▁String ▁getPersonnel Name ( long ▁mid ) ▁throw s ▁iTrustException ▁{ ▁return ▁personnelDAO . getName ( mid ); ▁} ▁/** ▁* ▁Set ▁the ▁state ▁of ▁the ▁MessageBean ▁to ▁read , ▁after ▁* ▁it ▁is ▁read ▁by ▁a ▁user . ▁* ▁@ param ▁mBean ▁MessageBean ▁to ▁be ▁read ▁*/ ▁public ▁void ▁set Read ( MessageBean ▁mBean ) ▁{ ▁try ▁{ ▁messageDAO . update Read ( mBean ); ▁} ▁catch ▁( DBException ▁e ) ▁{ ▁// ▁TODO ▁ Au to - generated ▁catch ▁block ▁e . print Stack T race (); ▁} ▁} ▁}