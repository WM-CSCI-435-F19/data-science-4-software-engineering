▁p ackage ▁edu . nc su . cs c . itrust . dao . mysql ; ▁import ▁java . sql . Connection ; ▁import ▁java . sql . P reparedStatement ; ▁import ▁java . sql . ResultSet ; ▁import ▁java . sql . SQLException ; ▁import ▁java . sql . Timestamp ; ▁import ▁java . sql . Date ; ▁import ▁java . util . List ; ▁import ▁edu . nc su . cs c . itrust . DBUtil ; ▁import ▁edu . nc su . cs c . itrust . beans . Ope rationalProfile ; ▁import ▁edu . nc su . cs c . itrust . beans . TransactionBean ; ▁import ▁edu . nc su . cs c . itrust . beans . loaders . Operation alProfileLoader ; ▁import ▁edu . nc su . cs c . itrust . beans . loaders . Transaction BeanLoader ; ▁import ▁edu . nc su . cs c . itrust . dao . DAOFactory ; ▁import ▁edu . nc su . cs c . itrust . enums . TransactionType ; ▁import ▁edu . nc su . cs c . itrust . exception . DBException ; ▁/** ▁* ▁Used ▁for ▁the ▁logging ▁mechanism . ▁* ▁* ▁DAO ▁stand s ▁for ▁Database ▁Access ▁Object . ▁All ▁DAOs ▁are ▁intended ▁to ▁be ▁ref lections ▁of ▁the ▁database , ▁that ▁is , ▁* ▁one ▁DAO ▁per ▁table ▁in ▁the ▁database ▁( most ▁of ▁the ▁time ) . ▁For ▁more ▁comple x ▁sets ▁of ▁queries , ▁extra ▁DAOs ▁are ▁* ▁added . ▁DAOs ▁can ▁assume ▁that ▁all ▁data ▁has ▁been ▁validated ▁and ▁is ▁correct . ▁* ▁* ▁DAOs ▁should ▁n ever ▁have ▁setter s ▁or ▁any ▁other ▁parameter ▁to ▁the ▁constructor ▁than ▁a ▁factory . ▁All ▁DAOs ▁should ▁be ▁* ▁accessed ▁by ▁DAOFactory ▁( @ see ▁ {@ link ▁DAOFactory }) ▁and ▁every ▁DAO ▁should ▁have ▁a ▁factory ▁- ▁for ▁obtain ing ▁JDBC ▁* ▁connections ▁and / or ▁access ing ▁other ▁DAOs . ▁* ▁* ▁@ author ▁Andy ▁* ▁*/ ▁public ▁class ▁TransactionDAO ▁{ ▁private ▁DAOFactory ▁factory ; ▁private ▁TransactionBean Loader ▁loader ▁= ▁new ▁TransactionBean Loader (); ▁private ▁Operation alProfileLoader ▁operation alProfileLoader ▁= ▁new ▁Operation alProfileLoader (); ▁/** ▁* ▁The ▁typical ▁constructor . ▁* ▁@ param ▁factory ▁The ▁ {@ link ▁DAOFactory } ▁associate d ▁with ▁this ▁DAO , ▁which ▁is ▁used ▁for ▁obtain ing ▁SQL ▁connections , ▁etc . ▁*/ ▁public ▁TransactionDAO ( DAOFactory ▁factory ) ▁{ ▁this . factory ▁= ▁factory ; ▁} ▁/** ▁* ▁Returns ▁the ▁who le ▁transaction ▁log ▁* ▁* ▁@ return ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < TransactionBean > ▁getAll Transactions () ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁TransactionLog ▁OR DER ▁ BY ▁timeLogged ▁DESC "); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁loader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Log ▁a ▁transaction , ▁just ▁giv ing ▁it ▁the ▁person ▁who ▁is ▁logged ▁in ▁and ▁the ▁type ▁* ▁* ▁@ param ▁type ▁The ▁ {@ link ▁TransactionType } ▁enum ▁representing ▁the ▁type ▁this ▁transaction ▁is . ▁* ▁@ param ▁loggedInMID ▁The ▁MID ▁of ▁the ▁user ▁who ▁is ▁logged ▁in . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁void ▁log Transaction ( TransactionType ▁type , ▁long ▁loggedInMID ) ▁throw s ▁DBException ▁{ ▁log Transaction ( type , ▁loggedInMID , ▁0 L , ▁" "); ▁} ▁/** ▁* ▁Log ▁a ▁transaction , ▁with ▁all ▁of ▁the ▁info . ▁The ▁meaning ▁of ▁secondaryMID ▁and ▁addedInfo ▁changes ▁depend ing ▁on ▁* ▁the ▁transaction ▁type . ▁* ▁* ▁@ param ▁type ▁The ▁ {@ link ▁TransactionType } ▁enum ▁representing ▁the ▁type ▁this ▁transaction ▁is . ▁* ▁@ param ▁loggedInMID ▁The ▁MID ▁of ▁the ▁user ▁who ▁is ▁logged ▁in . ▁* ▁@ param ▁secondaryMID ▁T y p ical ly , ▁the ▁MID ▁of ▁the ▁user ▁who ▁is ▁being ▁act ed ▁upon . ▁* ▁@ param ▁addedInfo ▁A ▁note ▁about ▁a ▁sub transaction , ▁or ▁specific s ▁of ▁this ▁transaction ▁( for ▁ post er ity ) . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁void ▁log Transaction ( TransactionType ▁type , ▁long ▁loggedInMID , ▁long ▁secondaryMID , ▁String ▁addedInfo ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" INSERT ▁INT O ▁TransactionLog ( loggedInMID , ▁secondaryMID , ▁" ▁+ ▁" transaction Code , ▁addedInfo ) ▁VALUES (?,?,?,? )"); ▁ps . s etLong ( 1, ▁loggedInMID ); ▁ps . s etLong (2, ▁secondaryMID ); ▁ps . set Int ( 3, ▁type . get Code ()); ▁ps . set String ( 4, ▁addedInfo ); ▁ps . execute Update (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁a ▁list ▁of ▁all ▁transactions ▁in ▁which ▁an ▁HCP ▁accessed ▁the ▁given ▁patient ' s ▁record ▁* ▁* ▁@ param ▁patientID ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ return ▁A ▁java . util . List ▁of ▁transactions . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < TransactionBean > ▁getAll Record Accesse s ( long ▁patientID , ▁boolean ▁get ByRole ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn ▁ . prepare Statement (" SEL ECT ▁* ▁FROM ▁TransactionLog ▁ WH ERE ▁secondaryMID =? ▁AND ▁transactionCode ▁" ▁+ ▁" IN (" ▁+ ▁TransactionType . patient ViewableStr ▁+ ▁" ) ▁OR DER ▁ BY ▁timeLogged ▁DESC "); ▁ps . s etLong ( 1, ▁patientID ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁List < TransactionBean > ▁tbList ▁= ▁loader . load List ( rs ); ▁tbList ▁= ▁add AndS or tRoles ( tbList , ▁patientID , ▁get ByRole ); ▁return ▁tbList ; ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁The ▁Mo st ▁ Th or ou g h ▁F et c h ▁* ▁@ param ▁loggedInRole ▁Role ▁of ▁logged In ▁* ▁@ param ▁secondaryRole ▁Role ▁of ▁secondary ▁* ▁@ param ▁begin ▁Begin n ing ▁of ▁date ▁range ▁* ▁@ param ▁end ▁End ▁of ▁date ▁range ▁* ▁@ param ▁type ▁Type ▁of ▁transaction ▁* ▁@ return ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < TransactionBean > ▁get Transactions For ( String ▁loggedInRole , ▁String ▁secondaryRole , ▁Date ▁begin , ▁Date ▁end , ▁TransactionType ▁type ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁if ( log g ed In Role . compareTo (" a ny ") ▁== ▁0) ▁{ ▁loggedInRole ▁= ▁" * "; ▁} ▁if ( second ary Role . compareTo (" a ny ") ▁== ▁0) ▁{ ▁secondaryRole ▁= ▁" * "; ▁} ▁ps ▁= ▁conn ▁ . prepare Statement (" SEL ECT ▁* ▁FROM ▁TransactionLog , ▁User s ▁ WH ERE ▁( MID = loggedInMID ▁OR ▁MID = s econdaryMID ) ▁AND ▁( Role =? ▁OR ▁Role =? ) ▁" ▁+ ▁" ▁AND ▁transactionCode =? ▁AND ▁timeLogged ▁>= ▁? ▁AND ▁timeLogged ▁< = ▁? " ▁+ ▁" ▁OR DER ▁ BY ▁timeLogged ▁DESC "); ▁ps . set String ( 1, ▁loggedInRole ); ▁ps . set String (2, ▁secondaryRole ); ▁ps . set Int ( 3, ▁type . get Code ()); ▁ps . setDate ( 4, ▁begin ); ▁ps . setDate (5, ▁end ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁List < TransactionBean > ▁tbList ▁= ▁loader . load List ( rs ); ▁// tbList ▁= ▁add AndS or tRoles ( tbList , ▁patientID , ▁get ByRole ); ▁return ▁tbList ; ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁a ▁list ▁of ▁all ▁transactions ▁in ▁which ▁an ▁HCP ▁accessed ▁the ▁given ▁patient ' s ▁record , ▁within ▁the ▁dates ▁* ▁* ▁@ param ▁patientID ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ param ▁lower ▁The ▁start ing ▁date ▁as ▁a ▁java . util . Date ▁* ▁@ param ▁upper ▁The ▁ ending ▁date ▁as ▁a ▁java . util . Date ▁* ▁@ return ▁A ▁java . util . List ▁of ▁transactions . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < TransactionBean > ▁get Record Accesse s ( long ▁patientID , ▁java . util . Date ▁lower , ▁java . util . Date ▁upper , ▁boolean ▁get ByRole ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn ▁ . prepare Statement (" SEL ECT ▁* ▁FROM ▁TransactionLog ▁ WH ERE ▁secondaryMID =? ▁AND ▁transactionCode ▁IN ▁ (" ▁+ ▁TransactionType . patient ViewableStr ▁+ ▁" ) ▁" ▁+ ▁" AND ▁timeLogged ▁>= ▁? ▁AND ▁timeLogged ▁< = ▁? ▁OR DER ▁ BY ▁timeLogged ▁DESC "); ▁ps . s etLong ( 1, ▁patientID ); ▁ps . set Timestamp (2, ▁new ▁Timestamp ( lower . getTime ()) ); ▁// ▁add ▁1 ▁day ' s ▁wor th ▁to ▁include ▁the ▁upper ▁ps . set Timestamp ( 3, ▁new ▁Timestamp ( upper . getTime () ▁+ ▁1000 L ▁* ▁60 L ▁* ▁60 ▁* ▁24 L )); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁List < TransactionBean > ▁tbList ▁= ▁loader . load List ( rs ); ▁tbList ▁= ▁add AndS or tRoles ( tbList , ▁patientID , ▁get ByRole ); ▁return ▁tbList ; ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Returns ▁the ▁operation ▁profile ▁* ▁* ▁@ return ▁The ▁Ope rationalProfile ▁as ▁a ▁bean . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁Ope rationalProfile ▁get Ope rationalProfile () ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁ Transaction Code , ▁count ( transactionID ) ▁as ▁ TotalCount , ▁" ▁+ ▁" count ( if ( loggedInMID < 90 0000 0000 , ▁transactionID , ▁null )) ▁as ▁ PatientCount , ▁" ▁+ ▁" count ( if ( loggedInMID > =900000000 0 , ▁transactionID , ▁null )) ▁as ▁ PersonnelCount ▁" ▁+ ▁" FROM ▁TransactionLog ▁ GROUP ▁ BY ▁transactionCode ▁OR DER ▁ BY ▁transactionCode ▁ASC "); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁operation alProfileLoader . loadSingle ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁* ▁@ param ▁tbList ▁* ▁@ param ▁patientID ▁* ▁@ param ▁sort ByRole ▁* ▁@ return ▁* ▁@ throw s ▁DBException ▁*/ ▁private ▁List < TransactionBean > ▁add AndS or tRoles ( List < TransactionBean > ▁tbList , ▁long ▁patientID , ▁boolean ▁sort ByRole ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁for ( TransactionBean ▁t ▁: ▁tbList ) ▁{ ▁ps ▁= ▁conn ▁ . prepare Statement (" SEL ECT ▁Role ▁FROM ▁User s ▁ WH ERE ▁MID =?" ); ▁ps . s etLong ( 1, ▁t . get LoggedInMID ()); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁String ▁role ▁= ▁""; ▁if ( rs . next ()) ▁role ▁= ▁rs . get String (" Role "); ▁if ( role . equals (" er ")) ▁role ▁= ▁" Emergency ▁Responder "; ▁else ▁if ( role . equals (" uap ")) ▁role ▁= ▁" UAP "; ▁else ▁if ( role . equals (" hcp ")) ▁{ ▁role ▁= ▁" LHCP "; ▁ps ▁= ▁conn ▁ . prepare Statement (" SEL ECT ▁PatientID ▁FROM ▁DeclaredHCP ▁ WH ERE ▁HCPID =?" ); ▁ps . s etLong ( 1, ▁t . get LoggedInMID ()); ▁ResultSet ▁rs 2 ▁= ▁ps . execute Query (); ▁while ( rs 2 . next ()) ▁{ ▁if ▁( rs 2 . getLong (" PatientID ") ▁== ▁patientID ){ ▁role ▁= ▁" DLHCP "; ▁break ; ▁} ▁} ▁} ▁else ▁if ( role . equals (" patient ")){ ▁role ▁= ▁" Patient "; ▁ps ▁= ▁conn ▁ . prepare Statement (" SEL ECT ▁representee MID ▁FROM ▁Representatives ▁ WH ERE ▁representer MID =?" ); ▁ps . s etLong ( 1, ▁t . get LoggedInMID ()); ▁ResultSet ▁rs 2 ▁= ▁ps . execute Query (); ▁while ( rs 2 . next ()) ▁{ ▁if ▁( rs 2 . getLong (" representee MID ") ▁== ▁patientID ){ ▁role ▁= ▁" Person al ▁Health ▁ Representative "; ▁break ; ▁} ▁} ▁} ▁t . set Role ( role ); ▁} ▁if ( sortBy Role ){ ▁TransactionBean [ ] ▁array ▁= ▁new ▁TransactionBean [ tbList . size () ] ; ▁array [0 ] ▁= ▁tbList . get (0); ▁TransactionBean ▁t ; ▁for ( int ▁i ▁= ▁1; ▁i ▁< ▁tbList . size (); ▁i ++) ▁{ ▁t ▁= ▁tbList . get ( i ); ▁String ▁role ▁= ▁t . getRole (); ▁int ▁j ▁= ▁0; ▁while ( array [ j ] ▁ != ▁null ▁&& ▁role . compareTo I gnore Case ( array [ j ] . getRole ()) ▁>= ▁0) ▁j ++; ▁for ( int ▁k ▁= ▁i ; ▁k ▁> ▁j ; ▁k -- ) ▁{ ▁array [ k ] ▁= ▁array [ k -1 ] ; ▁} ▁array [ j ] ▁= ▁t ; ▁} ▁int ▁size ▁= ▁tbList . size (); ▁for ( int ▁i ▁= ▁0; ▁i ▁< ▁size ; ▁i ++) ▁tbList . set ( i , ▁array [ i ] ); ▁} ▁return ▁tbList ; ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁}