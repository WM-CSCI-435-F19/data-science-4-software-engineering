▁p ackage ▁edu . nc su . cs c . itrust . dao . mysql ; ▁import ▁java . sql . Connection ; ▁import ▁java . sql . P reparedStatement ; ▁import ▁java . sql . ResultSet ; ▁import ▁java . sql . SQLException ; ▁import ▁java . util . List ; ▁import ▁java . util . Vector ; ▁import ▁edu . nc su . cs c . itrust . DBUtil ; ▁import ▁edu . nc su . cs c . itrust . beans . DiagnosisBean ; ▁import ▁edu . nc su . cs c . itrust . beans . PatientBean ; ▁import ▁edu . nc su . cs c . itrust . beans . PersonnelBean ; ▁import ▁edu . nc su . cs c . itrust . beans . PrescriptionBean ; ▁import ▁edu . nc su . cs c . itrust . beans . ProcedureBean ; ▁import ▁edu . nc su . cs c . itrust . beans . loaders . DiagnosisBean Loader ; ▁import ▁edu . nc su . cs c . itrust . beans . loaders . Patient Loader ; ▁import ▁edu . nc su . cs c . itrust . beans . loaders . Personnel Loader ; ▁import ▁edu . nc su . cs c . itrust . beans . loaders . PrescriptionBean Loader ; ▁import ▁edu . nc su . cs c . itrust . beans . loaders . ProcedureBean Loader ; ▁import ▁edu . nc su . cs c . itrust . dao . DAOFactory ; ▁import ▁edu . nc su . cs c . itrust . exception . DBException ; ▁import ▁edu . nc su . cs c . itrust . exception . iTrustException ; ▁import ▁edu . nc su . cs c . itrust . Date U ti l ; ▁/** ▁* ▁Used ▁for ▁ managing ▁all ▁static ▁information ▁relat ed ▁to ▁a ▁patient . ▁For ▁other ▁information ▁relat ed ▁to ▁all ▁as p e ct s ▁* ▁of ▁patient ▁care , ▁see ▁the ▁other ▁DAOs . ▁* ▁* ▁DAO ▁stand s ▁for ▁Database ▁Access ▁Object . ▁All ▁DAOs ▁are ▁intended ▁to ▁be ▁ref lections ▁of ▁the ▁database , ▁that ▁is , ▁* ▁one ▁DAO ▁per ▁table ▁in ▁the ▁database ▁( most ▁of ▁the ▁time ) . ▁For ▁more ▁comple x ▁sets ▁of ▁queries , ▁extra ▁DAOs ▁are ▁* ▁added . ▁DAOs ▁can ▁assume ▁that ▁all ▁data ▁has ▁been ▁validated ▁and ▁is ▁correct . ▁* ▁* ▁DAOs ▁should ▁n ever ▁have ▁setter s ▁or ▁any ▁other ▁parameter ▁to ▁the ▁constructor ▁than ▁a ▁factory . ▁All ▁DAOs ▁should ▁be ▁* ▁accessed ▁by ▁DAOFactory ▁( @ see ▁ {@ link ▁DAOFactory }) ▁and ▁every ▁DAO ▁should ▁have ▁a ▁factory ▁- ▁for ▁obtain ing ▁JDBC ▁* ▁connections ▁and / or ▁access ing ▁other ▁DAOs . ▁* ▁* ▁@ author ▁Andy ▁* ▁*/ ▁public ▁class ▁PatientDAO ▁{ ▁private ▁DAOFactory ▁factory ; ▁private ▁PatientLoader ▁patientLoader ; ▁private ▁PersonnelLoader ▁personnelLoader ; ▁private ▁DiagnosisBean Loader ▁diagnosisLoader ; ▁private ▁Prescription BeanLoader ▁prescription Loader ; ▁private ▁ProcedureBean Loader ▁procedureLoader ; ▁/** ▁* ▁The ▁typical ▁constructor . ▁* ▁@ param ▁factory ▁The ▁ {@ link ▁DAOFactory } ▁associate d ▁with ▁this ▁DAO , ▁which ▁is ▁used ▁for ▁obtain ing ▁SQL ▁connections , ▁etc . ▁*/ ▁public ▁PatientDAO ( DAOFactory ▁factory ) ▁{ ▁this . factory ▁= ▁factory ; ▁this . patient Loader ▁= ▁new ▁PatientLoader (); ▁this . personnel Loader ▁= ▁new ▁PersonnelLoader (); ▁this . diagnosis Loader ▁= ▁new ▁DiagnosisBean Loader ( true ); ▁this . prescription Loader ▁= ▁new ▁Prescription BeanLoader (); ▁this . procedure Loader ▁= ▁new ▁ProcedureBean Loader ( true ); ▁} ▁/** ▁* ▁Returns ▁the ▁name ▁for ▁the ▁given ▁MID ▁* ▁* ▁@ param ▁mid ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ return ▁A ▁String ▁representing ▁the ▁patient ' s ▁first ▁name ▁and ▁last ▁name . ▁* ▁@ throw s ▁iTrustException ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁String ▁getName ( long ▁mid ) ▁throw s ▁iTrustException , ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁firstName , ▁lastName ▁FROM ▁Patients ▁ WH ERE ▁MID =?" ); ▁ps . s etLong ( 1, ▁mid ); ▁ResultSet ▁rs ; ▁rs ▁= ▁ps . execute Query (); ▁if ▁( rs . next ()) ▁{ ▁return ▁rs . get String (" firstName ") ▁+ ▁" ▁" ▁+ ▁rs . get String (" lastName "); ▁} ▁else ▁{ ▁throw ▁new ▁iTrustException (" User ▁does ▁not ▁exist "); ▁} ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Returns ▁the ▁role ▁of ▁a ▁particular ▁patient ▁- ▁wh y ▁is ▁this ▁in ▁PatientDAO ? ▁It ▁should ▁be ▁in ▁AuthDAO ▁* ▁* ▁@ param ▁mid ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ param ▁role ▁A ▁String ▁representing ▁the ▁role ▁of ▁the ▁patient . ▁* ▁@ return ▁A ▁String ▁representing ▁the ▁patient ' s ▁role . ▁* ▁@ throw s ▁iTrustException ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁String ▁getRole ( long ▁mid , ▁String ▁role ) ▁throw s ▁iTrustException , ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁role ▁FROM ▁User s ▁ WH ERE ▁MID =? ▁AND ▁Role =?" ); ▁ps . s etLong ( 1, ▁mid ); ▁ps . set String (2, ▁role ); ▁ResultSet ▁rs ; ▁rs ▁= ▁ps . execute Query (); ▁if ▁( rs . next ()) ▁{ ▁return ▁rs . get String (" role "); ▁} ▁else ▁{ ▁throw ▁new ▁iTrustException (" User ▁does ▁not ▁exist ▁with ▁the ▁designated ▁role "); ▁} ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Add s ▁an ▁empty ▁patient ▁to ▁the ▁table , ▁return s ▁the ▁new ▁MID ▁* ▁* ▁@ return ▁The ▁MID ▁of ▁the ▁patient ▁as ▁a ▁long . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁long ▁ addEmpty Patient () ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" INSERT ▁INT O ▁Patients ( MID ) ▁VALUES ( NULL )"); ▁ps . execute Update (); ▁return ▁DBUtil . getLast Insert ( conn ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Returns ▁the ▁patient ' s ▁information ▁for ▁a ▁given ▁ID ▁* ▁* ▁@ param ▁mid ▁The ▁MID ▁of ▁the ▁patient ▁to ▁retrieve . ▁* ▁@ return ▁A ▁PatientBean ▁representing ▁the ▁patient . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁PatientBean ▁getPatient ( long ▁mid ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁Patients ▁ WH ERE ▁MID ▁= ▁? "); ▁ps . s etLong ( 1, ▁mid ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁// ▁p dao . log Transaction ( type , ▁loggedInMID , ▁secondaryMID , ▁addedInfo ) ▁if ▁( rs . next ()) ▁{ ▁return ▁patientLoader . loadSingle ( rs ); ▁} ▁else ▁return ▁null ; ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Updates ▁a ▁patient ' s ▁information ▁for ▁the ▁given ▁MID ▁* ▁* ▁@ param ▁p ▁The ▁patient ▁bean ▁representing ▁the ▁new ▁information ▁for ▁the ▁patient . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁void ▁ editPatient ( PatientBean ▁p ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" UPDATE ▁Patients ▁SET ▁firstName =?, lastName =?, email =?, " ▁+ ▁" address 1=?, address 2=?, city =?, state =?, zip 1=?, ▁zip 2=?, phone 1=?, phone 2=?, phone 3=?, " ▁+ ▁" e Name =?, ePhone 1=?, ePhone 2=?, ePhone 3=?, i C Name =?, i C Address 1=?, i C Address 2=?, i C City =?, " ▁+ ▁" I C State =?, i C Zip 1=?, ▁i C Zip 2=?, ▁ iCPhone 1=?, iCPhone 2=?, iCPhone 3=?, i C ID =?, Date Of Birth =?, " ▁+ ▁" DateOfDeath =?, CauseOfDeath =?, MotherMID =?, FatherMID =?, " ▁+ ▁" BloodType =?, Ethnicity =?, Gender =?, TopicalNotes =?, ▁ CreditCardType =?, ▁ CreditCardNumber =?, ▁ MessageFilter =? ▁ WH ERE ▁MID =?" ); ▁patientLoader . load Parameters ( ps , ▁p ); ▁ps . s etLong ( 40 , ▁p . get MID ()); ▁ps . execute Update (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Returns ▁whether ▁or ▁not ▁the ▁patient ▁exists ▁* ▁* ▁@ param ▁pid ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ return ▁A ▁boolean ▁indicat ing ▁whether ▁the ▁patient ▁exists . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁boolean ▁check Patient E xists ( long ▁pid ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁Patients ▁ WH ERE ▁MID =?" ); ▁ps . s etLong ( 1, ▁pid ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁rs . next (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Returns ▁a ▁list ▁of ▁HCPs ▁who ▁are ▁declared ▁by ▁the ▁given ▁patient ▁* ▁* ▁@ param ▁pid ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ return ▁A ▁java . util . List ▁of ▁Personnel ▁ Bean s . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < PersonnelBean > ▁ getDeclaredHCP s ( long ▁pid ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁if ▁( pid ▁== ▁0 L ) ▁throw ▁new ▁SQLException (" pid ▁cannot ▁be ▁0 "); ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁DeclaredHCP , ▁Personnel ▁" ▁+ ▁" WH ERE ▁PatientID =? ▁AND ▁Personnel . MID = DeclaredHCP . HCPID "); ▁ps . s etLong ( 1, ▁pid ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁personnelLoader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁ De c la re s ▁an ▁HCP ▁for ▁a ▁particular ▁patient ▁* ▁* ▁@ param ▁pid ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ param ▁hcpID ▁The ▁HCP ' s ▁MID . ▁* ▁@ return ▁A ▁boolean ▁as ▁to ▁whether ▁the ▁insert ion ▁was ▁successful . ▁* ▁@ throw s ▁DBException ▁* ▁@ throw s ▁iTrustException ▁*/ ▁public ▁boolean ▁declare HCP ( long ▁pid , ▁long ▁hcpID ) ▁throw s ▁DBException , ▁iTrustException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" INSERT ▁INT O ▁DeclaredHCP ( PatientID , ▁HCPID ) ▁VALUES (?,? )"); ▁ps . s etLong ( 1, ▁pid ); ▁ps . s etLong (2, ▁hcpID ); ▁return ▁1 ▁== ▁ps . execute Update (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁if ▁(1 062 ▁== ▁e . get ErrorCode ()) ▁throw ▁new ▁iTrustException (" HCP ▁" ▁+ ▁hcpID ▁+ ▁" ▁has ▁already ▁been ▁declared ▁for ▁patient ▁" ▁+ ▁pid ); ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Un de c la re ▁an ▁HCP ▁for ▁a ▁given ▁patient ▁* ▁* ▁@ param ▁pid ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ param ▁hcpID ▁The ▁MID ▁of ▁the ▁HCP ▁in ▁question . ▁* ▁@ return ▁A ▁boolean ▁indicat ing ▁whether ▁the ▁action ▁was ▁successful . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁boolean ▁undeclare HCP ( long ▁pid , ▁long ▁hcpID ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" DE LETE ▁FROM ▁DeclaredHCP ▁ WH ERE ▁PatientID =? ▁AND ▁HCPID =?" ); ▁ps . s etLong ( 1, ▁pid ); ▁ps . s etLong (2, ▁hcpID ); ▁return ▁1 ▁== ▁ps . execute Update (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Check ▁if ▁a ▁patient ▁has ▁declared ▁the ▁given ▁HCP ▁* ▁* ▁@ param ▁pid ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question ▁as ▁a ▁long . ▁* ▁@ param ▁hcpid ▁The ▁MID ▁of ▁the ▁HCP ▁in ▁question ▁as ▁a ▁long . ▁* ▁@ return ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁boolean ▁check DeclaredHCP ( long ▁pid , ▁long ▁hcpid ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁DeclaredHCP ▁ WH ERE ▁PatientID =? ▁AND ▁HCPID =?" ); ▁ps . s etLong ( 1, ▁pid ); ▁ps . s etLong (2, ▁hcpid ); ▁return ▁ps . execute Query (). next (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁a ▁list ▁of ▁patients ▁that ▁the ▁given ▁patient ▁represents ▁* ▁* ▁@ param ▁pid ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ return ▁A ▁java . util . List ▁of ▁PatientBeans ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < PatientBean > ▁get Represented ( long ▁pid ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁Patients .* ▁FROM ▁Representatives , ▁Patients ▁" ▁+ ▁" WH ERE ▁ RepresenterMID =? ▁AND ▁ RepresenteeMID = Patients . MID "); ▁ps . s etLong ( 1, ▁pid ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁patientLoader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁a ▁list ▁of ▁patients ▁that ▁the ▁given ▁patient ▁is ▁represented ▁by ▁* ▁* ▁@ param ▁pid ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ return ▁A ▁java . util . List ▁of ▁PatientBeans . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < PatientBean > ▁get Representing ( long ▁pid ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁Patients .* ▁FROM ▁Representatives , ▁Patients ▁" ▁+ ▁" WH ERE ▁ RepresenteeMID =? ▁AND ▁ RepresenterMID = Patients . MID "); ▁ps . s etLong ( 1, ▁pid ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁patientLoader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Check ▁if ▁the ▁given ▁representer ▁represents ▁the ▁representee ▁* ▁* ▁@ param ▁representer ▁The ▁MID ▁of ▁the ▁representer ▁in ▁question . ▁* ▁@ param ▁representee ▁The ▁MID ▁of ▁the ▁representee ▁in ▁question . ▁* ▁@ return ▁A ▁boolean ▁indicat ing ▁whether ▁re pres en ation ▁is ▁in ▁place . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁boolean ▁represents ( long ▁representer , ▁long ▁representee ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn ▁ . prepare Statement (" SEL ECT ▁* ▁FROM ▁Representatives ▁ WH ERE ▁ RepresenterMID =? ▁AND ▁ RepresenteeMID =?" ); ▁ps . s etLong ( 1, ▁representer ); ▁ps . s etLong (2, ▁representee ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁rs . next (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Assign ▁a ▁representer ▁to ▁the ▁representee ▁* ▁* ▁@ param ▁representer ▁The ▁MID ▁of ▁the ▁representer ▁as ▁a ▁long . ▁* ▁@ param ▁representee ▁The ▁MID ▁of ▁the ▁representee ▁as ▁a ▁long . ▁* ▁@ return ▁A ▁boolean ▁as ▁to ▁whether ▁the ▁insert ion ▁was ▁correct . ▁* ▁@ throw s ▁DBException ▁* ▁@ throw s ▁iTrustException ▁*/ ▁public ▁boolean ▁add Representative ( long ▁representer , ▁long ▁representee ) ▁throw s ▁DBException , ▁iTrustException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn ▁ . prepare Statement (" INSERT ▁INT O ▁Representatives ( RepresenterMID , RepresenteeMID ) ▁VALUES ▁(?,? )"); ▁ps . s etLong ( 1, ▁representer ); ▁ps . s etLong (2, ▁representee ); ▁return ▁1 ▁== ▁ps . execute Update (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁if ▁(1 062 ▁== ▁e . get ErrorCode ()) ▁throw ▁new ▁iTrustException (" Patient ▁" ▁+ ▁representer ▁+ ▁" ▁already ▁represents ▁patient ▁" ▁+ ▁representee ); ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Un assign ▁the ▁representation ▁* ▁* ▁@ param ▁representer ▁The ▁MID ▁of ▁the ▁representer ▁in ▁question . ▁* ▁@ param ▁representee ▁The ▁MID ▁of ▁the ▁representee ▁in ▁question . ▁* ▁@ return ▁A ▁boolean ▁indicat ing ▁whether ▁the ▁un assign ment ▁was ▁suc es s f ul . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁boolean ▁remove Representative ( long ▁representer , ▁long ▁representee ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn ▁ . prepare Statement (" DE LETE ▁FROM ▁Representatives ▁ WH ERE ▁ RepresenterMID =? ▁AND ▁ RepresenteeMID =?" ); ▁ps . s etLong ( 1, ▁representer ); ▁ps . s etLong (2, ▁representee ); ▁return ▁1 ▁== ▁ps . execute Update (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁a ▁list ▁of ▁all ▁diagnoses ▁for ▁a ▁given ▁patient ▁* ▁* ▁@ param ▁pid ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ return ▁A ▁java . util . List ▁of ▁Diagnoses . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < DiagnosisBean > ▁getDiagnose s ( long ▁pid ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁if ▁( pid ▁== ▁0 L ) ▁throw ▁new ▁SQLException (" pid ▁cannot ▁be ▁0 "); ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁OVDiagnosis ▁ovd , ▁OfficeVisits ▁ov , ▁ICDCodes ▁icd ▁" ▁+ ▁" WH ERE ▁ovd . VisitID = ov . ID ▁and ▁icd . Code = ov d . ICDCode ▁and ▁ov . PatientID =? ▁" ▁+ ▁" OR DER ▁ BY ▁ov . visitDate ▁DESC "); ▁ps . s etLong ( 1, ▁pid ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁diagnosisLoader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁a ▁list ▁of ▁all ▁procedures ▁for ▁a ▁given ▁patient ▁* ▁* ▁@ param ▁pid ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ return ▁A ▁java . util . List ▁of ▁all ▁the ▁procedures . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < ProcedureBean > ▁getProcedure s ( long ▁pid ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁if ▁( pid ▁== ▁0 L ) ▁throw ▁new ▁SQLException (" pid ▁cannot ▁be ▁0 "); ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" Select ▁* ▁From ▁ OVProcedure ▁ovp , ▁OfficeVisits ▁ov , ▁CPTCodes ▁cpt ▁" ▁+ ▁" W here ▁ovp . VisitID = ov . ID ▁and ▁cpt . code = ov p . cptcode ▁and ▁ov . patientID =? ▁" ▁+ ▁" OR DER ▁ BY ▁ov . visitDate ▁ desc "); ▁ps . s etLong ( 1, ▁pid ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁procedureLoader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁a ▁list ▁of ▁all ▁immunization ▁procedures ▁for ▁a ▁given ▁patient ▁* ▁* ▁@ param ▁pid ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ return ▁A ▁java . util . List ▁of ▁the ▁procedures . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < ProcedureBean > ▁getImmunization Procedures ( long ▁pid ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁if ▁( pid ▁== ▁0 L ) ▁throw ▁new ▁SQLException (" pid ▁cannot ▁be ▁0 "); ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" Select ▁* ▁From ▁ OVProcedure ▁ovp , ▁OfficeVisits ▁ov , ▁CPTCodes ▁cpt ▁" ▁+ ▁" W here ▁ovp . VisitID = ov . ID ▁and ▁cpt . code = ov p . cptcode ▁and ▁ov . patientID =? ▁and ▁cpt . attribute =' immunization ' " ▁+ ▁" OR DER ▁ BY ▁ov . visitDate ▁ desc "); ▁ps . s etLong ( 1, ▁pid ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁procedureLoader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁a ▁list ▁of ▁all ▁prescriptions ▁for ▁a ▁patient ▁* ▁* ▁@ param ▁patientID ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ return ▁A ▁java . util . List ▁of ▁prescriptions . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < PrescriptionBean > ▁ getPrescriptions ( long ▁patientID ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁if ▁( patientID ▁== ▁0 L ) ▁throw ▁new ▁SQLException (" pid ▁cannot ▁be ▁0 "); ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" Select ▁* ▁From ▁OVMedication , NDCodes , OfficeVisits ▁" ▁+ ▁" W here ▁OfficeVisits . PatientID ▁= ▁? ▁AND ▁OVMedication . VisitID ▁= ▁" ▁+ ▁" OfficeVisits . ID ▁AND ▁NDCodes . Code = OVMedication . NDCode ▁" ▁+ ▁" OR DER ▁ BY ▁OfficeVisits . visitDate ▁DESC , ▁OVMedication . NDCode ▁ASC ; "); ▁ps . s etLong ( 1, ▁patientID ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁prescription Loader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁a ▁list ▁of ▁prescriptions ▁which ▁are ▁currently ▁prescribed ▁for ▁a ▁patient ▁* ▁* ▁@ param ▁patientID ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ return ▁A ▁java . util . List ▁of ▁prescription ▁beans . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < PrescriptionBean > ▁ getCurrent Prescriptions ( long ▁patientID ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁if ▁( patientID ▁== ▁0 L ) ▁throw ▁new ▁SQLException (" pid ▁cannot ▁be ▁0 "); ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" Select ▁* ▁From ▁OVMedication , NDCodes , OfficeVisits ▁" ▁+ ▁" W here ▁OfficeVisits . PatientID ▁= ▁? ▁AND ▁OVMedication . VisitID ▁= ▁" ▁+ ▁" OfficeVisits . ID ▁AND ▁NDCodes . Code = OVMedication . NDCode ▁AND ▁" ▁+ ▁" OVMedication . EndDate ▁>= ▁? " ▁+ ▁" OR DER ▁ BY ▁OVMedication . ID ▁DESC ; "); ▁ps . s etLong ( 1, ▁patientID ); ▁ps . setDate (2, ▁DateUtil . getSQLdateX Day sAgo From Now ( 91 )); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁prescription Loader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁a ▁list ▁of ▁prescriptions ▁which ▁are ▁expired ▁prescription ▁for ▁a ▁patient ▁* ▁* ▁@ param ▁patientID ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ return ▁A ▁java . util . List ▁of ▁prescriptions . ▁* ▁@ throw s ▁DBException ▁** / ▁public ▁List < PrescriptionBean > ▁get Expired Prescriptions ▁( long ▁patientID ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁if ▁( patientID ▁== ▁0 L ) ▁throw ▁new ▁SQLException (" pid ▁cannot ▁be ▁0 "); ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" Select ▁* ▁From ▁OVMedication , NDCodes , OfficeVisits ▁" ▁+ ▁" W here ▁OfficeVisits . PatientID ▁= ▁? ▁AND ▁OVMedication . VisitID ▁= ▁" ▁+ ▁" OfficeVisits . ID ▁AND ▁NDCodes . Code = OVMedication . NDCode ▁AND ▁" ▁+ ▁" OVMedication . EndDate ▁< ▁? " ▁+ ▁" OR DER ▁ BY ▁OVMedication . ID ▁DESC ; "); ▁ps . s etLong ( 1, ▁patientID ); ▁ps . setDate (2, ▁DateUtil . getSQLdateX Day sAgo From Now (0) ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁prescription Loader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁List s ▁every ▁patient ▁in ▁the ▁database . ▁* ▁* ▁@ return ▁A ▁java . util . List ▁of ▁PatientBeans ▁representing ▁the ▁patients . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < PatientBean > ▁getAll Patients () ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁patients ▁" ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁patientLoader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Return ▁a ▁list ▁of ▁patients ▁with ▁a ▁special - diagnosis - h istory ▁who ▁* ▁have ▁the ▁logged ▁in ▁HCP ▁as ▁a ▁D HCP ▁and ▁who se ▁medications ▁are ▁go ing ▁to ▁* ▁expire ▁within ▁seve n ▁days . ▁* ▁* ▁@ param ▁hcpMID ▁The ▁MID ▁of ▁the ▁logged ▁in ▁HCP ▁* ▁@ return ▁A ▁list ▁of ▁patients ▁satisf y ing ▁the ▁conditions . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < PatientBean > ▁get RenewalNeeds Patients ( long ▁hcpMID ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁( ▁" ▁+ ▁" SEL ECT ▁DISTINCT ▁patients .* ▁From ▁patients , ▁declaredhcp , ▁ovdiagnosis , ▁officevisits , ▁ovmedication ▁" ▁+ ▁" W here ▁" ▁+ ▁" de cl ar ed HCP . HCPID ▁= ▁? ▁AND ▁" ▁+ ▁" patients . MID ▁= ▁declaredhcp . PatientID ▁AND ▁" ▁+ ▁" ( ▁" ▁+ ▁" ovdiagnosis . VisitID ▁= ▁officevisits . ID ▁AND ▁officevisits . PatientID ▁= ▁declaredhcp . PatientID ▁" ▁+ ▁" AND ▁" ▁+ ▁" ( ( ovdiagnosis . ICDCode ▁>= ▁? ▁AND ▁ovdiagnosis . ICDCode ▁< ▁? ) ▁" ▁+ ▁" OR ▁( ovdiagnosis . ICDCode ▁>= ▁? ▁AND ▁ovdiagnosis . ICDCode ▁< ▁? ) ▁" ▁+ ▁" OR ▁( ovdiagnosis . ICDCode ▁>= ▁? ▁AND ▁ovdiagnosis . ICDCode ▁< ▁? )) ▁" ▁+ ▁" ) ▁" ▁+ ▁" UN ION ▁ ALL ▁" ▁+ ▁" SEL ECT ▁DISTINCT ▁patients .* ▁From ▁patients , ▁declaredhcp , ▁ovdiagnosis , ▁officevisits , ▁ovmedication ▁" ▁+ ▁" W here ▁" ▁+ ▁" de cl ar ed HCP . HCPID ▁= ▁? ▁AND ▁" ▁+ ▁" patients . MID ▁= ▁declaredhcp . PatientID ▁AND ▁" ▁+ ▁" ( ▁" ▁+ ▁" de cl ar ed hcp . PatientID ▁= ▁officevisits . PatientID ▁AND ▁officevisits . ID ▁= ▁ovmedication . VisitID ▁" ▁+ ▁" AND ▁" ▁+ ▁" ov medication . EndDate ▁BE TW EEN ▁CU R DATE () ▁AND ▁DATE _ ADD ( CUR DATE (), ▁ INTERVAL ▁ 7 ▁DAY ) ▁" ▁+ ▁" ) ▁" ▁+ ▁" ) ▁AS ▁final ▁" ▁+ ▁" GROUP ▁ BY ▁final . MID ▁HAV ING ▁C O U NT ( *) ▁= ▁2 ▁" ▁+ ▁" OR DER ▁ BY ▁final . lastname ▁ASC , ▁final . firstname ▁ASC "); ▁ps . s etLong ( 1, ▁hcpMID ); ▁ps . set Float (2, ▁250.0 f ); ▁ps . set Float ( 3, ▁251.0 f ); ▁ps . set Float ( 4, ▁ 493.0 f ); ▁ps . set Float (5, ▁4 94 . 0 f ); ▁ps . set Float (6, ▁390.0 f ); ▁ps . set Float ( 7, ▁4 6 0 . 99 f ); ▁ps . s etLong ( 8, ▁hcpMID ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁patientLoader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Returns ▁all ▁patients ▁with ▁names ▁" LIKE " ▁( a s ▁in ▁SQL ) ▁the ▁passed ▁in ▁parameters . ▁* ▁* ▁@ param ▁first ▁The ▁patient ' s ▁first ▁name . ▁* ▁@ param ▁last ▁The ▁patient ' s ▁last ▁name . ▁* ▁@ return ▁A ▁java . util . List ▁of ▁PatientBeans . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < PatientBean > ▁ searchFor Patient sWith Name ( String ▁first , ▁String ▁last ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁if ▁( first . equals ("%") ▁&& ▁last . equals ("%") ) ▁return ▁new ▁ Vector < PatientBean > (); ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁patients ▁ WH ERE ▁firstName ▁ LIKE ▁? ▁AND ▁lastName ▁ LIKE ▁? "); ▁ps . set String ( 1, ▁first ); ▁ps . set String (2, ▁last ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁patientLoader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁}