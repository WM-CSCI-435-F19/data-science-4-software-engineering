▁p ackage ▁edu . nc su . cs c . itrust . dao . mysql ; ▁import ▁java . sql . Connection ; ▁import ▁java . sql . P reparedStatement ; ▁import ▁java . sql . ResultSet ; ▁import ▁java . sql . SQLException ; ▁import ▁java . util . List ; ▁import ▁edu . nc su . cs c . itrust . DBUtil ; ▁import ▁edu . nc su . cs c . itrust . beans . FamilyMemberBean ; ▁import ▁edu . nc su . cs c . itrust . beans . loaders . FamilyBeanLoader ; ▁import ▁edu . nc su . cs c . itrust . dao . DAOFactory ; ▁import ▁edu . nc su . cs c . itrust . exception . DBException ; ▁/** ▁* ▁Used ▁for ▁queries ▁relat ed ▁to ▁fam i li es . ▁* ▁* ▁DAO ▁stand s ▁for ▁Database ▁Access ▁Object . ▁All ▁DAOs ▁are ▁intended ▁to ▁be ▁ref lections ▁of ▁the ▁database , ▁that ▁is , ▁* ▁one ▁DAO ▁per ▁table ▁in ▁the ▁database ▁( most ▁of ▁the ▁time ) . ▁For ▁more ▁comple x ▁sets ▁of ▁queries , ▁extra ▁DAOs ▁are ▁* ▁added . ▁DAOs ▁can ▁assume ▁that ▁all ▁data ▁has ▁been ▁validated ▁and ▁is ▁correct . ▁* ▁* ▁DAOs ▁should ▁n ever ▁have ▁setter s ▁or ▁any ▁other ▁parameter ▁to ▁the ▁constructor ▁than ▁a ▁factory . ▁All ▁DAOs ▁should ▁be ▁* ▁accessed ▁by ▁DAOFactory ▁( @ see ▁ {@ link ▁DAOFactory }) ▁and ▁every ▁DAO ▁should ▁have ▁a ▁factory ▁- ▁for ▁obtain ing ▁JDBC ▁* ▁connections ▁and / or ▁access ing ▁other ▁DAOs . ▁* ▁* ▁@ author ▁Andy ▁* ▁*/ ▁public ▁class ▁FamilyDAO ▁{ ▁private ▁DAOFactory ▁factory ; ▁private ▁ FamilyBeanLoader ▁family BeanLoader ; ▁/** ▁* ▁The ▁typical ▁constructor . ▁* ▁@ param ▁factory ▁The ▁ {@ link ▁DAOFactory } ▁associate d ▁with ▁this ▁DAO , ▁which ▁is ▁used ▁for ▁obtain ing ▁SQL ▁connections , ▁etc . ▁*/ ▁public ▁FamilyDAO ( DAOFactory ▁factory ) ▁{ ▁this . factory ▁= ▁factory ; ▁} ▁/** ▁* ▁Return ▁the ▁information ▁of ▁the ▁mother ▁and ▁father ▁of ▁this ▁patient ▁* ▁* ▁@ param ▁pid ▁- ▁* ▁this ▁patient ▁* ▁@ return ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < FamilyMemberBean > ▁getParent s ( long ▁pid ) ▁throw s ▁DBException ▁{ ▁return ▁getFamilyMember s ( pid , ▁" P ar ent ", ▁" SEL ECT ▁p 2 . FirstName ▁AS ▁ FirstName , ▁p 2 . LastName ▁AS ▁ LastName , ▁p 2 . MID ▁as ▁MID ▁" ▁+ ▁" FROM ▁Patients ▁p 1, ▁Patients ▁p 2 ▁" ▁+ ▁" WH ERE ▁p 1 . MID =? ▁AND ▁( p 1 . MotherMID = p 2 . MID ▁OR ▁p 1 . FatherMID = p 2 . MID )", ▁false ); ▁} ▁/** ▁* ▁Return ▁a ▁list ▁of ▁patients ▁who ▁share ▁at ▁least ▁one ▁parent ▁( and ▁that ▁parent ▁is ▁not ▁ '0' ) ▁with ▁this ▁patient ▁* ▁* ▁@ param ▁pid ▁- ▁* ▁this ▁patient ▁* ▁@ return ▁A ▁java . util . list ▁of ▁ FamilyMemberBean s . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < FamilyMemberBean > ▁get Siblings ( long ▁pid ) ▁throw s ▁DBException ▁{ ▁return ▁getFamilyMember s ( pid , ▁" S i b l ing ", ▁" SEL ECT ▁p 2 . FirstName ▁AS ▁ FirstName , ▁p 2 . LastName ▁AS ▁ LastName , ▁p 2 . MID ▁as ▁MID ▁" ▁+ ▁" FROM ▁Patients ▁p 1, ▁Patients ▁p 2 ▁" ▁+ ▁" WH ERE ▁p 1 . MID =? ▁AND ▁p 1 . MID < > p 2 . MID ▁" ▁+ ▁" AND ( ▁( p 1 . MotherMID = p 2 . MotherMID ▁AND ▁p 2 . MotherMID < > 0 ) " ▁+ ▁" ▁OR ▁( p 1 . FatherMID = p 2 . FatherMID ▁AND ▁p 1 . FatherMID < > 0 )) ", ▁false ); ▁} ▁/** ▁* ▁Return ▁a ▁list ▁of ▁patients ▁who se ▁mother ▁or ▁father ▁is ▁this ▁patient ▁* ▁* ▁@ param ▁pid ▁- ▁* ▁this ▁patient ▁* ▁@ return ▁A ▁java . util . List ▁of ▁ FamilyMemberBean s . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < FamilyMemberBean > ▁get Children ( long ▁pid ) ▁throw s ▁DBException ▁{ ▁return ▁getFamilyMember s ( pid , ▁" Child ", ▁" SEL ECT ▁ FirstName , ▁ LastName , ▁MID ▁FROM ▁Patients ▁" ▁+ ▁" WH ERE ▁ MotherMID =? ▁or ▁ FatherMID =?" , ▁true ); ▁} ▁/** ▁* ▁Private ▁ helper ▁method ▁( s ince ▁all ▁thre e ▁are ▁a li k e ) ▁* ▁* ▁@ param ▁pid ▁* ▁@ param ▁relation ▁* ▁@ param ▁query ▁* ▁@ param ▁ secondParam ▁- ▁* ▁add ▁the ▁pid ▁as ▁the ▁second ▁parameter ▁( the ▁3 rd ▁query ▁was ▁a ▁l it tle ▁different ) ▁* ▁* ▁@ return ▁A ▁java . util . List ▁of ▁ FamilyMemberBean s . ▁* ▁@ throw s ▁DBException ▁*/ ▁private ▁List < FamilyMemberBean > ▁getFamilyMember s ( long ▁pid , ▁String ▁relation , ▁String ▁query , ▁boolean ▁ secondParam ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁family BeanLoader ▁= ▁new ▁ FamilyBeanLoader ( relation ); ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement ( query ); ▁ps . s etLong ( 1, ▁pid ); ▁if ▁( secondParam ) ▁ps . s etLong (2, ▁pid ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁family BeanLoader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁}