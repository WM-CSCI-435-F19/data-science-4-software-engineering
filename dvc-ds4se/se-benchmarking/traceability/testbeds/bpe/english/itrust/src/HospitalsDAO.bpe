▁p ackage ▁edu . nc su . cs c . itrust . dao . mysql ; ▁import ▁java . sql . Connection ; ▁import ▁java . sql . P reparedStatement ; ▁import ▁java . sql . ResultSet ; ▁import ▁java . sql . SQLException ; ▁import ▁java . util . List ; ▁import ▁edu . nc su . cs c . itrust . DBUtil ; ▁import ▁edu . nc su . cs c . itrust . beans . HospitalBean ; ▁import ▁edu . nc su . cs c . itrust . beans . loaders . HospitalBean Loader ; ▁import ▁edu . nc su . cs c . itrust . dao . DAOFactory ; ▁import ▁edu . nc su . cs c . itrust . exception . DBException ; ▁import ▁edu . nc su . cs c . itrust . exception . iTrustException ; ▁/** ▁* ▁Used ▁for ▁ managing ▁hospitals ▁* ▁* ▁DAO ▁stand s ▁for ▁Database ▁Access ▁Object . ▁All ▁DAOs ▁are ▁intended ▁to ▁be ▁ref lections ▁of ▁the ▁database , ▁that ▁is , ▁* ▁one ▁DAO ▁per ▁table ▁in ▁the ▁database ▁( most ▁of ▁the ▁time ) . ▁For ▁more ▁comple x ▁sets ▁of ▁queries , ▁extra ▁DAOs ▁are ▁* ▁added . ▁DAOs ▁can ▁assume ▁that ▁all ▁data ▁has ▁been ▁validated ▁and ▁is ▁correct . ▁* ▁* ▁DAOs ▁should ▁n ever ▁have ▁setter s ▁or ▁any ▁other ▁parameter ▁to ▁the ▁constructor ▁than ▁a ▁factory . ▁All ▁DAOs ▁should ▁be ▁* ▁accessed ▁by ▁DAOFactory ▁( @ see ▁ {@ link ▁DAOFactory }) ▁and ▁every ▁DAO ▁should ▁have ▁a ▁factory ▁- ▁for ▁obtain ing ▁JDBC ▁* ▁connections ▁and / or ▁access ing ▁other ▁DAOs . ▁* ▁* ▁@ author ▁Andy ▁* ▁*/ ▁public ▁class ▁HospitalsDAO ▁{ ▁private ▁DAOFactory ▁factory ; ▁private ▁HospitalBean Loader ▁hospitalLoader ▁= ▁new ▁HospitalBean Loader (); ▁/** ▁* ▁The ▁typical ▁constructor . ▁* ▁@ param ▁factory ▁The ▁ {@ link ▁DAOFactory } ▁associate d ▁with ▁this ▁DAO , ▁which ▁is ▁used ▁for ▁obtain ing ▁SQL ▁connections , ▁etc . ▁*/ ▁public ▁HospitalsDAO ( DAOFactory ▁factory ) ▁{ ▁this . factory ▁= ▁factory ; ▁} ▁/** ▁* ▁Returns ▁a ▁list ▁of ▁all ▁hospitals ▁sort ed ▁alpha b e tical ly ▁* ▁* ▁@ return ▁A ▁java . util . List ▁of ▁HospitalBean s . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < HospitalBean > ▁getAll Hospitals () ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁Hospitals ▁OR DER ▁ BY ▁ HospitalName "); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁return ▁hospitalLoader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Returns ▁a ▁particular ▁hospital ▁given ▁its ▁ID ▁* ▁* ▁@ param ▁id ▁The ▁String ▁ID ▁of ▁the ▁hospital . ▁* ▁@ return ▁A ▁HospitalBean ▁representing ▁this ▁hospital . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁HospitalBean ▁get Hospital ( String ▁id ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁Hospitals ▁ WH ERE ▁ HospitalID ▁= ▁? "); ▁ps . set String ( 1, ▁id ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁if ▁( rs . next ()) ▁return ▁hospitalLoader . loadSingle ( rs ); ▁return ▁null ; ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Add s ▁a ▁hospital ▁* ▁* ▁@ param ▁hosp ▁The ▁HospitalBean ▁object ▁to ▁insert . ▁* ▁@ return ▁A ▁boolean ▁indicat ing ▁whether ▁the ▁insert ion ▁was ▁successful . ▁* ▁@ throw s ▁DBException ▁* ▁@ throw s ▁iTrustException ▁*/ ▁public ▁boolean ▁add Hospital ( HospitalBean ▁hosp ) ▁throw s ▁DBException , ▁iTrustException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" INSERT ▁INT O ▁Hospitals ▁( HospitalID , ▁ HospitalName ) ▁" ▁+ ▁" VALUES ▁(?,? )"); ▁ps . set String ( 1, ▁hosp . get HospitalID ()); ▁ps . set String (2, ▁hosp . get HospitalName ()); ▁return ▁(1 ▁== ▁ps . execute Update ()); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁if ▁(1 062 ▁== ▁e . get ErrorCode ()) ▁throw ▁new ▁iTrustException (" Error : ▁Hospital ▁already ▁exists . "); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Updates ▁a ▁particular ▁hospital ' s ▁description . ▁Returns ▁the ▁number ▁of ▁rows ▁ affected ▁( sh ould ▁be ▁1) ▁* ▁* ▁@ param ▁hosp ▁The ▁HospitalBean ▁to ▁update . ▁* ▁@ return ▁An ▁int ▁indicat ing ▁the ▁number ▁of ▁ affected ▁rows . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁int ▁update Hospital ( HospitalBean ▁hosp ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" UPDATE ▁Hospitals ▁SET ▁ HospitalName ▁= ▁? ▁" ▁+ ▁" WH ERE ▁ HospitalID ▁= ▁? "); ▁ps . set String ( 1, ▁hosp . get HospitalName ()); ▁ps . set String (2, ▁hosp . get HospitalID ()); ▁return ▁ps . execute Update (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Assign ▁an ▁HCP ▁to ▁a ▁hospital . ▁If ▁they ▁have ▁already ▁been ▁assigned ▁to ▁that ▁hospital , ▁then ▁an ▁* ▁iTrustException ▁is ▁thrown . ▁* ▁* ▁@ param ▁hcpID ▁The ▁HCP ' s ▁MID ▁to ▁assign ▁to ▁the ▁hospital . ▁* ▁@ param ▁hospitalID ▁The ▁ID ▁of ▁the ▁hospital ▁to ▁assign ▁them ▁to . ▁* ▁@ return ▁A ▁boolean ▁indicat ing ▁whether ▁the ▁assignment ▁was ▁a ▁success . ▁* ▁@ throw s ▁DBException ▁* ▁@ throw s ▁iTrustException ▁*/ ▁public ▁boolean ▁assign Hospital ( long ▁hcpID , ▁String ▁hospitalID ) ▁throw s ▁DBException , ▁iTrustException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" INSERT ▁INT O ▁HCP AssignedHos ▁( HCPID , ▁ HosID ) ▁VALUES ▁(?,? )"); ▁ps . s etLong ( 1, ▁hcpID ); ▁ps . set String (2, ▁hospitalID ); ▁return ▁(1 ▁== ▁ps . execute Update ()); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁if ▁(1 062 ▁== ▁e . get ErrorCode ()) ▁throw ▁new ▁iTrustException (" HCP ▁" ▁+ ▁hcpID ▁+ ▁" ▁already ▁assigned ▁to ▁hospital ▁" ▁+ ▁hospitalID ); ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Un assign s ▁an ▁HCP ▁to ▁a ▁hospital . ▁Returns ▁whether ▁or ▁not ▁any ▁changes ▁we re ▁made ▁* ▁* ▁@ param ▁hcpID ▁The ▁MID ▁of ▁the ▁HCP ▁to ▁remove . ▁* ▁@ param ▁hospitalID ▁The ▁ID ▁of ▁the ▁hospital ▁being ▁removed ▁from . ▁* ▁@ return ▁A ▁boolean ▁indicat ing ▁success . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁boolean ▁remove Hospital Assignment ( long ▁hcpID , ▁String ▁hospitalID ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" DE LETE ▁FROM ▁HCP AssignedHos ▁ WH ERE ▁HCPID ▁= ▁? ▁AND ▁ HosID ▁= ▁? "); ▁ps . s etLong ( 1, ▁hcpID ); ▁ps . set String (2, ▁hospitalID ); ▁return ▁(1 ▁== ▁ps . execute Update ()); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Remove s ▁all ▁hospital ▁assignment s ▁for ▁a ▁particular ▁HCP . ▁Returns ▁the ▁number ▁of ▁rows ▁ affected . ▁* ▁* ▁@ param ▁hcpID ▁The ▁MID ▁of ▁the ▁HCP . ▁* ▁@ return ▁An ▁int ▁representing ▁the ▁number ▁of ▁hospital ▁assignment s ▁removed . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁int ▁remove All Hospital AssignmentsFrom ( long ▁hcpID ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" DE LETE ▁FROM ▁HCP AssignedHos ▁ WH ERE ▁HCPID ▁= ▁? "); ▁ps . s etLong ( 1, ▁hcpID ); ▁return ▁ps . execute Update (); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁}