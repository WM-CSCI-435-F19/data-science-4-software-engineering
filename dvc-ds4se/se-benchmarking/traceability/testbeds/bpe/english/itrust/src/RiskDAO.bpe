▁p ackage ▁edu . nc su . cs c . itrust . dao . mysql ; ▁import ▁java . sql . Connection ; ▁import ▁java . sql . P reparedStatement ; ▁import ▁java . sql . SQLException ; ▁import ▁java . util . List ; ▁import ▁edu . nc su . cs c . itrust . DBUtil ; ▁import ▁edu . nc su . cs c . itrust . beans . FamilyMemberBean ; ▁import ▁edu . nc su . cs c . itrust . dao . DAOFactory ; ▁import ▁edu . nc su . cs c . itrust . exception . DBException ; ▁/** ▁* ▁Used ▁for ▁finding ▁risk ▁factors ▁for ▁a ▁given ▁patient . ▁* ▁* ▁DAO ▁stand s ▁for ▁Database ▁Access ▁Object . ▁All ▁DAOs ▁are ▁intended ▁to ▁be ▁ref lections ▁of ▁the ▁database , ▁that ▁is , ▁* ▁one ▁DAO ▁per ▁table ▁in ▁the ▁database ▁( most ▁of ▁the ▁time ) . ▁For ▁more ▁comple x ▁sets ▁of ▁queries , ▁extra ▁DAOs ▁are ▁* ▁added . ▁DAOs ▁can ▁assume ▁that ▁all ▁data ▁has ▁been ▁validated ▁and ▁is ▁correct . ▁* ▁* ▁DAOs ▁should ▁n ever ▁have ▁setter s ▁or ▁any ▁other ▁parameter ▁to ▁the ▁constructor ▁than ▁a ▁factory . ▁All ▁DAOs ▁should ▁be ▁* ▁accessed ▁by ▁DAOFactory ▁( @ see ▁ {@ link ▁DAOFactory }) ▁and ▁every ▁DAO ▁should ▁have ▁a ▁factory ▁- ▁for ▁obtain ing ▁JDBC ▁* ▁connections ▁and / or ▁access ing ▁other ▁DAOs . ▁* ▁* ▁@ author ▁Andy ▁* ▁*/ ▁public ▁class ▁ RiskDAO ▁{ ▁private ▁DAOFactory ▁factory ; ▁/** ▁* ▁The ▁typical ▁constructor . ▁* ▁@ param ▁factory ▁The ▁ {@ link ▁DAOFactory } ▁associate d ▁with ▁this ▁DAO , ▁which ▁is ▁used ▁for ▁obtain ing ▁SQL ▁connections , ▁etc . ▁*/ ▁public ▁ RiskDAO ( DAOFactory ▁factory ) ▁{ ▁this . factory ▁= ▁factory ; ▁} ▁/** ▁* ▁This ▁method ▁is ▁implemented ▁using ▁ {@ link ▁FamilyDAO } ▁for ▁2 ▁reasons : ▁( a ) ▁definition s ▁of ▁family ▁members ▁* ▁m ight ▁change , ▁so ▁it ' s ▁be tter ▁to ▁ c ent ral ize ▁that ▁code ▁and ▁(2) ▁to ▁make ▁this ▁code ▁a ▁l it tle ▁bit ▁" ni c er " ▁* ▁even ▁though ▁it ▁ execute s ▁one ▁query ▁per ▁family ▁member . ▁If ▁this ▁method ▁gets ▁ s low , ▁then ▁you ▁will ▁need ▁to ▁* ▁re factor . ▁Otherwise , ▁let ' s ▁just ▁keep ▁it ▁simple . . . ▁* ▁* ▁@ param ▁patientID ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ param ▁icdLower ▁A ▁double ▁of ▁the ▁lower ▁bound ▁for ▁the ▁codes . ▁* ▁@ param ▁icdUpper ▁A ▁double ▁of ▁the ▁upper ▁bound ▁for ▁the ▁codes . ▁* ▁@ return ▁A ▁boolean ▁indicat ing ▁whether ▁a ▁family ▁member ▁had ▁a ▁match ▁in ▁this ▁range . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁boolean ▁has FamilyHistory ( long ▁patientID , ▁double ▁icdLower , ▁double ▁icdUpper ) ▁throw s ▁DBException ▁{ ▁List < FamilyMemberBean > ▁familyMembers ▁= ▁getFamilyMember s ( patientID ); ▁for ▁( FamilyMemberBean ▁fam M em b er ▁: ▁familyMembers ) ▁{ ▁if ▁( h ad PriorDiagnos es ( f am M em b er . get Mid (), ▁icdLower , ▁icdUpper )) ▁return ▁true ; ▁} ▁return ▁false ; ▁} ▁private ▁List < FamilyMemberBean > ▁getFamilyMember s ( long ▁patientID ) ▁throw s ▁DBException ▁{ ▁FamilyDAO ▁fam DAO ▁= ▁factory . get FamilyDAO (); ▁List < FamilyMemberBean > ▁familyMembers ▁= ▁fam DAO . getParent s ( patientID ); ▁familyMembers . addAll ( f am DAO . get Siblings ( patientID )); ▁return ▁familyMembers ; ▁} ▁/** ▁* ▁Returns ▁whether ▁or ▁not ▁a ▁patient ▁had ▁a ▁childhood ▁in f ec tion ▁for ▁the ▁exact , ▁given ▁ICD ▁codes . ▁* ▁* ▁@ param ▁patientID ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ param ▁icdCodes ▁A ▁parameter ▁list ▁of ▁the ▁ICD ▁codes ▁to ▁match . ▁* ▁@ return ▁A ▁boolean ▁indicat ing ▁whether ▁this ▁patient ▁had ▁all ▁the ▁list ed ▁ICD ▁codes . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁boolean ▁had Child h o o d I nfe c tion ( long ▁patientID , ▁double . . . ▁icdCodes ) ▁throw s ▁DBException ▁{ ▁// ▁Note ▁the ▁date diff ▁call ▁- ▁this ▁is ▁a ▁My SQL ▁function ▁that ▁takes ▁the ▁differen ce ▁between ▁two ▁// ▁dates ▁and ▁return s ▁that ▁value ▁in ▁term s ▁of ▁days . ▁657 0 ▁days ▁is ▁ 18 ▁years ▁( not ▁count ing ▁leap ▁years ) ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁OVDiagnosis ▁ovd , ▁OfficeVisits ▁ov , ▁Patients ▁p ▁" ▁+ ▁" WH ERE ▁ovd . visitID = ov . id ▁AND ▁ov . patientid = p . mid ▁AND ▁p . mid =? ▁" ▁+ ▁" AND ▁date diff ( ov . visit date , p . dateofbirth ) ▁< ▁657 0 ▁AND ▁ovd . icdcode ▁IN ▁ (" ▁+ ▁create P rep ar ed ( icd Code s . length ) ▁+ ▁" )"); ▁ps . s etLong ( 1, ▁patientID ); ▁set ICD s (2, ▁ps , ▁icdCodes ); ▁return ▁ps . execute Query (). next (); ▁// ▁if ▁this ▁query ▁has ▁ ANY ▁rows , ▁then ▁ yes ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁private ▁String ▁create P rep ar ed ( int ▁length ) ▁{ ▁String ▁str ▁= ▁""; ▁for ▁( int ▁i ▁= ▁0; ▁i ▁< ▁length ; ▁i ++) ▁str ▁+= ▁" ? , "; ▁return ▁str . substring (0, ▁str . length () ▁- ▁1); ▁} ▁private ▁void ▁set ICD s ( int ▁start , ▁P reparedStatement ▁ps , ▁double [ ] ▁icdCodes ) ▁throw s ▁SQLException ▁{ ▁for ▁( double ▁icdCode ▁: ▁icdCodes ) ▁{ ▁ps . set Double ( start ++ , ▁icdCode ); ▁} ▁} ▁/** ▁* ▁Returns ▁if ▁the ▁patient ▁has ▁ ever ▁smoked ▁in ▁the ir ▁ life ▁* ▁* ▁@ param ▁patientID ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ return ▁A ▁boolean ▁indicat ing ▁whether ▁the ▁patient ▁smoked . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁boolean ▁has Smoke d ( long ▁patientID ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn ▁ . prepare Statement (" SEL ECT ▁* ▁FROM ▁Personal Health Information ▁ WH ERE ▁PatientID =? ▁AND ▁ Smoker =1 "); ▁ps . s etLong ( 1, ▁patientID ); ▁return ▁ps . execute Query (). next (); ▁// ▁if ▁this ▁query ▁has ▁ ANY ▁rows , ▁then ▁ yes ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Returns ▁if ▁a ▁patient ▁has ▁ ever ▁been ▁diagnosed ▁with ▁the ▁given ▁ICD ▁code , ▁in ▁the ▁range ▁[ lower , upper ) ▁* ▁* ▁@ param ▁patientID ▁The ▁MID ▁of ▁the ▁patient ▁in ▁question . ▁* ▁@ param ▁lowerICDCode ▁A ▁double ▁of ▁the ▁lower ▁ICD ▁code . ▁* ▁@ param ▁upperICDCode ▁A ▁double ▁of ▁the ▁upper ▁ICD ▁code . ▁* ▁@ return ▁A ▁boolean ▁indicat ing ▁whether ▁there ▁was ▁a ▁match ▁in ▁the ▁given ▁range . ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁boolean ▁had PriorDiagnos es ( long ▁patientID , ▁double ▁lowerICDCode , ▁double ▁upperICDCode ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁OVDiagnosis ▁ovd , ▁OfficeVisits ▁ov , ▁Patients ▁p ▁" ▁+ ▁" WH ERE ▁ovd . visitID = ov . id ▁AND ▁ov . patientid = p . mid ▁AND ▁p . mid =? ▁" ▁+ ▁" AND ▁ovd . icdcode > =? ▁AND ▁ovd . icdcode < ? "); ▁ps . s etLong ( 1, ▁patientID ); ▁ps . set Double (2, ▁lowerICDCode ); ▁ps . set Double ( 3, ▁upperICDCode ); ▁return ▁ps . execute Query (). next (); ▁// ▁if ▁this ▁query ▁has ▁ ANY ▁rows , ▁then ▁ yes ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁}