▁p ackage ▁edu . nc su . cs c . itrust . risk ; ▁import ▁java . util . ArrayList ; ▁import ▁java . util . List ; ▁import ▁edu . nc su . cs c . itrust . beans . HealthRecord ; ▁import ▁edu . nc su . cs c . itrust . beans . PatientBean ; ▁import ▁edu . nc su . cs c . itrust . dao . DAOFactory ; ▁import ▁edu . nc su . cs c . itrust . dao . mysql . HealthRecordsDAO ; ▁import ▁edu . nc su . cs c . itrust . exception . DBException ; ▁import ▁edu . nc su . cs c . itrust . exception . No HealthRecords Exception ; ▁import ▁edu . nc su . cs c . itrust . risk . factors . P atientRiskFactor ; ▁/** ▁* ▁An ▁abstract ▁class ▁which ▁has ▁a ▁number ▁of ▁ ut l ity ▁methods ▁for ▁checking ▁risk s . ▁* ▁* ▁When ▁extend ing ▁this ▁class , ▁use ▁the ▁methods ▁to ▁fill ▁in ▁all ▁of ▁the ▁necessary ▁information . ▁The n ▁use ▁isAtRisk ▁* ▁and ▁getPatient RiskFactors ▁to ▁get ▁the ▁actual ▁risk s . ▁Se e ▁the ▁known ▁subclass es ▁for ▁an ▁example ▁* ▁* ▁@ author ▁Andy ▁* ▁*/ ▁abstract ▁public ▁class ▁RiskChecker ▁{ ▁private ▁static ▁final ▁int ▁RI SK _ TH RE S HOL D ▁= ▁3 ; ▁ protected ▁PatientBean ▁patient ; ▁ protected ▁HealthRecord ▁current HealthRecord ; ▁ protected ▁DAOFactory ▁factory ; ▁public ▁RiskChecker ( DAOFactory ▁factory , ▁long ▁patientID ) ▁throw s ▁DBException , ▁No HealthRecords Exception ▁{ ▁this . factory ▁= ▁factory ; ▁ HealthRecordsDAO ▁hrDAO ▁= ▁factory . get HealthRecordsDAO (); ▁List < HealthRecord > ▁records ▁= ▁hrDAO . getAll HealthRecords ( patientID ); ▁if ▁( records . size () ▁> ▁0) ▁current HealthRecord ▁= ▁records . get (0); ▁else ▁throw ▁new ▁No HealthRecords Exception (); ▁patient ▁= ▁factory . get PatientDAO (). getPatient ( patientID ); ▁} ▁/** ▁* ▁@ return ▁The ▁name ▁of ▁the ▁disease ▁being ▁checked . ▁*/ ▁abstract ▁public ▁String ▁getName (); ▁/** ▁* ▁@ return ▁A ▁java . util . List ▁of ▁the ▁risk ▁factors ▁in c re a s ing ▁this ▁patients ▁disease ▁risk . ▁*/ ▁abstract ▁ protected ▁List < P atientRiskFactor > ▁getDisease RiskFactors (); ▁/** ▁* ▁@ return ▁A ▁boolean ▁indicat ing ▁whether ▁the ▁patient ▁is ▁at ▁increase d ▁risk . ▁*/ ▁abstract ▁public ▁boolean ▁qualifies For Disease (); ▁/** ▁* ▁This ▁method ▁exists ▁pure ly ▁for ▁performance ▁- ▁just ▁stop ▁once ▁you ▁hi t ▁the ▁threshold . ▁< br ▁/> ▁* ▁< br ▁/> ▁* ▁Also , ▁the ▁risk ▁factors ▁should ▁be ▁cached ▁in ▁the ▁Risk Factor ▁implement or s ▁- ▁in ▁getPatient RiskFactors ▁there ▁* ▁should ▁be ▁no ▁double - query ing ▁* ▁* ▁@ return ▁isAtRisk ▁*/ ▁public ▁boolean ▁isAtRisk () ▁{ ▁if ▁( q ual if ies For Disease ()) ▁{ ▁int ▁num Risk s ▁= ▁0; ▁List < P atientRiskFactor > ▁disease RiskFactors ▁= ▁getDisease RiskFactors (); ▁for ▁( P atientRiskFactor ▁factor ▁: ▁disease RiskFactors ) ▁{ ▁if ▁( factor . hasRiskFactor ()) ▁num Risk s ++; ▁if ▁( num Risk s ▁>= ▁RI SK _ TH RE S HOL D ) ▁return ▁true ; ▁} ▁} ▁return ▁false ; ▁// ▁both ▁an ▁else ▁from ▁qualifies ▁or ▁NOT ▁over ▁the ▁threshold ▁} ▁/** ▁* ▁@ return ▁A ▁java . util . List ▁of ▁patient ▁risk ▁factors ▁associate d ▁with ▁this ▁disease . ▁*/ ▁public ▁List < P atientRiskFactor > ▁getPatient RiskFactors () ▁{ ▁List < P atientRiskFactor > ▁patient RiskFactors ▁= ▁new ▁ArrayList < P atientRiskFactor > (); ▁List < P atientRiskFactor > ▁disease RiskFactors ▁= ▁getDisease RiskFactors (); ▁for ▁( P atientRiskFactor ▁factor ▁: ▁disease RiskFactors ) ▁{ ▁if ▁( factor . hasRiskFactor ()) ▁{ ▁patient RiskFactors . add ( factor ); ▁} ▁} ▁return ▁patient RiskFactors ; ▁} ▁}