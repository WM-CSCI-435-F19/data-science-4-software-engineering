▁p ackage ▁edu . nc su . cs c . itrust . dao . mysql ; ▁import ▁java . sql . Connection ; ▁import ▁java . sql . P reparedStatement ; ▁import ▁java . sql . ResultSet ; ▁import ▁java . sql . SQLException ; ▁import ▁java . text . ParseException ; ▁import ▁java . text . SimpleDateFormat ; ▁import ▁java . util . Date ; ▁import ▁java . util . List ; ▁import ▁edu . nc su . cs c . itrust . DBUtil ; ▁import ▁edu . nc su . cs c . itrust . beans . AdverseEventBean ; ▁import ▁edu . nc su . cs c . itrust . beans . loaders . AdverseEventBean Loader ; ▁import ▁edu . nc su . cs c . itrust . dao . DAOFactory ; ▁import ▁edu . nc su . cs c . itrust . exception . DBException ; ▁import ▁java . sql . Timestamp ; ▁/** ▁* ▁Used ▁for ▁the ▁logging ▁mechanism . ▁* ▁* ▁DAO ▁stand s ▁for ▁Database ▁Access ▁Object . ▁All ▁DAOs ▁are ▁intended ▁to ▁be ▁ref lections ▁of ▁the ▁database , ▁that ▁is , ▁* ▁one ▁DAO ▁per ▁table ▁in ▁the ▁database ▁( most ▁of ▁the ▁time ) . ▁For ▁more ▁comple x ▁sets ▁of ▁queries , ▁extra ▁DAOs ▁are ▁* ▁added . ▁DAOs ▁can ▁assume ▁that ▁all ▁data ▁has ▁been ▁validated ▁and ▁is ▁correct . ▁* ▁* ▁DAOs ▁should ▁n ever ▁have ▁setter s ▁or ▁any ▁other ▁parameter ▁to ▁the ▁constructor ▁than ▁a ▁factory . ▁All ▁DAOs ▁should ▁be ▁* ▁accessed ▁by ▁DAOFactory ▁( @ see ▁ {@ link ▁DAOFactory }) ▁and ▁every ▁DAO ▁should ▁have ▁a ▁factory ▁- ▁for ▁obtain ing ▁JDBC ▁* ▁connections ▁and / or ▁access ing ▁other ▁DAOs . ▁* ▁* ▁@ author ▁Andy ▁* ▁*/ ▁public ▁class ▁AdverseEventDAO ▁{ ▁private ▁DAOFactory ▁factory ; ▁private ▁AdverseEvent BeanLoader ▁aeLoader ; ▁/** ▁* ▁The ▁typical ▁constructor . ▁* ▁@ param ▁factory ▁The ▁ {@ link ▁DAOFactory } ▁associate d ▁with ▁this ▁DAO , ▁which ▁is ▁used ▁for ▁obtain ing ▁SQL ▁connections , ▁etc . ▁*/ ▁public ▁AdverseEventDAO ( DAOFactory ▁factory ) ▁{ ▁this . factory ▁= ▁factory ; ▁this . a e Loader ▁= ▁new ▁AdverseEvent BeanLoader (); ▁} ▁/** ▁* ▁Get s ▁all ▁the ▁adverse ▁event ▁reports ▁for ▁a ▁certain ▁user ▁MID . ▁* ▁@ param ▁mid ▁The ▁MID ▁of ▁the ▁user ▁to ▁be ▁look ed ▁up . ▁* ▁@ return ▁A ▁java . util . List ▁of ▁ AdverseEventBean s . ▁* ▁@ throw s ▁SQLException ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁List < AdverseEventBean > ▁get Report s For ( long ▁mid ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁AdverseEvents ▁ WH ERE ▁PatientMID ▁= ▁? "); ▁ps . s etLong ( 1, ▁mid ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁List < AdverseEventBean > ▁aeList ▁= ▁this . a e Loader . load List ( rs ); ▁return ▁aeList ; ▁} ▁catch ( SQLException ▁e ){ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally { ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁/** ▁* ▁Add s ▁a ▁message ▁to ▁the ▁database . ▁* ▁@ param ▁mBean ▁A ▁bean ▁representing ▁the ▁message ▁to ▁be ▁added . ▁* ▁@ throw s ▁SQLException ▁* ▁@ throw s ▁DBException ▁*/ ▁public ▁void ▁ addReport ( AdverseEventBean ▁aeBean , ▁long ▁hcp mid ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try { ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement ( ▁" INSERT ▁INT O ▁AdverseEvents ▁( PatientMID , ▁ PresImmu , ▁Code , ▁Comment , ▁Prescriber , ▁Status ) ▁" ▁+ ▁" VALUES ▁(?, ▁? , ▁? , ▁? , ▁? , ▁? )"); ▁ps . set String ( 1, ▁aeBean . get MID ()); ▁ps . set String (2, ▁aeBean . getDrug ()); ▁ps . set String ( 3, ▁aeBean . get Code ()); ▁ps . set String ( 4, ▁aeBean . get Description ()); ▁ps . s etLong (5, ▁hcp mid ); ▁ps . set String (6, " A ct ive "); ▁ps . execute Update (); ▁} ▁catch ( SQLException ▁e ){ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁public ▁long ▁get HCPMID ( int ▁id ) ▁throw s ▁DBException { ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁AdverseEvents ▁ WH ERE ▁id =?" ); ▁ps . set Int ( 1, ▁id ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁long ▁hcpMID ▁= ▁0; ▁if ( rs . next ()) ▁{ ▁hcpMID ▁= ▁rs . getLong (" Presc ri b er "); ▁} ▁return ▁hcpMID ; ▁} ▁catch ( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁public ▁ AdverseEventBean ▁get Report ( int ▁id ) ▁throw s ▁DBException { ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁AdverseEvents ▁ WH ERE ▁id =?" ); ▁ps . set Int ( 1, ▁id ); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁List < AdverseEventBean > ▁aeList ▁= ▁aeLoader . load List ( rs ); ▁return ▁aeList . get (0); ▁} ▁catch ( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁public ▁long ▁remove Report ( int ▁id ) ▁throw s ▁DBException { ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" UPDATE ▁AdverseEvents ▁SET ▁Status ▁= ▁? ▁ WH ERE ▁id ▁= ▁? "); ▁String ▁removed ▁= ▁" removed "; ▁ps . set String ( 1, ▁removed ); ▁ps . set Int (2, id ); ▁ps . execute Update (); ▁long ▁a ▁= ▁DBUtil . getLast Insert ( conn ); ▁return ▁a ; ▁} ▁catch ( SQLException ▁e ){ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁public ▁List < AdverseEventBean > ▁get Un removed AdverseEvent sBy Code ( String ▁code ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁adverse events ▁ WH ERE ▁code =? ▁AND ▁status =?" ); ▁ps . set String ( 1, ▁code ); ▁ps . set String (2, ▁" A ct ive "); ▁ResultSet ▁rs ; ▁rs ▁= ▁ps . execute Query (); ▁return ▁aeLoader . load List ( rs ); ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁public ▁String ▁getName For Code ( String ▁code ) ▁throw s ▁DBException ▁{ ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁conn ▁= ▁factory . get Connection (); ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁ PresImmu ▁FROM ▁adverse events ▁ WH ERE ▁code =?" ); ▁ps . set String ( 1, ▁code ); ▁ResultSet ▁rs ; ▁rs ▁= ▁ps . execute Query (); ▁if ( rs . next ()) ▁{ ▁return ▁rs . get String (" PresImmu "); ▁} ▁return ▁" Name ▁not ▁Found "; ▁} ▁catch ▁( SQLException ▁e ) ▁{ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁public ▁List < AdverseEventBean > ▁get P er script ion s ( String ▁start , ▁String ▁end ) ▁throw s ▁ParseException , ▁DBException { ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try { ▁ SimpleDateFormat ▁fmt ▁= ▁new ▁ SimpleDateFormat (" MM / dd / y y y "); ▁Date ▁ beginning ▁= ▁fmt . parse ( start ); ▁Date ▁ ending ▁= ▁fmt . parse ( end ); ▁conn ▁= ▁factory . get Connection (); ▁// AND ▁NDCodes . Code = AdverseEvents . Code ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁AdverseEvents , NDCodes ▁ WH ERE ▁AdverseEvents . TimeLogged ▁>= ▁? ▁AND ▁AdverseEvents . TimeLogged ▁< = ▁? ▁AND ▁NDCodes . Code = AdverseEvents . Code ▁OR DER ▁ BY ▁AdverseEvents . Code , ▁AdverseEvents . TimeLogged ▁DESC "); ▁ps . set Timestamp ( 1, ▁new ▁Timestamp ( beginning . getTime ()) ); ▁ps . set Timestamp (2, ▁new ▁Timestamp ( ending . getTime () ▁+ ▁1000 L ▁* ▁60 L ▁* ▁60 ▁* ▁24 L )); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁List < AdverseEventBean > ▁aeList ▁= ▁aeLoader . load List ( rs ); ▁return ▁aeList ; ▁} ▁catch ( SQLException ▁e ){ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁public ▁List < AdverseEventBean > ▁getImmunization s ( String ▁start , ▁String ▁end ) ▁throw s ▁ParseException , ▁DBException { ▁ Connection ▁conn ▁= ▁null ; ▁P reparedStatement ▁ps ▁= ▁null ; ▁try ▁{ ▁ SimpleDateFormat ▁fmt ▁= ▁new ▁ SimpleDateFormat (" MM / dd / y y y "); ▁Date ▁ beginning ▁= ▁fmt . parse ( start ); ▁Date ▁ ending ▁= ▁fmt . parse ( end ); ▁conn ▁= ▁factory . get Connection (); ▁// AND ▁NDCodes . Code = AdverseEvents . Code ▁ps ▁= ▁conn . prepare Statement (" SEL ECT ▁* ▁FROM ▁AdverseEvents , CPTCodes ▁ WH ERE ▁AdverseEvents . TimeLogged ▁>= ▁? ▁AND ▁AdverseEvents . TimeLogged ▁< = ▁? ▁AND ▁CPTCodes . Code = AdverseEvents . Code ▁OR DER ▁ BY ▁AdverseEvents . Code , ▁AdverseEvents . TimeLogged ▁DESC "); ▁ps . set Timestamp ( 1, ▁new ▁Timestamp ( beginning . getTime ()) ); ▁ps . set Timestamp (2, ▁new ▁Timestamp ( ending . getTime () ▁+ ▁1000 L ▁* ▁60 L ▁* ▁60 ▁* ▁24 L )); ▁ResultSet ▁rs ▁= ▁ps . execute Query (); ▁List < AdverseEventBean > ▁aeList ▁= ▁aeLoader . load List ( rs ); ▁return ▁aeList ; ▁} ▁catch ( SQLException ▁e ){ ▁e . print Stack T race (); ▁throw ▁new ▁DBException ( e ); ▁} ▁finally ▁{ ▁DBUtil . close Connection ( conn , ▁ps ); ▁} ▁} ▁}