▁/* -- ---------------- ---------------- ---------------- ---------------- ▁* ▁us 899. c ▁- ▁ Unit ▁Test s ▁for ▁User ▁Stor y ▁ 899 ▁- ▁Client ▁simple ▁enroll ▁* ▁* ▁September , ▁2013 ▁* ▁* ▁Copy right ▁( c ) ▁2013 , ▁2016 ▁by ▁ cisco ▁S ystems , ▁Inc . ▁* ▁All ▁ right s ▁ reserved . ▁* -- ---------------- ---------------- ---------------- ---------------- ▁*/ ▁# include ▁ < std io . h > ▁# if n def ▁W IN 32 ▁# include ▁ < uni std . h > ▁# endif ▁# include ▁ < est . h > ▁# include ▁" test _ util s . h " ▁# include ▁" st _ server . h " ▁# include ▁ < openssl / ssl . h > ▁# include ▁ < openssl / x 509 v 3 . h > ▁# if def ▁HA VE _ C UNIT ▁# include ▁" CUnit / Basic . h " ▁# include ▁" CUnit / A utomat ed . h " ▁# endif ▁static ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁static ▁int ▁cacerts _ len ▁= ▁0; ▁# define ▁US 899_ SERVER _ PORT ▁2989 9 ▁# define ▁US 899_ SERVER _ IP ▁"127.0.0.1" ▁# define ▁US 899_ UID ▁" estuser " ▁# define ▁US 899_ PWD ▁" estpwd " ▁/* ▁* ▁The ▁following ▁certs ▁are ▁used ▁for ▁ FQDN ▁testing ▁*/ ▁# if n def ▁W IN 32 ▁# define ▁US 899_ CACERTS ▁" CA / estCA / cacert . crt " ▁# define ▁US 899_ TRUST _ CERTS ▁" CA / trustedcerts . crt " ▁# define ▁US 899_ SERVER _ CERTKEY ▁" CA / estCA / private / estserver cert and key . pem " ▁# define ▁US 899_ SERVER _ CERT _ CN _ MISMATCH ▁" US 899/ cert _ cn _ mismatch . pem " ▁# define ▁US 899_ SERVER _ KEY _ CN _ MISMATCH ▁" US 899/ key _ cn _ mismatch . pem " ▁# define ▁US 899_ SERVER _ CERT _ CN _ MISMATCH _ IP ▁" US 899/ cert _ cn _ mismatch _ ip . pem " ▁# define ▁US 899_ SERVER _ KEY _ CN _ MISMATCH _ IP ▁" US 899/ key _ cn _ mismatch _ ip . pem " ▁# define ▁US 899_ SERVER _ CERT _ CN _ MATCH _ WC ▁" US 899/ cert _ cn _ match _ wc . pem " ▁# define ▁US 899_ SERVER _ KEY _ CN _ MATCH _ WC ▁" US 899/ key _ cn _ match _ wc . pem " ▁# define ▁US 899_ SERVER _ CERT _ CN _ MISMATCH _ WC ▁" US 899/ cert _ cn _ mismatch _ wc . pem " ▁# define ▁US 899_ SERVER _ KEY _ CN _ MISMATCH _ WC ▁" US 899/ key _ cn _ mismatch _ wc . pem " ▁# define ▁US 899_ SERVER _ CERT _ SAN _ MATCH ▁" US 899/ cert _ san _ match . pem " ▁# define ▁US 899_ SERVER _ KEY _ SAN _ MATCH ▁" US 899/ key _ san _ match . pem " ▁# define ▁US 899_ SERVER _ CERT _ SAN _ MISMATCH ▁" US 899/ cert _ san _ mismatch . pem " ▁# define ▁US 899_ SERVER _ KEY _ SAN _ MISMATCH ▁" US 899/ key _ san _ mismatch . pem " ▁# define ▁US 899_ SERVER _ CERT _ SAN _ MISMATCH _ IP ▁" US 899/ cert _ san _ mismatch _ ip . pem " ▁# define ▁US 899_ SERVER _ KEY _ SAN _ MISMATCH _ IP ▁" US 899/ key _ san _ mismatch _ ip . pem " ▁# define ▁US 899_ SERVER _ CERT _ SAN _ MATCH _ IP ▁" US 899/ cert _ san _ match _ ip . pem " ▁# define ▁US 899_ SERVER _ KEY _ SAN _ MATCH _ IP ▁" US 899/ key _ san _ match _ ip . pem " ▁# define ▁US 899_ SERVER _ CERT _ SAN _ MATCH _ WC ▁" US 899/ cert _ san _ match _ wc . pem " ▁# define ▁US 899_ SERVER _ KEY _ SAN _ MATCH _ WC ▁" US 899/ key _ san _ match _ wc . pem " ▁# define ▁US 899_ SERVER _ CERT _ SAN _ MISMATCH _ WC ▁" US 899/ cert _ san _ mismatch _ wc . pem " ▁# define ▁US 899_ SERVER _ KEY _ SAN _ MISMATCH _ WC ▁" US 899/ key _ san _ mismatch _ wc . pem " ▁# else ▁# define ▁US 899_ CACERTS ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 899_ TRUST _ CERTS ▁" CA \\ trustedcerts . crt " ▁# define ▁US 899_ SERVER _ CERTKEY ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# define ▁US 899_ SERVER _ CERT _ CN _ MISMATCH ▁" US 899\\ cert _ cn _ mismatch . pem " ▁# define ▁US 899_ SERVER _ KEY _ CN _ MISMATCH ▁" US 899\\ key _ cn _ mismatch . pem " ▁# define ▁US 899_ SERVER _ CERT _ CN _ MISMATCH _ IP ▁" US 899\\ cert _ cn _ mismatch _ ip . pem " ▁# define ▁US 899_ SERVER _ KEY _ CN _ MISMATCH _ IP ▁" US 899\\ key _ cn _ mismatch _ ip . pem " ▁# define ▁US 899_ SERVER _ CERT _ CN _ MATCH _ WC ▁" US 899\\ cert _ cn _ match _ wc . pem " ▁# define ▁US 899_ SERVER _ KEY _ CN _ MATCH _ WC ▁" US 899\\ key _ cn _ match _ wc . pem " ▁# define ▁US 899_ SERVER _ CERT _ CN _ MISMATCH _ WC ▁" US 899\\ cert _ cn _ mismatch _ wc . pem " ▁# define ▁US 899_ SERVER _ KEY _ CN _ MISMATCH _ WC ▁" US 899\\ key _ cn _ mismatch _ wc . pem " ▁# define ▁US 899_ SERVER _ CERT _ SAN _ MATCH ▁" US 899\\ cert _ san _ match . pem " ▁# define ▁US 899_ SERVER _ KEY _ SAN _ MATCH ▁" US 899\\ key _ san _ match . pem " ▁# define ▁US 899_ SERVER _ CERT _ SAN _ MISMATCH ▁" US 899\\ cert _ san _ mismatch . pem " ▁# define ▁US 899_ SERVER _ KEY _ SAN _ MISMATCH ▁" US 899\\ key _ san _ mismatch . pem " ▁# define ▁US 899_ SERVER _ CERT _ SAN _ MISMATCH _ IP ▁" US 899\\ cert _ san _ mismatch _ ip . pem " ▁# define ▁US 899_ SERVER _ KEY _ SAN _ MISMATCH _ IP ▁" US 899\\ key _ san _ mismatch _ ip . pem " ▁# define ▁US 899_ SERVER _ CERT _ SAN _ MATCH _ IP ▁" US 899\\ cert _ san _ match _ ip . pem " ▁# define ▁US 899_ SERVER _ KEY _ SAN _ MATCH _ IP ▁" US 899\\ key _ san _ match _ ip . pem " ▁# define ▁US 899_ SERVER _ CERT _ SAN _ MATCH _ WC ▁" US 899\\ cert _ san _ match _ wc . pem " ▁# define ▁US 899_ SERVER _ KEY _ SAN _ MATCH _ WC ▁" US 899\\ key _ san _ match _ wc . pem " ▁# define ▁US 899_ SERVER _ CERT _ SAN _ MISMATCH _ WC ▁" US 899\\ cert _ san _ mismatch _ wc . pem " ▁# define ▁US 899_ SERVER _ KEY _ SAN _ MISMATCH _ WC ▁" US 899\\ key _ san _ mismatch _ wc . pem " ▁static ▁CR ITI CAL _ SE CTION ▁logger _ critical _ section ; ▁static ▁void ▁us 899_ logger _ stderr ▁( char ▁* format , ▁va _ list ▁l ) ▁{ ▁E nter CriticalSection (& logger _ critical _ section ); ▁ vf printf ( stderr , ▁format , ▁l ); ▁f flu sh ( stderr ); ▁ Leav eCriticalSection (& logger _ critical _ section ); ▁} ▁# endif ▁# define ▁US 899_ VALID _ CSR _ PEM ▁" ----- BEG IN ▁CERTIFICATE ▁REQUEST ----- \ n MIIB h DCB 7 gIBADB F MQswCQYDVQQGEwJ BV TET MB EGA 1 UECAw KU 29 tZS 1 T dGF 0 ZTE h \ n MB 8 GA 1 UECgw Y SW 50 ZXJ u ZXQg V 2 lkZ 2 l 0 cyB Q dH kg TH Rk MIG f MA 0 GCS qGS Ib 3 DQEB \ nAQ U AA 4 GNA DCB i QKBg QC 13 w EG 36 vB Y 8 Mq + u u 80 S Kv kx 0 ZC t 0 lc 18 ka MS DL wML 2 IRS \ n + Sa C LE Zbj JY eS x wZ 9 qX y 4 R t 1 vF DR RT L 57/ l QT g T 5 kz KI 2 D 2 Y UZ + Dg 6 wQ qx / 4 t 99 S \ na Cv / l xc UT f IP ia qAT U Q xe ZA + h 7 Fo 0 ti 9 wL Sw 6 AQ ft 9 hib YP RJ Z 6 z Ha 24 l Xw d 7 wID \ nAQ AB oAAw DQYJKoZIhvcNAQEF BQADgYEA jw Sj Lq FA z oP Ga 4 GK n 7 AE ite p VA +3 Qj X L \ n 45 LS z r VJ MW 4 Jl 8 O vm / a Pat nF RQY m 82 r VK b 7 Sq 4 Dd o 9 n DJ 9 t gZ 45 0 oq IW b ujU m GE U \ n s UU xJ S J 3 vG X y Qy +8 Ne Ty 4 Gm ms N WIw h SK M kqh 7 Y Vl Bv gkw Go NF uQ 8 mD 90 pr Fm ld + J \ nh HB ZX Ca ekr E =\ n ----- END ▁CERTIFICATE ▁REQUEST ----- " ▁/* ▁* ▁Note : ▁this ▁array ▁was ▁ generated ▁using : ▁ xdd ▁- i ▁req . der ▁req . c ▁*/ ▁static ▁un signed ▁char ▁US 899_ VALID _ CSR _ DER [] ▁= ▁{ ▁0 x 30, ▁0 x 82 , ▁0 x 01, ▁0 xa 8 , ▁0 x 30, ▁0 x 82 , ▁0 x 01, ▁0 x 11, ▁0 x 02, ▁0 x 01, ▁0 x 00, ▁0 x 30, ▁0 x 68 , ▁0 x 31 , ▁0 x 0 b , ▁0 x 30, ▁0 x 09 , ▁0 x 06, ▁0 x 03, ▁0 x 55, ▁0 x 04, ▁0 x 06, ▁0 x 13 , ▁0 x 02, ▁0 x 55, ▁0 x 53 , ▁0 x 31 , ▁0 x 0 b , ▁0 x 30, ▁0 x 09 , ▁0 x 06, ▁0 x 03, ▁0 x 55, ▁0 x 04, ▁0 x 08, ▁0 x 0 c , ▁0 x 02, ▁0 x 6 e , ▁0 x 63 , ▁0 x 31 , ▁0 x 0 c , ▁0 x 30, ▁0 x 0 a , ▁0 x 06, ▁0 x 03, ▁0 x 55, ▁0 x 04, ▁0 x 07, ▁0 x 0 c , ▁0 x 03, ▁0 x 73 , ▁0 x 73 , ▁0 x 73 , ▁0 x 31 , ▁0 x 0 c , ▁0 x 30, ▁0 x 0 a , ▁0 x 06, ▁0 x 03, ▁0 x 55, ▁0 x 04, ▁0 x 0 a , ▁0 x 0 c , ▁0 x 03, ▁0 x 64, ▁0 x 64, ▁0 x 64, ▁0 x 31 , ▁0 x 0 d , ▁0 x 30, ▁0 x 0 b , ▁0 x 06, ▁0 x 03, ▁0 x 55, ▁0 x 04, ▁0 x 0 b , ▁0 x 0 c , ▁0 x 04, ▁0 x 66 , ▁0 x 6 a , ▁0 x 6 a , ▁0 x 64, ▁0 x 31 , ▁0 x 0 c , ▁0 x 30, ▁0 x 0 a , ▁0 x 06, ▁0 x 03, ▁0 x 55, ▁0 x 04, ▁0 x 03, ▁0 x 0 c , ▁0 x 03, ▁0 x 31 , ▁0 x 32 , ▁0 x 3 7, ▁0 x 31 , ▁0 x 13 , ▁0 x 30, ▁0 x 11, ▁0 x 06, ▁0 x 09 , ▁0 x 2 a , ▁0 x 86, ▁0 x 48, ▁0 x 86, ▁0 xf 7, ▁0 x 0 d , ▁0 x 01, ▁0 x 09 , ▁0 x 01, ▁0 x 16 , ▁0 x 04, ▁0 x 6 e , ▁0 x 6 f , ▁0 x 6 e , ▁0 x 65 , ▁0 x 30, ▁0 x 81, ▁0 x 9 f , ▁0 x 30, ▁0 x 0 d , ▁0 x 06, ▁0 x 09 , ▁0 x 2 a , ▁0 x 86, ▁0 x 48, ▁0 x 86, ▁0 xf 7, ▁0 x 0 d , ▁0 x 01, ▁0 x 01, ▁0 x 01, ▁0 x 05, ▁0 x 00, ▁0 x 03, ▁0 x 81, ▁0 x 8 d , ▁0 x 00, ▁0 x 30, ▁0 x 81, ▁0 x 89 , ▁0 x 02, ▁0 x 81, ▁0 x 81, ▁0 x 00, ▁0 xb 9 , ▁0 x 9 f , ▁0 xdd , ▁0 xd 0 , ▁0 xa 4 , ▁0 xd f , ▁0 x 06, ▁0 x 50, ▁0 xf 5 , ▁0 x 4 e , ▁0 x 85, ▁0 x 80 , ▁0 xe b , ▁0 x 2 a , ▁0 x 1 e , ▁0 xff , ▁0 x 3 c , ▁0 x 0 f , ▁0 x 0 d , ▁0 x 98 , ▁0 x 6 e , ▁0 xf e , ▁0 x 08, ▁0 x 74 , ▁0 xf 4 , ▁0 xce , ▁0 xf 5 , ▁0 x fd , ▁0 xf 9 , ▁0 x 2 f , ▁0 x 86, ▁0 x 20 , ▁0 xf 7, ▁0 xc c , ▁0 x 08, ▁0 x 05, ▁0 xce , ▁0 x 98 , ▁0 x 69 , ▁0 x 5 c , ▁0 x 8 c , ▁0 xb d , ▁0 x 20 , ▁0 xa 7, ▁0 x 28, ▁0 xf 7, ▁0 xe 4 , ▁0 x 2 2 , ▁0 xf a , ▁0 xa f , ▁0 xe 4 , ▁0 x 15 , ▁0 xc 4 , ▁0 xb 9 , ▁0 x 85, ▁0 x cb , ▁0 x 0 f , ▁0 x 11, ▁0 xc 6 , ▁0 x 55, ▁0 x 0 d , ▁0 x 31 , ▁0 x 5 c , ▁0 xf b , ▁0 x 5 e , ▁0 xc f , ▁0 x 8 e , ▁0 xd 1, ▁0 x de , ▁0 x 77, ▁0 x 15 , ▁0 x 2 c , ▁0 x 8 c , ▁0 x 4 e , ▁0 x 8 8 , ▁0 x 4 e , ▁0 x 21 , ▁0 xb 6 , ▁0 x 69 , ▁0 x 9 c , ▁0 xa 7, ▁0 x 7 d , ▁0 x 06, ▁0 xc 5 , ▁0 x 7 5 , ▁0 x 3 f , ▁0 xd c , ▁0 x 18 , ▁0 xf 6 , ▁0 x 00, ▁0 x 51 , ▁0 xd 5 , ▁0 x 00, ▁0 x 47, ▁0 x 62 , ▁0 xf c , ▁0 x 95 , ▁0 xc 8 , ▁0 xd 4 , ▁0 x ef , ▁0 x 31 , ▁0 x 4 a , ▁0 xb 0 , ▁0 x 15 , ▁0 xa 9 , ▁0 x 50, ▁0 x 04, ▁0 x 6 e , ▁0 x 13 , ▁0 x 14, ▁0 xd 4 , ▁0 xb b , ▁0 x 56, ▁0 x 2 2 , ▁0 x 6 f , ▁0 x 3 b , ▁0 x 91 , ▁0 xb 6 , ▁0 xe b , ▁0 x ba , ▁0 x 25, ▁0 x 8 f , ▁0 x 12, ▁0 xe a , ▁0 x fd , ▁0 xd 4 , ▁0 xd 0 , ▁0 x 6 d , ▁0 x 02, ▁0 x 03, ▁0 x 01, ▁0 x 00, ▁0 x 01, ▁0 xa 0 , ▁0 x 00, ▁0 x 30, ▁0 x 0 d , ▁0 x 06, ▁0 x 09 , ▁0 x 2 a , ▁0 x 86, ▁0 x 48, ▁0 x 86, ▁0 xf 7, ▁0 x 0 d , ▁0 x 01, ▁0 x 01, ▁0 x 05, ▁0 x 05, ▁0 x 00, ▁0 x 03, ▁0 x 81, ▁0 x 81, ▁0 x 00, ▁0 x 3 b , ▁0 xa 5 , ▁0 xb 4 , ▁0 x 9 7, ▁0 x 6 c , ▁0 xe a , ▁0 xe 4 , ▁0 x 9 f , ▁0 xe b , ▁0 x 56, ▁0 x ca , ▁0 x 7 a , ▁0 x 7 f , ▁0 xf a , ▁0 x 53 , ▁0 x 8 d , ▁0 xe e , ▁0 x 6 f , ▁0 x 7 e , ▁0 xa 1, ▁0 x 08, ▁0 x 65 , ▁0 xe 0 , ▁0 x 05, ▁0 x 5 b , ▁0 x 0 e , ▁0 x 5 a , ▁0 x 92 , ▁0 xd b , ▁0 x 3 c , ▁0 xc 5 , ▁0 x 6 d , ▁0 x 0 d , ▁0 xc d , ▁0 x 2 c , ▁0 xc d , ▁0 x 4 d , ▁0 x 10 , ▁0 x 2 a , ▁0 x 92 , ▁0 x 78 , ▁0 x 1 d , ▁0 xf b , ▁0 x 92 , ▁0 x 66 , ▁0 x 3 3 , ▁0 x 18 , ▁0 xdd , ▁0 xf 8 , ▁0 x 78 , ▁0 xc 5 , ▁0 x 1 a , ▁0 x 03, ▁0 xf 9 , ▁0 x 58 , ▁0 x 9 f , ▁0 x 32 , ▁0 x 49 , ▁0 x de , ▁0 xd 2 , ▁0 x 26 , ▁0 x 78 , ▁0 x 80 , ▁0 x 87 , ▁0 x 18 , ▁0 xf 3 , ▁0 x 6 d , ▁0 xc 3 , ▁0 x 3 5 , ▁0 x 5 d , ▁0 x 21 , ▁0 x 8 b , ▁0 x 4 c , ▁0 x 8 c , ▁0 x 87 , ▁0 x ef , ▁0 xb 1, ▁0 xf c , ▁0 x 2 c , ▁0 xe c , ▁0 xd b , ▁0 xd 6 , ▁0 x 00, ▁0 xe 5 , ▁0 x 21 , ▁0 xf a , ▁0 x 34 , ▁0 x 5 a , ▁0 x 3 c , ▁0 xc 3 , ▁0 x 82 , ▁0 x 5 2 , ▁0 x 6 f , ▁0 x 81, ▁0 x 2 a , ▁0 x 05, ▁0 xc c , ▁0 xd c , ▁0 x 8 a , ▁0 x 51 , ▁0 xf 6 , ▁0 x 65 , ▁0 x 1 d , ▁0 xc 5 , ▁0 x 64, ▁0 x 86, ▁0 xc 1, ▁0 x 28, ▁0 xf 5 , ▁0 x 0 c , ▁0 x 8 f , ▁0 x 09 , ▁0 xd 4 , ▁0 x 84 , ▁0 x 8 f , ▁0 x 69 , ▁0 x 04, ▁0 x 24, ▁0 x 65 , ▁0 xf 4 , ▁0 x 47, ▁0 x 6 c , ▁0 x 90 , ▁0 x 5 7, ▁0 x 3 c , ▁0 x 04, ▁0 x 4 d , ▁0 x 5 2 ▁} ; ▁static ▁un signed ▁int ▁US 899_ VALID _ CSR _ DER _ LEN ▁= ▁42 8 ; ▁# if ▁0 ▁// Leav ing ▁this ▁in ▁for ▁now , ▁we ▁ma y ▁need ▁this ▁for ▁some ▁test ▁cases ▁static ▁ FILE ▁* outfile ; ▁static ▁size _ t ▁write _ func ( void ▁* ptr , ▁size _ t ▁size , ▁size _ t ▁nmemb , ▁void ▁* user data ) ▁{ ▁size _ t ▁written ; ▁written ▁= ▁f write ( ptr , size , nmemb , outfile ); ▁return ▁written ; ▁} ▁# endif ▁static ▁void ▁us 899_ clean ▁( void ) ▁{ ▁} ▁static ▁int ▁us 899_ start _ server ▁( int ▁manual _ enroll , ▁int ▁nid ) ▁{ ▁int ▁rv ; ▁rv ▁= ▁st _ start ( US 899_ SERVER _ PORT , ▁US 899_ SERVER _ CERTKEY , ▁US 899_ SERVER _ CERTKEY , ▁" US 899 ▁test ▁realm ", ▁US 899_ CACERTS , ▁US 899_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁manual _ enroll , ▁0, ▁nid ); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁initialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁allocate ▁data ▁or ▁open ▁any ▁* ▁resource s ▁required ▁for ▁all ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 899_ init _ suite ▁( void ) ▁{ ▁int ▁rv ; ▁# if def ▁W IN 32 ▁Initialize CriticalSection ▁(& logger _ critical _ section ); ▁est _ init _ logger ( EST _ LOG _ L VL _ INFO , ▁& us 899_ logger _ stderr ); ▁# endif ▁/* ▁* ▁Rea d ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( US 899_ CACERTS , ▁& cacerts ); ▁if ▁( cacerts _ len ▁ < = ▁0) ▁{ ▁return ▁1; ▁} ▁us 899_ clean (); ▁/* ▁* ▁Start ▁an ▁instance ▁of ▁the ▁EST ▁server ▁with ▁* ▁automatic ▁enrollment ▁enabled . ▁*/ ▁rv ▁= ▁us 899_ start _ server ( 0 , ▁0); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁uninitialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁de allocate ▁data ▁or ▁close ▁any ▁* ▁resource s ▁that ▁we re ▁used ▁for ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 899_ destroy _ suite ▁( void ) ▁{ ▁st _ stop (); ▁free ( cacerts ); ▁return ▁0; ▁} ▁/* ▁* ▁C allback ▁function ▁passed ▁to ▁est _ client _ init () ▁*/ ▁static ▁int ▁client _ manual _ cert _ verify ( X 509 ▁* cur _ cert , ▁int ▁openssl _ cert _ error ) ▁{ ▁BIO ▁* bio _ err ; ▁bio _ err = BIO _ new _ fp ( stderr , BIO _ NO CLOSE ); ▁int ▁approve ▁= ▁0; ▁/* ▁* ▁Pr int ▁out ▁the ▁specific s ▁of ▁this ▁cert ▁*/ ▁ printf ("% s : ▁OpenSSL / EST ▁server ▁cert ▁verification ▁failed ▁with ▁the ▁following ▁error : ▁openssl _ cert _ error ▁= ▁% d ▁(% s ) \ n ", ▁ _ _ FUNCTION _ _ , ▁openssl _ cert _ error , ▁X 509_ verify _ cert _ error _ string ( openssl _ cert _ error ) ); ▁ printf (" Fail ing ▁Cert : \ n "); ▁X 509_ print _ fp ( stdout , cur _ cert ); ▁/* ▁* ▁ Next ▁call ▁print s ▁out ▁the ▁signature ▁which ▁can ▁be ▁used ▁as ▁the ▁fingerprint ▁* ▁This ▁fingerprint ▁can ▁be ▁checked ▁against ▁the ▁anti cip ated ▁value ▁to ▁determine ▁* ▁whether ▁or ▁not ▁the ▁server ' s ▁cert ▁should ▁be ▁approved . ▁*/ ▁X 509_ signature _ print ( bio _ err , ▁cur _ cert -> sig _ alg , ▁cur _ cert -> signature ); ▁if ▁( openssl _ cert _ error ▁ == ▁X 509_ V _ ERR _ U NABLE _ TO _ GET _ CRL ) ▁{ ▁approve ▁= ▁1; ▁} ▁BIO _ free ( bio _ err ); ▁return ▁approve ; ▁} ▁static ▁E VP _ PKEY ▁* ▁generate _ private _ key ▁( void ) ▁{ ▁RSA ▁* rsa ▁= ▁RSA _ new (); ▁B IG NUM ▁* bn ▁= ▁ BN _ new (); ▁E VP _ PKEY ▁* pkey ; ▁/* ▁* ▁create ▁an ▁RSA ▁ keypair ▁and ▁assign ▁them ▁to ▁a ▁ PKEY ▁and ▁return ▁it . ▁*/ ▁ BN _ set _ word ( bn , ▁0 x 1000 1); ▁RSA _ generate _ key _ ex ( rsa , ▁1024 , ▁bn , ▁NULL ); ▁pkey ▁= ▁E VP _ PKEY _ new (); ▁if ▁( pkey == NULL ) ▁{ ▁ printf (" \ n Error ▁allocat ing ▁ PKEY ▁structure ▁for ▁new ▁key ▁pair \ n "); ▁return ▁NULL ; ▁} ▁if ▁(! E VP _ PKEY _ set 1 _ RSA ( pkey , ▁rsa )) ▁{ ▁ printf (" \ n Error ▁assign ing ▁RSA ▁key ▁pair ▁to ▁ PKEY ▁structure \ n "); ▁return ▁NULL ; ▁} ▁RSA _ free ( rsa ); ▁ BN _ free ( bn ); ▁return ▁( pkey ); ▁} ▁static ▁int ▁populate _ x 509_ csr ▁( X 509_ REQ ▁* req , ▁E VP _ PKEY ▁* pkey , ▁char ▁* cn ) ▁{ ▁X 509_ NAME ▁* subj ; ▁/* ▁set up ▁version ▁number ▁*/ ▁if ▁(! X 509_ REQ _ set _ version ( req , ▁0 L )) ▁{ ▁ printf (" \ nU nable ▁to ▁set ▁X 509 ▁version # \ n "); ▁return ▁(-1 ); ▁} ▁/* ▁* ▁Add ▁Common ▁Name ▁entry ▁*/ ▁subj ▁= ▁X 509_ REQ _ get _ subject _ name ( req ); ▁if ▁(! X 509_ NAME _ add _ entry _ by _ txt ( subj , ▁" CN ", ▁MB STRING _ ASC , ▁( un signed ▁char *) cn , ▁-1, ▁-1, ▁0) ) ▁{ ▁ printf (" \ nU nable ▁to ▁create ▁X 509 ▁Common ▁Name ▁entry \ n "); ▁return ▁(-1 ); ▁} ▁/* ▁* ▁Set ▁the ▁public ▁key ▁on ▁the ▁request ▁*/ ▁if ▁(! X 509_ REQ _ set _ pub key ( req , ▁pkey )) ▁{ ▁ printf (" \ nU nable ▁to ▁set ▁X 509 ▁public ▁key \ n "); ▁return ▁(-1 ); ▁} ▁return ▁( 0 ); ▁} ▁/* ▁* ▁Sign ▁an ▁X 509 ▁certificate ▁request ▁using ▁the ▁digest ▁and ▁the ▁key ▁passed . ▁* ▁Returns ▁OpenSSL ▁error ▁code ▁from ▁X 509_ REQ _ sign _ ctx (); ▁*/ ▁static ▁int ▁sign _ X 509_ req ▁( X 509_ REQ ▁* x , ▁E VP _ PKEY ▁* pkey , ▁const ▁E VP _ MD ▁* md ) ▁{ ▁int ▁rv ; ▁E VP _ PKEY _ CTX ▁* pkctx ▁= ▁NULL ; ▁E VP _ MD _ CTX ▁ mctx ; ▁E VP _ MD _ CTX _ init (& mctx ); ▁if ▁(! E VP _ Digest Sign Init (& mctx , ▁& pkctx , ▁md , ▁NULL , ▁pkey )) ▁{ ▁return ▁0; ▁} ▁/* ▁* ▁E ncode ▁using ▁DER ▁( ASN .1) ▁* ▁* ▁We ▁have ▁to ▁set ▁the ▁modifi ed ▁flag ▁on ▁the ▁X 509_ REQ ▁because ▁* ▁OpenSSL ▁keep s ▁a ▁cached ▁copy ▁of ▁the ▁DER ▁encoded ▁data ▁in ▁some ▁* ▁cases . ▁Set ting ▁this ▁flag ▁tell s ▁OpenSSL ▁to ▁run ▁the ▁ASN ▁* ▁encoding ▁again ▁ra ther ▁than ▁using ▁the ▁cached ▁copy . ▁*/ ▁x -> req _ info -> enc . modifi ed ▁= ▁1; ▁rv ▁= ▁X 509_ REQ _ sign _ ctx ( x , ▁& mctx ); ▁E VP _ MD _ CTX _ cleanup (& mctx ); ▁return ▁( rv ); ▁} ▁/* ▁* ▁This ▁function ▁perform s ▁a ▁basic ▁simple ▁enroll ▁using ▁* ▁a ▁UID / PWD ▁to ▁identify ▁the ▁client ▁to ▁the ▁server . ▁This ▁* ▁is ▁used ▁for ▁a ▁variet y ▁of ▁test ▁cases ▁in ▁this ▁ module . ▁*/ ▁static ▁void ▁us 899_ simple _ enroll ▁( char ▁* cn , ▁char ▁* server , ▁EST _ ERROR ▁expected _ enroll _ rv ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 899_ UID , ▁US 899_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁server , ▁US 899_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁ == ▁expected _ enroll _ rv ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁cn , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁expected _ enroll _ rv ); ▁/* ▁* ▁ Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁ == ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ectx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁* ▁* ▁This ▁is ▁a ▁basic ▁test ▁to ▁perform ▁a ▁/ simpleenroll ▁using ▁a ▁* ▁user ▁ID ▁and ▁password ▁to ▁identify ▁the ▁client ▁to ▁the ▁server . ▁* ▁No ▁identity ▁certificate ▁is ▁used ▁by ▁the ▁client . ▁*/ ▁static ▁void ▁us 899_ test 1 ▁( void ) ▁{ ▁ LOG _ FUNC _ NM ; ▁us 899_ simple _ enroll (" TC 899-1 ", ▁US 899_ SERVER _ IP , ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁CSR ▁* ▁* ▁This ▁is ▁a ▁basic ▁test ▁to ▁perform ▁a ▁/ simpleenroll ▁using ▁a ▁* ▁user ▁ID ▁and ▁password ▁to ▁identify ▁the ▁client ▁to ▁the ▁server . ▁* ▁No ▁identity ▁certificate ▁is ▁used ▁by ▁the ▁client . ▁* ▁This ▁test ▁case ▁uses ▁the ▁alternat e ▁enroll ▁method ▁ where ▁the ▁CSR ▁* ▁is ▁provided ▁by ▁the ▁application ▁layer ▁ra ther ▁than ▁ having ▁libest ▁* ▁generate ▁the ▁CSR . ▁*/ ▁static ▁void ▁us 899_ test 2 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁X 509_ REQ ▁* csr ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 899_ UID , ▁US 899_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 899_ SERVER _ IP , ▁US 899_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Generat e ▁a ▁CSR ▁*/ ▁csr ▁= ▁X 509_ REQ _ new (); ▁CU _ ASSERT ( csr ▁ != ▁NULL ); ▁rv ▁= ▁populate _ x 509_ csr ( csr , ▁key , ▁" US 899- TC 2 "); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Use ▁the ▁alternat e ▁API ▁to ▁enroll ▁an ▁existing ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll _ csr ( ectx , ▁csr , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁ Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁ == ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ectx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁X 509_ REQ _ free ( csr ); ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁{ ▁free ( new _ cert ); ▁} ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁CSR ▁- ▁Null ▁* ▁* ▁This ▁is ▁a ▁basic ▁test ▁to ▁perform ▁a ▁/ simpleenroll ▁using ▁a ▁* ▁user ▁ID ▁and ▁password ▁to ▁identify ▁the ▁client ▁to ▁the ▁server . ▁* ▁No ▁identity ▁certificate ▁is ▁used ▁by ▁the ▁client . ▁* ▁This ▁test ▁case ▁uses ▁the ▁alternat e ▁enroll ▁method ▁ where ▁the ▁CSR ▁* ▁is ▁provided ▁by ▁the ▁application ▁layer ▁ra ther ▁than ▁ having ▁libest ▁* ▁generate ▁the ▁CSR . ▁It ▁attempts ▁to ▁pass ▁in ▁null ▁CSR , ▁which ▁should ▁* ▁fail . ▁*/ ▁static ▁void ▁us 899_ test 3 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 899_ UID , ▁US 899_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 899_ SERVER _ IP , ▁US 899_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Use ▁the ▁alternat e ▁API ▁to ▁enroll ▁a ▁null ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll _ csr ( ectx , ▁NULL , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NO _ CSR ); ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁CSR ▁- ▁corrupted ▁* ▁* ▁This ▁test ▁checks ▁the ▁X 509_ REQ ▁ helper ▁function ▁is ▁working ▁pro ple ry . ▁*/ ▁static ▁void ▁us 899_ test 4 ▁( void ) ▁{ ▁X 509_ REQ ▁* csr ; ▁un signed ▁char ▁ badreq [1 4] ▁= ▁" bogus ▁request "; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁First ▁try ▁PEM ▁decoding ▁*/ ▁csr ▁= ▁est _ read _ x 509_ request ( badreq , ▁13 , ▁EST _ CERT _ FORMAT _ PEM ); ▁CU _ ASSERT ( csr ▁ == ▁NULL ); ▁/* ▁* ▁ Next ▁try ▁DER ▁decoding ▁*/ ▁csr ▁= ▁est _ read _ x 509_ request ( badreq , ▁13 , ▁EST _ CERT _ FORMAT _ DER ); ▁CU _ ASSERT ( csr ▁ == ▁NULL ); ▁/* ▁* ▁ Next ▁try ▁an ▁invalid ▁format ▁*/ ▁csr ▁= ▁est _ read _ x 509_ request ( badreq , ▁13 , ▁999 ); ▁CU _ ASSERT ( csr ▁ == ▁NULL ); ▁/* ▁* ▁ Next ▁try ▁an ▁invalid ▁csr ▁length ▁*/ ▁csr ▁= ▁est _ read _ x 509_ request ( badreq , ▁ 99 9999 , ▁EST _ CERT _ FORMAT _ PEM ); ▁CU _ ASSERT ( csr ▁ == ▁NULL ); ▁/* ▁* ▁ Next ▁try ▁a ▁valid ▁PEM ▁encoded ▁csr ▁*/ ▁csr ▁= ▁est _ read _ x 509_ request ( ( un signed ▁char *) US 899_ VALID _ CSR _ PEM , ▁str len ( US 899_ VALID _ CSR _ PEM ) , ▁EST _ CERT _ FORMAT _ PEM ); ▁CU _ ASSERT ( csr ▁ != ▁NULL ); ▁if ▁( csr ) ▁{ ▁X 509_ REQ _ free ( csr ); ▁} ▁/* ▁* ▁ Next ▁try ▁a ▁valid ▁DER ▁encoded ▁csr ▁*/ ▁csr ▁= ▁est _ read _ x 509_ request ( ( un signed ▁char *) US 899_ VALID _ CSR _ DER , ▁US 899_ VALID _ CSR _ DER _ LEN , ▁EST _ CERT _ FORMAT _ DER ); ▁CU _ ASSERT ( csr ▁ != ▁NULL ); ▁if ▁( csr ) ▁{ ▁X 509_ REQ _ free ( csr ); ▁} ▁} ▁// C . ▁Attempt ▁to ▁enroll ▁a ▁new ly ▁created ▁CSR ▁that ' s ▁al ready ▁been ▁signed ▁// ▁ via ▁est _ client _ enroll _ csr ▁static ▁void ▁us 899_ test 5 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁X 509_ REQ ▁* csr ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 899_ UID , ▁US 899_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 899_ SERVER _ IP , ▁US 899_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Generat e ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Generat e ▁a ▁new ▁CSR ▁*/ ▁csr ▁= ▁X 509_ REQ _ new (); ▁CU _ ASSERT ( csr ▁ != ▁NULL ); ▁rv ▁= ▁populate _ x 509_ csr ( csr , ▁key , ▁" US 899- TC 5 "); ▁CU _ ASSERT ( csr ▁ != ▁NULL ); ▁/* ▁* ▁Sign ▁the ▁CSR ▁*/ ▁rv ▁= ▁sign _ X 509_ req ( csr , key , E VP _ sha 256() ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Use ▁the ▁alternat e ▁API ▁to ▁enroll ▁an ▁existing ▁CSR . ▁This ▁should ▁pass . ▁*/ ▁rv ▁= ▁est _ client _ enroll _ csr ( ectx , ▁csr , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Cleanup ▁*/ ▁X 509_ REQ _ free ( csr ); ▁E VP _ PKEY _ free ( key ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁ FQDN ▁mismatch ▁hostname ▁in ▁CN ▁* ▁* ▁This ▁test ▁confirm s ▁that ▁a ▁mismatche d ▁host ▁name ▁on ▁* ▁the ▁server ▁cert ▁CN ▁will ▁result ▁in ▁an ▁auth ▁failure ▁* ▁at ▁the ▁TLS ▁layer ▁on ▁the ▁client ▁side . ▁*/ ▁static ▁void ▁us 899_ test 6 ▁( void ) ▁{ ▁int ▁rv ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁Sto p ▁the ▁existing ▁server . ▁This ▁test ▁case ▁needs ▁* ▁the ▁server ▁to ▁use ▁a ▁diff erent ▁cert . ▁*/ ▁st _ stop (); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁certificate ▁that ▁contains ▁a ▁* ▁ bogus ▁hostname ▁in ▁the ▁CN ▁*/ ▁rv ▁= ▁st _ start ( US 899_ SERVER _ PORT , ▁US 899_ SERVER _ CERT _ CN _ MISMATCH , ▁US 899_ SERVER _ KEY _ CN _ MISMATCH , ▁" US 899 ▁test ▁realm ", ▁US 899_ CACERTS , ▁US 899_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rv ▁ == ▁0); ▁if ▁( rv ) ▁return ; ▁us 899_ simple _ enroll (" TC 899- 6 ", ▁US 899_ SERVER _ IP , ▁EST _ ERR _ FQDN _ MISMATCH ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁ FQDN ▁mismatch ▁IPv 4 ▁address ▁in ▁CN ▁* ▁* ▁This ▁test ▁confirm s ▁that ▁a ▁mismatche d ▁IP ▁address ▁in ▁* ▁the ▁server ▁cert ▁CN ▁will ▁result ▁in ▁an ▁auth ▁failure ▁* ▁at ▁the ▁TLS ▁layer ▁on ▁the ▁client ▁side . ▁* ▁Note : ▁this ▁test ▁ma y ▁be ▁redu nd ant ▁since ▁the ▁IP ▁address ▁* ▁match ing ▁logic ▁only ▁occurs ▁when ▁the ▁d NS Name ▁is ▁* ▁used ▁instead ▁of ▁the ▁CommonName . ▁*/ ▁static ▁void ▁us 899_ test 7 ▁( void ) ▁{ ▁int ▁rv ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁Sto p ▁the ▁existing ▁server . ▁This ▁test ▁case ▁needs ▁* ▁the ▁server ▁to ▁use ▁a ▁diff erent ▁cert . ▁*/ ▁st _ stop (); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁certificate ▁that ▁contains ▁a ▁* ▁ bogus ▁hostname ▁in ▁the ▁CN ▁*/ ▁rv ▁= ▁st _ start ( US 899_ SERVER _ PORT , ▁US 899_ SERVER _ CERT _ CN _ MISMATCH _ IP , ▁US 899_ SERVER _ KEY _ CN _ MISMATCH _ IP , ▁" US 899 ▁test ▁realm ", ▁US 899_ CACERTS , ▁US 899_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rv ▁ == ▁0); ▁if ▁( rv ) ▁return ; ▁us 899_ simple _ enroll (" TC 899- 7", ▁US 899_ SERVER _ IP , ▁EST _ ERR _ FQDN _ MISMATCH ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁ FQDN ▁matched ▁wildcard ▁in ▁CN ▁* ▁* ▁This ▁test ▁confirm s ▁that ▁wildcard ▁match ing ▁logic ▁* ▁in ▁the ▁CN ▁is ▁working . ▁The ▁cert ▁uses ▁a ▁wildcard ▁* ▁pattern ▁of ▁* . cisco . com ▁with ▁a ▁server ▁address ▁* ▁of ▁local host . cisco . com . ▁*/ ▁static ▁void ▁us 899_ test 8 ▁( void ) ▁{ ▁int ▁rv ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁Sto p ▁the ▁existing ▁server . ▁This ▁test ▁case ▁needs ▁* ▁the ▁server ▁to ▁use ▁a ▁diff erent ▁cert . ▁*/ ▁st _ stop (); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁certificate ▁that ▁contains ▁a ▁* ▁ bogus ▁hostname ▁in ▁the ▁CN ▁*/ ▁rv ▁= ▁st _ start ( US 899_ SERVER _ PORT , ▁US 899_ SERVER _ CERT _ CN _ MATCH _ WC , ▁US 899_ SERVER _ KEY _ CN _ MATCH _ WC , ▁" US 899 ▁test ▁realm ", ▁US 899_ CACERTS , ▁US 899_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rv ▁ == ▁0); ▁if ▁( rv ) ▁return ; ▁us 899_ simple _ enroll (" TC 899- 8 ", ▁" local host . cisco . com ", ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁ FQDN ▁mismatche d ▁wildcard ▁in ▁CN ▁* ▁* ▁This ▁test ▁confirm s ▁that ▁wildcard ▁match ing ▁logic ▁* ▁in ▁the ▁CN ▁is ▁working . ▁The ▁cert ▁uses ▁a ▁wildcard ▁* ▁pattern ▁of ▁* . goo gle . com ▁with ▁a ▁server ▁address ▁* ▁of ▁local host . cisco . com . ▁*/ ▁static ▁void ▁us 899_ test 9 ▁( void ) ▁{ ▁int ▁rv ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁Sto p ▁the ▁existing ▁server . ▁This ▁test ▁case ▁needs ▁* ▁the ▁server ▁to ▁use ▁a ▁diff erent ▁cert . ▁*/ ▁st _ stop (); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁certificate ▁that ▁contains ▁a ▁* ▁ bogus ▁hostname ▁in ▁the ▁CN ▁*/ ▁rv ▁= ▁st _ start ( US 899_ SERVER _ PORT , ▁US 899_ SERVER _ CERT _ CN _ MISMATCH _ WC , ▁US 899_ SERVER _ KEY _ CN _ MISMATCH _ WC , ▁" US 899 ▁test ▁realm ", ▁US 899_ CACERTS , ▁US 899_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rv ▁ == ▁0); ▁if ▁( rv ) ▁return ; ▁us 899_ simple _ enroll (" TC 899- 9", ▁" local host . cisco . com ", ▁EST _ ERR _ FQDN _ MISMATCH ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁ FQDN ▁matched ▁hostname ▁in ▁SubjectAltName ▁* ▁* ▁This ▁test ▁confirm s ▁that ▁a ▁matched ▁host ▁name ▁on ▁* ▁the ▁server ▁cert ▁SubjectAltName ▁ext ▁will ▁result ▁in ▁an ▁auth ▁success . ▁*/ ▁static ▁void ▁us 899_ test 10 ▁( void ) ▁{ ▁int ▁rv ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁Sto p ▁the ▁existing ▁server . ▁This ▁test ▁case ▁needs ▁* ▁the ▁server ▁to ▁use ▁a ▁diff erent ▁cert . ▁*/ ▁st _ stop (); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁certificate ▁that ▁contains ▁a ▁* ▁ bogus ▁hostname ▁in ▁the ▁CN ▁*/ ▁rv ▁= ▁st _ start ( US 899_ SERVER _ PORT , ▁US 899_ SERVER _ CERT _ SAN _ MATCH , ▁US 899_ SERVER _ KEY _ SAN _ MATCH , ▁" US 899 ▁test ▁realm ", ▁US 899_ CACERTS , ▁US 899_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rv ▁ == ▁0); ▁if ▁( rv ) ▁return ; ▁us 899_ simple _ enroll (" TC 899-1 0", ▁" local host . cisco . com ", ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁ FQDN ▁mismatche d ▁hostname ▁in ▁SubjectAltName ▁* ▁* ▁This ▁test ▁confirm s ▁that ▁a ▁mismatche d ▁host ▁name ▁on ▁* ▁the ▁server ▁cert ▁SubjectAltName ▁ext ▁will ▁result ▁in ▁an ▁auth ▁failure . ▁*/ ▁static ▁void ▁us 899_ test 11 ▁( void ) ▁{ ▁int ▁rv ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁Sto p ▁the ▁existing ▁server . ▁This ▁test ▁case ▁needs ▁* ▁the ▁server ▁to ▁use ▁a ▁diff erent ▁cert . ▁*/ ▁st _ stop (); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁certificate ▁that ▁contains ▁a ▁* ▁ bogus ▁hostname ▁in ▁the ▁CN ▁*/ ▁rv ▁= ▁st _ start ( US 899_ SERVER _ PORT , ▁US 899_ SERVER _ CERT _ SAN _ MISMATCH , ▁US 899_ SERVER _ KEY _ SAN _ MISMATCH , ▁" US 899 ▁test ▁realm ", ▁US 899_ CACERTS , ▁US 899_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rv ▁ == ▁0); ▁if ▁( rv ) ▁return ; ▁us 899_ simple _ enroll (" TC 899-1 1", ▁" local host . cisco . com ", ▁EST _ ERR _ FQDN _ MISMATCH ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁ FQDN ▁mismatche d ▁IPv 4 ▁address ▁in ▁SubjectAltName ▁* ▁* ▁This ▁test ▁confirm s ▁that ▁a ▁mismatche d ▁IPv 4 ▁address ▁on ▁* ▁the ▁server ▁cert ▁SubjectAltName ▁ext ▁will ▁result ▁in ▁an ▁auth ▁failure . ▁*/ ▁static ▁void ▁us 899_ test 12 ▁( void ) ▁{ ▁int ▁rv ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁Sto p ▁the ▁existing ▁server . ▁This ▁test ▁case ▁needs ▁* ▁the ▁server ▁to ▁use ▁a ▁diff erent ▁cert . ▁*/ ▁st _ stop (); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁certificate ▁that ▁contains ▁a ▁* ▁ bogus ▁hostname ▁in ▁the ▁CN ▁*/ ▁rv ▁= ▁st _ start ( US 899_ SERVER _ PORT , ▁US 899_ SERVER _ CERT _ SAN _ MISMATCH _ IP , ▁US 899_ SERVER _ KEY _ SAN _ MISMATCH _ IP , ▁" US 899 ▁test ▁realm ", ▁US 899_ CACERTS , ▁US 899_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rv ▁ == ▁0); ▁if ▁( rv ) ▁return ; ▁us 899_ simple _ enroll (" TC 899-1 2 ", ▁US 899_ SERVER _ IP , ▁EST _ ERR _ FQDN _ MISMATCH ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁ FQDN ▁matched ▁IPv 4 ▁address ▁in ▁SubjectAltName ▁* ▁* ▁This ▁test ▁confirm s ▁that ▁a ▁matched ▁IPv 4 ▁address ▁on ▁* ▁the ▁server ▁cert ▁SubjectAltName ▁ext ▁will ▁result ▁in ▁an ▁auth ▁success . ▁*/ ▁static ▁void ▁us 899_ test 13 ▁( void ) ▁{ ▁int ▁rv ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁Sto p ▁the ▁existing ▁server . ▁This ▁test ▁case ▁needs ▁* ▁the ▁server ▁to ▁use ▁a ▁diff erent ▁cert . ▁*/ ▁st _ stop (); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁certificate ▁that ▁contains ▁a ▁* ▁ bogus ▁hostname ▁in ▁the ▁CN ▁*/ ▁rv ▁= ▁st _ start ( US 899_ SERVER _ PORT , ▁US 899_ SERVER _ CERT _ SAN _ MATCH _ IP , ▁US 899_ SERVER _ KEY _ SAN _ MATCH _ IP , ▁" US 899 ▁test ▁realm ", ▁US 899_ CACERTS , ▁US 899_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rv ▁ == ▁0); ▁if ▁( rv ) ▁return ; ▁us 899_ simple _ enroll (" TC 899-1 3 ", ▁US 899_ SERVER _ IP , ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁ FQDN ▁matched ▁hostname ▁in ▁SubjectAltName ▁with ▁wildcard ▁* ▁* ▁This ▁test ▁confirm s ▁that ▁a ▁hostname ▁matches ▁a ▁wildcard ▁pattern ▁in ▁* ▁the ▁server ▁cert ▁SubjectAltName ▁ext , ▁which ▁will ▁result ▁in ▁an ▁auth ▁success . ▁*/ ▁static ▁void ▁us 899_ test 14 ▁( void ) ▁{ ▁int ▁rv ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁Sto p ▁the ▁existing ▁server . ▁This ▁test ▁case ▁needs ▁* ▁the ▁server ▁to ▁use ▁a ▁diff erent ▁cert . ▁*/ ▁st _ stop (); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁certificate ▁that ▁contains ▁a ▁* ▁ bogus ▁hostname ▁in ▁the ▁CN ▁*/ ▁rv ▁= ▁st _ start ( US 899_ SERVER _ PORT , ▁US 899_ SERVER _ CERT _ SAN _ MATCH _ WC , ▁US 899_ SERVER _ KEY _ SAN _ MATCH _ WC , ▁" US 899 ▁test ▁realm ", ▁US 899_ CACERTS , ▁US 899_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rv ▁ == ▁0); ▁if ▁( rv ) ▁return ; ▁us 899_ simple _ enroll (" TC 899-1 4", ▁" local host . cisco . com ", ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁ FQDN ▁mismatche d ▁hostname ▁in ▁SubjectAltName ▁with ▁wildcard ▁* ▁* ▁This ▁test ▁confirm s ▁that ▁a ▁hostname ▁mismatche s ▁a ▁wildcard ▁pattern ▁in ▁* ▁the ▁server ▁cert ▁SubjectAltName ▁ext , ▁which ▁will ▁result ▁in ▁an ▁auth ▁fail . ▁*/ ▁static ▁void ▁us 899_ test 15 ▁( void ) ▁{ ▁int ▁rv ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁Sto p ▁the ▁existing ▁server . ▁This ▁test ▁case ▁needs ▁* ▁the ▁server ▁to ▁use ▁a ▁diff erent ▁cert . ▁*/ ▁st _ stop (); ▁/* ▁* ▁Spi n ▁up ▁a ▁new ▁instance ▁of ▁the ▁EST ▁server ▁* ▁using ▁a ▁certificate ▁that ▁contains ▁a ▁* ▁ bogus ▁hostname ▁in ▁the ▁CN ▁*/ ▁rv ▁= ▁st _ start ( US 899_ SERVER _ PORT , ▁US 899_ SERVER _ CERT _ SAN _ MISMATCH _ WC , ▁US 899_ SERVER _ KEY _ SAN _ MISMATCH _ WC , ▁" US 899 ▁test ▁realm ", ▁US 899_ CACERTS , ▁US 899_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁0, ▁0, ▁0); ▁CU _ ASSERT ( rv ▁ == ▁0); ▁if ▁( rv ) ▁return ; ▁us 899_ simple _ enroll (" TC 899-1 5 ", ▁" local host . cisco . com ", ▁EST _ ERR _ FQDN _ MISMATCH ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁CRL ▁check ▁enabled ▁on ▁client ▁* ▁* ▁We ▁enable ▁CRL ▁checking ▁on ▁the ▁client ▁side . ▁We ▁will ▁* ▁generate ▁a ▁CRL , ▁but ▁the ▁server ▁cert ▁will ▁not ▁be ▁* ▁revoked . ▁The ▁enroll ▁should ▁succeed . ▁*/ ▁static ▁void ▁us 899_ test 16 ▁( void ) ▁{ ▁int ▁rv ; ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁un signed ▁char ▁* cacrlcerts ▁= ▁NULL ; ▁int ▁ cacrlcerts _ len ▁= ▁0; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁Sto p ▁the ▁existing ▁server . ▁This ▁test ▁case ▁needs ▁* ▁the ▁server ▁to ▁use ▁a ▁diff erent ▁cert . ▁*/ ▁st _ stop (); ▁/* ▁* ▁No w ▁that ▁all ▁the ▁ FQDN ▁tests ▁are ▁complete d , ▁start ▁* ▁the ▁normal ▁server . ▁*/ ▁rv ▁= ▁us 899_ start _ server ( 0 , ▁0); ▁CU _ ASSERT ( rv ▁ == ▁0); ▁/* ▁* ▁Generat e ▁a ▁CRL ▁and ▁append ▁it ▁to ▁the ▁CA ▁chain ▁* ▁we ' re ▁using ▁on ▁the ▁client ▁side . ▁*/ ▁# if n def ▁W IN 32 ▁system (" openssl ▁ca ▁- config ▁CA / est Example CA . cnf ▁- gen crl ▁- out ▁US 899/ test 16 _ crl . pem "); ▁SL EEP (1); ▁system (" cat ▁CA / trustedcerts . crt ▁> ▁US 899/ test 16 trust . crt "); ▁SL EEP (1); ▁system (" cat ▁US 899/ test 16 _ crl . pem ▁> > ▁US 899/ test 16 trust . crt "); ▁SL EEP (1); ▁# else ▁system (" openssl ▁ca ▁- config ▁CA / est Example CA . cnf ▁- gen crl ▁- out ▁US 899/ test 16 _ crl . pem "); ▁SL EEP (1); ▁system (" type ▁CA \\ trustedcerts . crt ▁> ▁US 899\\ test 16 trust . crt "); ▁SL EEP (1); ▁system (" type ▁US 899\\ test 16 _ crl . pem ▁> > ▁US 899\\ test 16 trust . crt "); ▁SL EEP (1); ▁# endif ▁/* ▁* ▁Rea d ▁in ▁the ▁CA ▁certificates ▁*/ ▁ cacrlcerts _ len ▁= ▁read _ binary _ file (" US 899/ test 16 trust . crt ", ▁& cacrlcerts ); ▁CU _ ASSERT ( cacrlcerts ▁> ▁0); ▁if ▁( cacrlcerts _ len ▁ < = ▁0) ▁{ ▁return ; ▁} ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacrlcerts , ▁ cacrlcerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁E nable ▁CRL ▁checking ▁on ▁the ▁client ▁*/ ▁rv ▁= ▁est _ enable _ crl ( ectx ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 899_ UID , ▁US 899_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 899_ SERVER _ IP , ▁US 899_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁" TEST 16- CN ", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁ Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁ == ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ectx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ectx ); ▁free ( cacrlcerts ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁CRL ▁check ▁enabled ▁on ▁client ▁* ▁* ▁We ▁enable ▁CRL ▁checking ▁on ▁the ▁client ▁side . ▁We ▁will ▁* ▁generate ▁a ▁CRL , ▁the ▁server ▁cert ▁will ▁be ▁* ▁revoked . ▁The ▁enroll ▁should ▁fail . ▁*/ ▁static ▁void ▁us 899_ test 17 ▁( void ) ▁{ ▁int ▁rv ; ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* cacrlcerts ▁= ▁NULL ; ▁int ▁ cacrlcerts _ len ▁= ▁0; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁ Revoke ▁the ▁server ▁cert , ▁generate ▁a ▁CRL ▁and ▁append ▁it ▁to ▁the ▁CA ▁chain ▁* ▁we ' re ▁using ▁on ▁the ▁client ▁side . ▁*/ ▁# if n def ▁W IN 32 ▁system (" cp ▁CA / estCA / index . txt ▁CA / estCA / index . txt . save "); ▁SL EEP (1); ▁system (" openssl ▁ca ▁- config ▁CA / est Example CA . cnf ▁- revoke ▁CA / estCA / private / estserver cert and key . pem "); ▁SL EEP (1); ▁system (" openssl ▁ca ▁- config ▁CA / est Example CA . cnf ▁- gen crl ▁- out ▁US 899/ test 17 _ crl . pem "); ▁SL EEP (1); ▁system (" cat ▁CA / trustedcerts . crt ▁> ▁US 899/ test 17 trust . crt "); ▁SL EEP (1); ▁system (" cat ▁US 899/ test 17 _ crl . pem ▁> > ▁US 899/ test 17 trust . crt "); ▁SL EEP (1); ▁system (" cp ▁CA / estCA / index . txt . save ▁CA / estCA / index . txt "); ▁SL EEP (1); ▁# else ▁system (" copy ▁CA \\ estCA \\ index . txt ▁CA \\ estCA \\ index . txt . save "); ▁SL EEP (1); ▁system (" openssl ▁ca ▁- config ▁CA \\ est Example CA . cnf ▁- revoke ▁CA \\ estCA \\ private \\ estserver cert and key . pem "); ▁SL EEP (1); ▁system (" openssl ▁ca ▁- config ▁CA \\ est Example CA . cnf ▁- gen crl ▁- out ▁US 899\\ test 17 _ crl . pem "); ▁SL EEP (1); ▁system (" type ▁CA \\ trustedcerts . crt ▁> ▁US 899\\ test 17 trust . crt "); ▁SL EEP (1); ▁system (" type ▁US 899\\ test 17 _ crl . pem ▁> > ▁US 899\\ test 17 trust . crt "); ▁SL EEP (1); ▁system (" copy ▁CA \\ estCA \\ index . txt . save ▁CA \\ estCA \\ index . txt "); ▁SL EEP (1); ▁# endif ▁/* ▁* ▁Rea d ▁in ▁the ▁CA ▁certificates ▁*/ ▁ cacrlcerts _ len ▁= ▁read _ binary _ file (" US 899/ test 17 trust . crt ", ▁& cacrlcerts ); ▁CU _ ASSERT ( cacrlcerts ▁> ▁0); ▁if ▁( cacrlcerts _ len ▁ < = ▁0) ▁{ ▁return ; ▁} ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacrlcerts , ▁ cacrlcerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁E nable ▁CRL ▁checking ▁on ▁the ▁client ▁*/ ▁rv ▁= ▁est _ enable _ crl ( ectx ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 899_ UID , ▁US 899_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 899_ SERVER _ IP , ▁US 899_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ SSL _ CONNECT ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁" TEST 1 7- CN ", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ SSL _ CONNECT ); ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁est _ destroy ( ectx ); ▁free ( cacrlcerts ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁ Receive ▁Retr y - After ▁response ▁* ▁* ▁Client ▁issues ▁an ▁Enroll ▁request ▁and ▁receives ▁* ▁a ▁Retr y - After ▁response . ▁E nsure ▁that ▁the ▁* ▁retry ▁after ▁value ▁can ▁be ▁obtained ▁from ▁the ▁client . ▁*/ ▁static ▁void ▁us 899_ test 18 ▁( void ) ▁{ ▁int ▁rv ; ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁int ▁delay _ secs ▁= ▁0; ▁time _ t ▁retry _ date ▁= ▁0; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁Sto p ▁the ▁existing ▁server . ▁This ▁test ▁case ▁needs ▁* ▁the ▁server ▁to ▁go ▁into ▁manual ▁enroll ▁mode ▁*/ ▁st _ stop (); ▁/* ▁* ▁Start ▁the ▁server ▁up ▁in ▁manual ▁enroll ▁mode ▁*/ ▁rv ▁= ▁us 899_ start _ server ( 1, ▁0); ▁CU _ ASSERT ( rv ▁ == ▁0); ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁using ▁the ▁default ▁CA ▁certs ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 899_ UID , ▁US 899_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 899_ SERVER _ IP , ▁US 899_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁" TEST 18 - CN ", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ CA _ ENROLL _ RETRY ); ▁if ▁( rv ▁ == ▁EST _ ERR _ CA _ ENROLL _ RETRY ) ▁{ ▁/* ▁* ▁go ▁get ▁the ▁retry ▁dur ation ▁* ▁make ▁sure ▁it ' s ▁set ▁to ▁the ▁default ▁value ▁*/ ▁rv ▁= ▁est _ client _ copy _ retry _ after ( ectx , ▁& delay _ secs , ▁& retry _ date ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( delay _ secs ▁ == ▁3600 ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁est _ destroy ( ectx ); ▁} ▁// TO ▁DO ▁// ▁// Auth ▁( HTTP ▁basic ▁auth ▁enabled ▁on ▁server ) ▁// A . ▁Enroll ▁CSR ▁using ▁valid ▁cert , ▁no ▁UID ▁// B . ▁Enroll ▁CSR ▁using ▁valid ▁cert , ▁valid ▁UID ▁// C . ▁Enroll ▁CSR ▁using ▁valid ▁cert , ▁invalid ▁UID ▁// D . ▁Enroll ▁CSR ▁using ▁invalid ▁cert , ▁no ▁UID ▁// E . ▁Enroll ▁CSR ▁using ▁invalid ▁cert , ▁valid ▁UID ▁// F . ▁Enroll ▁CSR ▁using ▁invalid ▁cert , ▁invalid ▁UID ▁// ▁// Auth ▁( HTTP ▁digest ▁auth ▁enabled ▁on ▁server ) ▁// A . ▁Enroll ▁CSR ▁using ▁valid ▁cert , ▁no ▁UID ▁// B . ▁Enroll ▁CSR ▁using ▁valid ▁cert , ▁valid ▁UID ▁// C . ▁Enroll ▁CSR ▁using ▁valid ▁cert , ▁invalid ▁UID ▁// D . ▁Enroll ▁CSR ▁using ▁invalid ▁cert , ▁no ▁UID ▁// E . ▁Enroll ▁CSR ▁using ▁invalid ▁cert , ▁valid ▁UID ▁// F . ▁Enroll ▁CSR ▁using ▁invalid ▁cert , ▁invalid ▁UID ▁// ▁int ▁us 899_ add _ suite ▁( void ) ▁{ ▁# if def ▁HA VE _ C UNIT ▁CU _ pSuite ▁pSuite ▁= ▁NULL ; ▁/* ▁add ▁a ▁suite ▁to ▁the ▁ registry ▁*/ ▁pSuite ▁= ▁CU _ add _ suite (" us 899_ client _ simp enroll ", ▁us 899_ init _ suite , ▁us 899_ destroy _ suite ); ▁if ▁( NULL ▁ == ▁pSuite ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁/* ▁* ▁Add ▁the ▁tests ▁to ▁the ▁suite ▁* ▁* ▁ ***** *************** IMPORTANT ***** **************** ▁* ▁Do ▁not ▁change ▁the ▁order ▁of ▁these ▁tests . ▁* ▁Some ▁of ▁the ▁tests ▁stop ▁the ▁EST ▁server ▁and ▁restart ▁* ▁it ▁using ▁diff erent ▁certs . ▁If ▁you ▁change ▁the ▁order ▁* ▁then ▁fal se ▁negative s ▁ma y ▁occur . ▁* ▁** **************** **************** **************** ▁* ▁*/ ▁if ▁( ( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ", ▁us 899_ test 1)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁CSR ", ▁us 899_ test 2)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁null ▁CSR ", ▁us 899_ test 3)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁corrupted ▁CSR ", ▁us 899_ test 4)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁signed ▁CSR ", ▁us 899_ test 5)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁- ▁hostname ▁mismatch ▁ FQDN ▁CN ", ▁us 899_ test 6)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁- ▁IPv 4 ▁mismatch ▁ FQDN ▁CN ", ▁us 899_ test 7)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁- ▁wildcard ▁match ▁ FQDN ▁CN ", ▁us 899_ test 8)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁- ▁wildcard ▁mismatch ▁ FQDN ▁CN ", ▁us 899_ test 9 )) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁- ▁hostname ▁match ▁ FQDN ▁SAN ", ▁us 899_ test 10)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁- ▁hostname ▁mismatch ▁ FQDN ▁SAN ", ▁us 899_ test 11)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁- ▁IPv 4 ▁mismatch ▁ FQDN ▁SAN ", ▁us 899_ test 12)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁- ▁IPv 4 ▁match ▁ FQDN ▁SAN ", ▁us 899_ test 1 3)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁- ▁wildcard ▁match ▁ FQDN ▁SAN ", ▁us 899_ test 1 4)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁- ▁wildcard ▁mismatch ▁ FQDN ▁SAN ", ▁us 899_ test 1 5)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁- ▁CRL ▁enabled , ▁valid ▁server ▁cert ", ▁us 899_ test 16)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁- ▁CRL ▁enabled , ▁revoked ▁server ▁cert ", ▁us 899_ test 17)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Simple ▁enroll ▁- ▁Retr y - After ▁received ", ▁us 899_ test 18)) ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁return ▁CU E _ SUCCESS ; ▁# endif ▁}