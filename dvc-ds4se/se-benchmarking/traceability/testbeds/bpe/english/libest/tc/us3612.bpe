▁/* -- ---------------- ---------------- ---------------- ---------------- ▁* ▁us 3612 . c ▁- ▁ Unit ▁Test s ▁for ▁User ▁Stor y ▁US 3612 ▁- ▁Encrypted ▁Private ▁Key ▁Support ▁* ▁* ▁* ▁* ▁July , ▁2016 ▁* ▁* ▁Copy right ▁( c ) ▁2016 ▁by ▁ cisco ▁S ystems , ▁Inc . ▁* ▁All ▁ right s ▁ reserved . ▁* -- ---------------- ---------------- ---------------- ---------------- ▁*/ ▁# include ▁ < std io . h > ▁# if n def ▁W IN 32 ▁# include ▁ < uni std . h > ▁# endif ▁# include ▁ < est . h > ▁# include ▁" test _ util s . h " ▁# include ▁" st _ server . h " ▁# include ▁ < openssl / ssl . h > ▁# include ▁ < openssl / x 509 v 3 . h > ▁# if def ▁HA VE _ C UNIT ▁# include ▁" CUnit / Basic . h " ▁# include ▁" CUnit / A utomat ed . h " ▁# endif ▁static ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁static ▁char ▁* key _ password ▁= ▁NULL ; ▁static ▁int ▁cacerts _ len ▁= ▁0; ▁# define ▁US 3612_ SERVER _ PORT ▁2989 9 ▁# define ▁US 3612_ SERVER _ IP ▁"127.0.0.1" ▁# define ▁US 3612_ UID ▁" estuser " ▁# define ▁US 3612_ PWD ▁" estpwd " ▁# define ▁US 3612_ GOOD _ PWD ▁" us 3612 " ▁# define ▁US 3612_ BAD _ PWD ▁" this ca nt possibly work " ▁# define ▁RSA _ KEYSIZE ▁4096 ▁/* ▁* ▁Key ▁wrap ▁algorithm ▁optional ly ▁used ▁to ▁protect ▁private ▁keys ▁*/ ▁# define ▁EST _ PRIVATE _ KEY _ ENC ▁E VP _ aes _ 128 _ cb c () ▁/* ▁* ▁The ▁following ▁certs ▁are ▁used ▁for ▁ FQDN ▁testing ▁*/ ▁# if n def ▁W IN 32 ▁# define ▁US 3612_ CACERTS ▁" CA / estCA / cacert . crt " ▁# define ▁US 3612_ TRUST _ CERTS ▁" CA / trustedcerts . crt " ▁# define ▁US 3612_ SERVER _ CERTKEY ▁" CA / estCA / private / estserver cert and key . pem " ▁# define ▁US 3612_ PRIVATE _ KEY _ FILE ▁" US 3612 / us 3612_ key . pem " ▁# else ▁# define ▁US 3612_ CACERTS ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 3612_ TRUST _ CERTS ▁" CA \\ trustedcerts . crt " ▁# define ▁US 3612_ SERVER _ CERTKEY ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# define ▁US 3612_ PRIVATE _ KEY _ FILE ▁" US 3612 \\ us 3612_ key . pem " ▁static ▁CR ITI CAL _ SE CTION ▁logger _ critical _ section ; ▁static ▁void ▁us 3612_ logger _ stderr ▁( char ▁* format , ▁va _ list ▁l ) ▁{ ▁E nter CriticalSection (& logger _ critical _ section ); ▁ vf printf ( stderr , ▁format , ▁l ); ▁f flu sh ( stderr ); ▁ Leav eCriticalSection (& logger _ critical _ section ); ▁} ▁# endif ▁un signed ▁char ▁* BIO _ copy _ data ( BIO ▁* out , ▁int ▁* data _ len p ) ▁{ ▁un signed ▁char ▁* data , ▁* tdata ; ▁int ▁data _ len ; ▁data _ len ▁= ▁BIO _ get _ mem _ data ( out , ▁& tdata ); ▁data ▁= ▁malloc ( data _ len +1 ); ▁if ▁( data ) ▁{ ▁memcpy ( data , ▁t data , ▁data _ len ); ▁data [ data _ len ]= '\0'; ▁// ▁M ake ▁sure ▁it ' s ▁\ 0 ▁terminated , ▁in ▁case ▁used ▁as ▁string ▁if ▁( data _ len p ) ▁{ ▁* data _ len p ▁= ▁data _ len ; ▁} ▁} ▁else ▁{ ▁ printf (" malloc ▁failed "); ▁} ▁return ▁data ; ▁} ▁char ▁* generate _ private _ RSA _ key ▁( int ▁key _ size , ▁ pem _ password _ cb ▁* cb ) ▁{ ▁char ▁* key _ data ▁= ▁NULL ; ▁RSA ▁* rsa ▁= ▁RSA _ new (); ▁if ▁(! rsa ) ▁{ ▁return ▁NULL ; ▁} ▁B IG NUM ▁* bn ▁= ▁ BN _ new (); ▁if ▁(! bn ) ▁{ ▁RSA _ free ( rsa ); ▁return ▁NULL ; ▁} ▁ BN _ set _ word ( bn , ▁0 x 1000 1); ▁RSA _ generate _ key _ ex ( rsa , ▁key _ size , ▁bn , ▁NULL ); ▁do ▁{ ▁BIO ▁* out ▁= ▁BIO _ new ( BIO _ s _ mem () ); ▁if ▁(! out ) ▁{ ▁break ; ▁} ▁PEM _ write _ bio _ RSA PrivateKey ( out , ▁rsa , ▁cb ▁ ? ▁EST _ PRIVATE _ KEY _ ENC ▁ : ▁NULL , ▁NULL , ▁0, ▁cb , ▁NULL ); ▁key _ data ▁= ▁( char ▁*) BIO _ copy _ data ( out , ▁NULL ); ▁BIO _ free ( out ); ▁if ▁( key _ data ▁&& ▁! key _ data [0]) ▁{ ▁// ▁happen s ▁if ▁pass phrase ▁ enter ed ▁ via ▁STD IN ▁does ▁not ▁verify ▁or ▁has ▁ less ▁than ▁4 ▁characters ▁free ( key _ data ); ▁key _ data ▁= ▁NULL ; ▁} ▁} ▁while ▁( cb ▁&& ▁! key _ data ); ▁RSA _ free ( rsa ); ▁ BN _ free ( bn ); ▁return ▁( key _ data ); ▁} ▁char ▁* generate _ private _ EC _ key ▁( int ▁curve _ nid , ▁ pem _ password _ cb ▁* cb ) ▁{ ▁EC _ KEY ▁* eckey ; ▁EC _ GROUP ▁* group ▁= ▁NULL ; ▁char ▁* key _ data ▁= ▁NULL ; ▁int ▁as n 1 _ flag ▁= ▁O PEN SSL _ EC _ NAME D _ CU RVE ; ▁point _ conversion _ form _ t ▁form ▁= ▁PO INT _ CON VERSION _ UN COMP RESS ED ; ▁/* ▁* ▁Generat e ▁an ▁EC ▁key ▁*/ ▁eckey ▁= ▁EC _ KEY _ new (); ▁if ▁(! eckey ) ▁{ ▁return ▁NULL ; ▁} ▁group ▁= ▁EC _ GROUP _ new _ by _ curve _ name ( curve _ nid ); ▁EC _ GROUP _ set _ asn 1 _ flag ( group , ▁as n 1 _ flag ); ▁EC _ GROUP _ set _ point _ conversion _ form ( group , ▁form ); ▁EC _ KEY _ set _ group ( eckey , ▁group ); ▁if ▁(! EC _ KEY _ generate _ key ( eckey )) ▁{ ▁return ▁( NULL ); ▁} ▁do ▁{ ▁BIO ▁* out ▁= ▁BIO _ new ( BIO _ s _ mem () ); ▁if ▁(! out ) ▁{ ▁break ; ▁} ▁PEM _ write _ bio _ EC PK Parameters ( out , ▁group ); ▁PEM _ write _ bio _ EC PrivateKey ( out , ▁eckey , ▁cb ▁ ? ▁EST _ PRIVATE _ KEY _ ENC ▁ : ▁NULL , ▁NULL , ▁0, ▁cb , ▁NULL ); ▁key _ data ▁= ▁( char ▁*) BIO _ copy _ data ( out , ▁NULL ); ▁BIO _ free ( out ); ▁if ▁( key _ data ▁&& ▁! strstr ( key _ data , ▁" ----- BEG IN ▁EC ▁ PRIVATE ▁ KEY ----- ")) ▁{ ▁// ▁happen s ▁if ▁pass phrase ▁ enter ed ▁ via ▁STD IN ▁does ▁not ▁verify ▁or ▁has ▁ less ▁than ▁4 ▁characters ▁free ( key _ data ); ▁key _ data ▁= ▁NULL ; ▁} ▁} ▁while ▁( cb ▁&& ▁! key _ data ); ▁EC _ KEY _ free ( eckey ); ▁return ▁( key _ data ); ▁} ▁static ▁int ▁string _ password _ cb ▁( char ▁* buf , ▁int ▁size , ▁int ▁w flag , ▁void ▁* data ) ▁{ ▁/* ▁* ▁H ard ▁code ▁a ▁password ▁for ▁this ▁suite ▁*/ ▁strncpy ( buf , ▁key _ password , ▁size ); ▁return ( strnlen ( buf , ▁size ) ); ▁} ▁static ▁void ▁us 3612_ clean ▁( void ) ▁{ ▁} ▁static ▁int ▁us 3612_ start _ server ▁( int ▁manual _ enroll , ▁int ▁nid ) ▁{ ▁int ▁rv ; ▁rv ▁= ▁st _ start ( US 3612_ SERVER _ PORT , ▁US 3612_ SERVER _ CERTKEY , ▁US 3612_ SERVER _ CERTKEY , ▁" US 3612 ▁test ▁realm ", ▁US 3612_ CACERTS , ▁US 3612_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁manual _ enroll , ▁0, ▁nid ); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁initialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁allocate ▁data ▁or ▁open ▁any ▁* ▁resource s ▁required ▁for ▁all ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 3612_ init _ suite ▁( void ) ▁{ ▁int ▁rv ; ▁# if def ▁W IN 32 ▁Initialize CriticalSection ▁(& logger _ critical _ section ); ▁est _ init _ logger ( EST _ LOG _ L VL _ INFO , ▁& us 3612_ logger _ stderr ); ▁# endif ▁/* ▁* ▁Rea d ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( US 3612_ CACERTS , ▁& cacerts ); ▁if ▁( cacerts _ len ▁ < = ▁0) ▁{ ▁return ▁1; ▁} ▁us 3612_ clean (); ▁/* ▁* ▁Start ▁an ▁instance ▁of ▁the ▁EST ▁server ▁with ▁* ▁automatic ▁enrollment ▁enabled . ▁*/ ▁rv ▁= ▁us 3612_ start _ server ( 0 , ▁0); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁uninitialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁de allocate ▁data ▁or ▁close ▁any ▁* ▁resource s ▁that ▁we re ▁used ▁for ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 3612_ destroy _ suite ▁( void ) ▁{ ▁st _ stop (); ▁free ( cacerts ); ▁return ▁0; ▁} ▁/* ▁* ▁C allback ▁function ▁passed ▁to ▁est _ client _ init () ▁*/ ▁static ▁int ▁client _ manual _ cert _ verify ( X 509 ▁* cur _ cert , ▁int ▁openssl _ cert _ error ) ▁{ ▁BIO ▁* bio _ err ; ▁bio _ err = BIO _ new _ fp ( stderr , BIO _ NO CLOSE ); ▁int ▁approve ▁= ▁0; ▁/* ▁* ▁Pr int ▁out ▁the ▁specific s ▁of ▁this ▁cert ▁*/ ▁ printf ("% s : ▁OpenSSL / EST ▁server ▁cert ▁verification ▁failed ▁with ▁the ▁following ▁error : ▁openssl _ cert _ error ▁= ▁% d ▁(% s ) \ n ", ▁ _ _ FUNCTION _ _ , ▁openssl _ cert _ error , ▁X 509_ verify _ cert _ error _ string ( openssl _ cert _ error ) ); ▁ printf (" Fail ing ▁Cert : \ n "); ▁X 509_ print _ fp ( stdout , cur _ cert ); ▁/* ▁* ▁ Next ▁call ▁print s ▁out ▁the ▁signature ▁which ▁can ▁be ▁used ▁as ▁the ▁fingerprint ▁* ▁This ▁fingerprint ▁can ▁be ▁checked ▁against ▁the ▁anti cip ated ▁value ▁to ▁determine ▁* ▁whether ▁or ▁not ▁the ▁server ' s ▁cert ▁should ▁be ▁approved . ▁*/ ▁X 509_ signature _ print ( bio _ err , ▁cur _ cert -> sig _ alg , ▁cur _ cert -> signature ); ▁if ▁( openssl _ cert _ error ▁ == ▁X 509_ V _ ERR _ U NABLE _ TO _ GET _ CRL ) ▁{ ▁approve ▁= ▁1; ▁} ▁BIO _ free ( bio _ err ); ▁return ▁approve ; ▁} ▁/* ▁* ▁Simple ▁Enroll ▁b - ▁client ▁* ▁Load ▁in ▁a ▁password ▁pro r tected ▁private ▁key ▁with ▁* ▁the ▁correct ▁pass phrase ▁and ▁attempt ▁to ▁enroll ▁for ▁a ▁certificate ▁*/ ▁static ▁void ▁us 3612_ test 1 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 3612_ UID , ▁US 3612_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 3612_ SERVER _ IP , ▁US 3612_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Rea d ▁in ▁our ▁test ▁private ▁key ▁* ▁ generated ▁ via ▁the ▁command ▁below : ▁* ▁* ▁openssl ▁gen rsa ▁- aes 128 ▁- pass out ▁pass : us 3612 ▁- out ▁us 3612_ key . pem ▁4096 ▁*/ ▁key _ password ▁= ▁US 3612_ GOOD _ PWD ; ▁key ▁= ▁read _ protected _ private _ key ( US 3612_ PRIVATE _ KEY _ FILE , ▁string _ password _ cb ); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁" TC US 3612- 1", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁ Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁ == ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ectx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁CSR ▁* ▁* ▁Load ▁in ▁a ▁password ▁ protected ▁private ▁key ▁with ▁the ▁in correct ▁password ▁* ▁and ▁attempt ▁to ▁enroll ▁for ▁a ▁certificate . ▁This ▁will ▁fail . ▁*/ ▁static ▁void ▁us 3612_ test 2 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 3612_ UID , ▁US 3612_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 3612_ SERVER _ IP , ▁US 3612_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Rea d ▁in ▁our ▁test ▁private ▁key ▁* ▁ generated ▁ via ▁the ▁command ▁below : ▁* ▁* ▁openssl ▁gen rsa ▁- aes 128 ▁- pass out ▁pass : us 3612 ▁- out ▁us 3612_ key . pem ▁4096 ▁*/ ▁key _ password ▁= ▁US 3612_ BAD _ PWD ; ▁key ▁= ▁read _ protected _ private _ key ( US 3612_ PRIVATE _ KEY _ FILE , ▁string _ password _ cb ); ▁CU _ ASSERT ( key ▁ == ▁NULL ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁" TC 3612- 2 ", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ != ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁CSR ▁* ▁* ▁Change ▁the ▁password ▁used ▁by ▁the ▁callback ▁after ▁reading ▁* ▁in ▁the ▁ protected ▁private ▁key ▁file . ▁*/ ▁static ▁void ▁us 3612_ test 3 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 3612_ UID , ▁US 3612_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 3612_ SERVER _ IP , ▁US 3612_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Rea d ▁in ▁our ▁test ▁private ▁key ▁* ▁ generated ▁ via ▁the ▁command ▁below : ▁* ▁* ▁openssl ▁gen rsa ▁- aes 128 ▁- pass out ▁pass : us 3612 ▁- out ▁us 3612_ key . pem ▁4096 ▁*/ ▁key _ password ▁= ▁US 3612_ GOOD _ PWD ; ▁key ▁= ▁read _ protected _ private _ key ( US 3612_ PRIVATE _ KEY _ FILE , ▁string _ password _ cb ); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Change ▁out ▁the ▁password , ▁E VP _ PKEY ▁should ▁remain ▁una ff ected ▁*/ ▁key _ password ▁= ▁US 3612_ BAD _ PWD ; ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁" TC US 3612- 3 ", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁ Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁ == ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ectx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁Test ▁key ▁generation ▁utili ty ▁functions ▁* ▁and ▁a ssociat ed ▁password ▁callback s ▁*/ ▁static ▁void ▁us 3612_ test 4 ▁( void ) ▁{ ▁char ▁* ▁new _ pkey ▁= ▁NULL ; ▁/* ▁* ▁Generat e ▁an ▁RSA ▁key ▁without ▁a ▁password ▁*/ ▁new _ pkey ▁= ▁generate _ private _ RSA _ key ( RSA _ KEYSIZE , ▁NULL ); ▁CU _ ASSERT ( new _ pkey ▁ != ▁NULL ); ▁ printf (" \ n % s \ n ", ▁new _ pkey ); ▁free ( new _ pkey ); ▁new _ pkey ▁= ▁NULL ; ▁/* ▁* ▁Generat e ▁an ▁RSA ▁key ▁with ▁password ▁*/ ▁key _ password ▁= ▁US 3612_ GOOD _ PWD ; ▁new _ pkey ▁= ▁generate _ private _ RSA _ key ( RSA _ KEYSIZE , ▁string _ password _ cb ); ▁CU _ ASSERT ( new _ pkey ▁ != ▁NULL ); ▁ printf (" \ n % s \ n ", ▁new _ pkey ); ▁free ( new _ pkey ); ▁new _ pkey ▁= ▁NULL ; ▁/* ▁* ▁Generat e ▁an ▁EC ▁key ▁without ▁a ▁password ▁*/ ▁new _ pkey ▁= ▁generate _ private _ EC _ key ( OBJ _ s n 2 nid ( ( char ▁*) ▁" prime 256 v 1") , ▁NULL ); ▁CU _ ASSERT ( new _ pkey ▁ != ▁NULL ); ▁ printf (" \ n % s \ n ", ▁new _ pkey ); ▁free ( new _ pkey ); ▁new _ pkey ▁= ▁NULL ; ▁/* ▁* ▁Generat e ▁an ▁EC ▁key ▁with ▁a ▁password ▁*/ ▁new _ pkey ▁= ▁generate _ private _ EC _ key ( OBJ _ s n 2 nid ( ( char ▁*) ▁" prime 256 v 1") , ▁string _ password _ cb ); ▁CU _ ASSERT ( new _ pkey ▁ != ▁NULL ); ▁ printf (" \ n % s \ n ", ▁new _ pkey ); ▁free ( new _ pkey ); ▁new _ pkey ▁= ▁NULL ; ▁} ▁int ▁us 3612_ add _ suite ▁( void ) ▁{ ▁# if def ▁HA VE _ C UNIT ▁CU _ pSuite ▁pSuite ▁= ▁NULL ; ▁/* ▁add ▁a ▁suite ▁to ▁the ▁ registry ▁*/ ▁pSuite ▁= ▁CU _ add _ suite (" us 3612_ encrypted _ private _ key s ", ▁us 3612_ init _ suite , ▁us 3612_ destroy _ suite ); ▁if ▁( NULL ▁ == ▁pSuite ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁/* ▁* ▁Add ▁the ▁tests ▁to ▁the ▁suite ▁*/ ▁if ▁( ( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Client ▁simple ▁enroll ▁w / ▁correct ▁pwd ", ▁us 3612_ test 1)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Client ▁simple ▁enroll ▁w / ▁in correct ▁pwd ", ▁us 3612_ test 2)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Client ▁simple ▁enroll ▁w / ▁in correct ▁pwd ", ▁us 3612_ test 3)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Key gen ▁Test ", ▁us 3612_ test 4)) ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁return ▁CU E _ SUCCESS ; ▁# endif ▁}