▁/* -- ---------------- ---------------- ---------------- ---------------- ▁* ▁us 900 . c ▁- ▁ Unit ▁Test s ▁for ▁User ▁Stor y ▁ 900 ▁- ▁Server ▁CSR ▁Attributes ▁* ▁* ▁November , ▁2013 ▁* ▁* ▁Copy right ▁( c ) ▁2013 , ▁2016 ▁by ▁ cisco ▁S ystems , ▁Inc . ▁* ▁All ▁ right s ▁ reserved . ▁* -- ---------------- ---------------- ---------------- ---------------- ▁*/ ▁# include ▁ < std io . h > ▁# if n def ▁W IN 32 ▁# include ▁ < uni std . h > ▁# endif ▁# include ▁ < est . h > ▁# include ▁ < curl / curl . h > ▁# include ▁" curl _ util s . h " ▁# include ▁" test _ util s . h " ▁# include ▁" st _ server . h " ▁# include ▁ < openssl / ssl . h > ▁# if def ▁HA VE _ C UNIT ▁# include ▁" CUnit / Basic . h " ▁# include ▁" CUnit / A utomat ed . h " ▁# endif ▁# define ▁US 900_ SERVER _ PORT ▁2990 0 ▁# define ▁US 900_ SERVER _ IP ▁"127.0.0.1" ▁# if n def ▁W IN 32 ▁# define ▁CLIENT _ UT _ CACERT ▁" CA / estCA / cacert . crt " ▁# define ▁CLIENT _ UT _ PUBKEY ▁" . / est _ client _ ut _ keypair " ▁# define ▁US 900_ CACERTS ▁" CA / estCA / cacert . crt " ▁# define ▁US 900_ TRUST _ CERTS ▁" CA / trustedcerts . crt " ▁# define ▁US 900_ SERVER _ CERTKEY ▁" CA / estCA / private / estserver cert and key . pem " ▁# else ▁# define ▁CLIENT _ UT _ CACERT ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁CLIENT _ UT _ PUBKEY ▁" est _ client _ ut _ keypair " ▁# define ▁US 900_ CACERTS ▁" CA \\ estCA / cacert . crt " ▁# define ▁US 900_ TRUST _ CERTS ▁" CA \\ trustedcerts . crt " ▁# define ▁US 900_ SERVER _ CERTKEY ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# endif ▁# define ▁TEST _ ATTR _ POP ▁" MA s GCS qGS Ib 3 DQEJBw == \0" ▁# define ▁TEST _ ATTR _ NOPOP ▁" MHE w LA YDiDcCMS UGA 4 g 3 AwYDiDcEE xlQ YXJ z ZSB T RV QgY XMg Mi 45 OTkuMiBkYXRhBg lg hk g BZQ MEA g IGCSskAwMCCAEBCz Ai BgOINwEx G xM ZU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 Lj EgZG F 0 YQYHKwYBAQEBFg == \0" ▁# define ▁TEST _ ATTR _ NOPOPPOP ▁" MHw w LA YDiDcCMS UGA 4 g 3 AwYDiDcEE xlQ YXJ z ZSB T RV QgY XMg Mi 45 OTkuMiBkYXRhBg lg hk g BZQ MEA g IGCSskAwMCCAEBCz Ai BgOINwEx G xM ZU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 Lj EgZG F 0 YQYHKwYBAQEBFg YJKoZIhvcNAQk H \0" ▁# define ▁TEST _ ATTR _ POP AD DED ▁" MHw w LA YDiDcCMS UGA 4 g 3 AwYDiDcEE xlQ YXJ z ZSB T RV QgY XMg Mi 45 OTkuMiBkYXRhBg lg hk g BZQ MEA g IGCSskAwMCCAEBCz Ai BgOINwEx G xM ZU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 Lj EgZG F 0 YQYHKwYBAQEBFg YJKoZIhvcNAQk H \0" ▁# define ▁TEST _ ATTR 1 ▁" MC YGBysGAQEBARY GCS qGS Ib 3 DQEJBw Y FK 4 E EAC IGCWCGSAFlAwQCAg == \0" ▁# define ▁TEST _ ATTR 2 ▁" MA A = \0" ▁# define ▁TEST _ ATTR 7 ▁" MA == \0" ▁# define ▁TEST _ ATTR 2 _ POP ▁" MA s GCS qGS Ib 3 DQEJBw == \0" ▁# define ▁TEST _ ATTR 8 ▁" MA this is ▁bad s GCS qGS Ib 3 DQEJBw == \0" ▁# define ▁TEST _ ATTR 3 ▁" MIG SMF g GA 4 g 3 AjF RE xlQ YXJ z ZSB T RV QgY XMg Mi 45 OTkuMiBkYXRh E xlQ YXJ z ZSB T RV QgY XMg Mi 45 OTkuM y BkYXRh E xlQ YXJ z ZSB T RV QgY XMg Mi 45 OTku NC BkYXRhBg kqh k iG 9 w 0 BCQc wI g YDiDcBMR sT GV Bhc nNl IF NF VC Bhc yA yL jk 5 OS 4 xIGRhdGE GBysGAQEBARY = \0" ▁# define ▁TEST _ ATTR 4_122 ▁" MH ow LA YDiDcCMS UGA 4 g 3 AwYDiDcEE xlQ YXJ z ZSB T RV QgY XMg Mi 45 OTkuMiBkYXRhBg lg hk g BZQ MEA g IGCSskAwMCCAEBCz Ai BgOINwEx G xM ZU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 Lj EgZG F 0 YQYHKwYBAQEBFg YHKwYBAQEBFg == \0" ▁# define ▁TEST _ ATTR 4_122 POP ▁" MIG FM C wGA 4 g 3 AjE lBgOINw MGA 4 g 3 BBM ZU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 LjIg ZG F 0 YQ YJYIZIAWUDBAIC BgkrJAMDAggBAQsw Ig YDiDcBMR sT GV Bhc nNl IF NF VC Bhc yA yL jk 5 OS 4 xIGRhdGE GBysGAQEBARY GBysGAQEBARY GCS qGS Ib 3 DQEJBw == \0" ▁# define ▁TEST _ ATTR 5_117 ▁" MH Uw Jw YDiDcCMS AGA 4 g 3 AwYDiDcEE xRQ YXJ z ZSB T RV QgY XMg Mi 45 OTkuM g YJYIZIAWUDBAIC BgkrJAMDAggBAQsw Ig YDiDcBMR sT GV Bhc nNl IF NF VC Bhc yA yL jk 5 OS 4 xIGRhdGE GBysGAQEBARY GBysGAQEBARY = \0" ▁# define ▁TEST _ ATTR 5_117 POP ▁" MIG AMC cGA 4 g 3 AjE g BgOINw MGA 4 g 3 BBM UU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 Lj IGCWCGSAFlAwQCAg YJKyQDAwIIAQELM CI GA 4 g 3 ATE bE xlQ YXJ z ZSB T RV QgY XMg Mi 45 OTkuMSBkYXRh BgcrBgEBAQEW BgcrBgEBAQEWBg kqh k iG 9 w 0 BCQc = \0" ▁# define ▁TEST _ ATTR 6_116 ▁" MH Qw Jw YDiDcCMS AGA 4 g 3 AwYDiDcEE xRQ YXJ z ZSB T RV QgY XMg Mi 45 OTkuM g YJYIZIAWUDBAIC BgkrJAMDAggBAQsw IQ YDiDcBMR o T GF Bhc nNl IF NF VC Bhc yA yL jk 5 OS 4 xIGRhd A YHKwYBAQEBFg YHKwYBAQEBFg == \0" ▁# define ▁TEST _ ATTR _244 ▁" MIH 1 MG Q GA 4 g 3 AjF d BgOINw MGA 4 g 3 B BN RU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 LjIg MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw Bg lg hk g BZQ ME AgI GCSskAwMCCAEBCzB l BgOINwExX hN cU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 Lj EgZG F 0 YS AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT Bh Yj EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ GBysGAQEBARY GBysGAQEBARY = \0" ▁# define ▁TEST _ ATTR _245 ▁" MIH 2 MG Q GA 4 g 3 AjF d BgOINw MGA 4 g 3 B BN RU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 LjIg MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw Bg lg hk g BZQ ME AgI GCSskAwMCCAEBCzB m BgOINwExX x N dU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 Lj EgZG F 0 YS AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT Bh Yj EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 BgcrBgEBAQEW BgcrBgEBAQEW \0" ▁# define ▁TEST _ ATTR _250 ▁" MIH 7 MG Q GA 4 g 3 AjF d BgOINw MGA 4 g 3 B BN RU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 LjIg MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw Bg lg hk g BZQ MEA g IGCSskAwMCCAEBCz Br BgOINwEx Z BN iU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 Lj EgZG F 0 YS AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT Bh Yj EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 MTIzNDU GBysGAQEBARY GBysGAQEBARY = \0" ▁# define ▁TEST _ ATTR _250 POP ▁" MIIB Bj Bk BgOINwIx X QYDiDcDBgOINwQT UV Bhc nNl IF NF VC Bhc yA yL jk 5 OS 4 yI DEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MA YJYIZIAWUDBAIC BgkrJAMDAggBAQsw aw YDiDcBM WQ TY l Bhc nNl IF NF VC Bhc yA yL jk 5 OS 4 xIGRhdGE g MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw YWI xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 NT EyMzQ 1 BgcrBgEBAQEW BgcrBgEBAQEWBg kqh k iG 9 w 0 BCQc = \0" ▁# define ▁TEST _ ALL _ ATTR ▁" MIH T MIG B BgOINwIx e gEB / wI CA P 8 GA 4 g 3 AwYDiDcE C gE CE h AxM jM 0 N TY 3 ODkw QU JD REV GE xRQ YXJ z ZSB T RV QgY XMg Mi 45 OTkuMhQFM TIzNDU UB T EyMzQ 1 F gU xM jM 0 NR o FMTIzNDU cF AAAA DE AAAA y AAAA Mw AAAD Q AAAA 1 Hg oAM QA yA DM ANA A 1 Bg lg hk g BZQ MEA g IGCSskAwMCCAEBCz Ai BgOINwEx G xM ZU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 Lj EgZG F 0 YQYHKwYBAQEBFg YHKwYBAQEBFg EBAA == \0" ▁# define ▁TEST _1024_ NOPOP ▁" MIID / DCCA 2 MGA 4 g 3 AjGCA 1 oGA 4 g 3 AwYDiDcEEi o xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTI S ZT EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MD AxM jM 0 N TY 3 ODkwE mU xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OTA wMTIzNDU 2 N zg 5 MB Jl MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw MDEyMzQ 1 Nj c 4 OTA S ZT EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MD AxM jM 0 N TY 3 ODkwE mU xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OTA wMTIzNDU 2 N zg 5 MB Jl MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw MDEyMzQ 1 Nj c 4 OTA S ZT EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MD AxM jM 0 N TY 3 ODkwE 1 FQ YXJ z ZSB T RV QgY XMg Mi 45 OTkuMi AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OTA GCWCGSAFlAwQCAg YJKyQDAwIIAQELM G sGA 4 g 3 AT Fk E 2 JQY X Jz ZSB T RV QgY XMg Mi 45 OTkuMSBkYXRh ID EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MG Fi MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU xM jM 0 N QYHKwYBAQEBFg YHKwYBAQEBFg == \0" ▁# define ▁TEST _102 5 _ NOPOP ▁" MIID / TCCA 2 Q GA 4 g 3 AjGCA 1 sGA 4 g 3 AwYDiDcEEi s xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIz E mU xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OTA wMTIzNDU 2 N zg 5 MB Jl MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw MDEyMzQ 1 Nj c 4 OTA S ZT EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MD AxM jM 0 N TY 3 ODkwE mU xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OTA wMTIzNDU 2 N zg 5 MB Jl MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw MDEyMzQ 1 Nj c 4 OTA S ZT EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MD AxM jM 0 N TY 3 ODkwE mU xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OTA wMTIzNDU 2 N zg 5 MB N RU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 LjIg MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw Bg lg hk g BZQ MEA g IGCSskAwMCCAEBCz Br BgOINwEx Z BN iU GFy c 2 U gU 0 VU IG FzI DI u OTk 5 Lj EgZG F 0 YS AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT Bh Yj EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 MTIzNDU GBysGAQEBARY GBysGAQEBARY = \0" ▁# define ▁TEST _1024_ POP ▁" MIIE BzCCA 2 MGA 4 g 3 AjGCA 1 oGA 4 g 3 AwYDiDcEEi o xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTI S ZT EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MD AxM jM 0 N TY 3 ODkwE mU xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OTA wMTIzNDU 2 N zg 5 MB Jl MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw MDEyMzQ 1 Nj c 4 OTA S ZT EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MD AxM jM 0 N TY 3 ODkwE mU xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OTA wMTIzNDU 2 N zg 5 MB Jl MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw MDEyMzQ 1 Nj c 4 OTA S ZT EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MD AxM jM 0 N TY 3 ODkwE 1 FQ YXJ z ZSB T RV QgY XMg Mi 45 OTkuMi AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OTA GCWCGSAFlAwQCAg YJKyQDAwIIAQELM G sGA 4 g 3 AT Fk E 2 JQY X Jz ZSB T RV QgY XMg Mi 45 OTkuMSBkYXRh ID EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MG Fi MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU xM jM 0 N QYHKwYBAQEBFg YHKwYBAQEBFg YJKoZIhvcNAQk H \0" ▁# define ▁TEST _ LONG _ ATTR ▁" MIIE N zCCA 5 4 GA 4 g 3 AjGCA 5 UGA 4 g 3 AwYDiDcEE mU xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OTA wMTIzNDU 2 N zg 5 MB Jl MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw MDEyMzQ 1 Nj c 4 OTA S ZT EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MD AxM jM 0 N TY 3 ODkwE mU xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OTA wMTIzNDU 2 N zg 5 MB Jl MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw MDEyMzQ 1 Nj c 4 OTA S ZT EyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MD AxM jM 0 N TY 3 ODkwE mU xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OTA wMTIzNDU 2 N zg 5 MB Jl MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw MDEyMzQ 1 Nj c 4 OTA TUV Bhc nNl IF NF VC Bhc yA yL jk 5 OS 4 yI DEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MA YJYIZIAWUDBAIC BgkrJAMDAggBAQsw aw YDiDcBM WQ TY l Bhc nNl IF NF VC Bhc yA yL jk 5 OS 4 xIGRhdGE g MTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 N TY 3 ODkw YWI xM jM 0 N TY 3 ODkwMTIzNDU 2 N zg 5 MDEyMzQ 1 Nj c 4 OT AxM jM 0 NT EyMzQ 1 BgcrBgEBAQEW BgcrBgEBAQEW \0" ▁# define ▁EST _ UT _ MAX _ CMD _ LEN ▁255 ▁extern ▁EST _ CTX ▁* ectx ; ▁static ▁void ▁us 900_ clean ▁( void ) ▁{ ▁} ▁static ▁int ▁us 900_ start _ server ▁( int ▁manual _ enroll , ▁int ▁nid ) ▁{ ▁int ▁rv ; ▁rv ▁= ▁st _ start ( US 900_ SERVER _ PORT , ▁US 900_ SERVER _ CERTKEY , ▁US 900_ SERVER _ CERTKEY , ▁" US 900 ▁test ▁realm ", ▁US 900_ CACERTS , ▁US 900_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁manual _ enroll , ▁0, ▁nid ); ▁SL EEP (1); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁initialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁allocate ▁data ▁or ▁open ▁any ▁* ▁resource s ▁required ▁for ▁all ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 900_ init _ suite ▁( void ) ▁{ ▁int ▁rv ▁= ▁0; ▁char ▁cmd [ EST _ UT _ MAX _ CMD _ LEN ]; ▁ printf (" Start ing ▁EST ▁Server ▁CSR ▁attributes ▁ unit ▁tests . \ n "); ▁/* ▁* ▁gen ▁the ▁ keypair ▁to ▁be ▁used ▁for ▁EST ▁Client ▁testing ▁*/ ▁ snprintf ( ▁cmd , ▁EST _ UT _ MAX _ CMD _ LEN , ▁" openssl ▁ec param ▁- name ▁prime 256 v 1 ▁- gen key ▁- out ▁% s ", ▁CLIENT _ UT _ PUBKEY ); ▁ printf ("% s \ n ", ▁cmd ); ▁rv ▁= ▁system ( cmd ); ▁/* ▁* ▁start ▁the ▁server ▁for ▁the ▁tests ▁that ▁need ▁to ▁t alk ▁to ▁a ▁server ▁*/ ▁us 900_ clean (); ▁/* ▁* ▁Start ▁an ▁instance ▁of ▁the ▁EST ▁server ▁*/ ▁rv ▁= ▁us 900_ start _ server ( 0 , ▁0); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁uninitialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁de allocate ▁data ▁or ▁close ▁any ▁* ▁resource s ▁that ▁we re ▁used ▁for ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 900_ destroy _ suite ▁( void ) ▁{ ▁st _ stop (); ▁SL EEP ( 2 ); ▁return ▁0; ▁} ▁static ▁un signed ▁char ▁* ▁handle _ correct _ csrattrs _ request ▁( int ▁* csr _ len , ▁char ▁* path _ seg , ▁void ▁* app _ data ) ▁{ ▁un signed ▁char ▁* csr _ data ; ▁* csr _ len ▁= ▁str len ( TEST _ ATTR 1); ▁csr _ data ▁= ▁malloc (* csr _ len ▁+ ▁1); ▁strncpy ( ( char ▁*) ▁csr _ data , ▁TEST _ ATTR 1, ▁* csr _ len ); ▁csr _ data [ * csr _ len ] ▁= ▁0; ▁return ▁( csr _ data ); ▁} ▁static ▁un signed ▁char ▁* ▁handle _ corrupt _ csrattrs _ request ▁( int ▁* csr _ len , ▁char ▁* path _ seg , ▁void ▁* app _ data ) ▁{ ▁un signed ▁char ▁* csr _ data ; ▁* csr _ len ▁= ▁str len ( TEST _ ATTR 8 ); ▁csr _ data ▁= ▁malloc (* csr _ len ▁+ ▁1); ▁strncpy ( ( char ▁*) ▁csr _ data , ▁TEST _ ATTR 8 , ▁* csr _ len ); ▁csr _ data [ * csr _ len ] ▁= ▁0; ▁return ▁( csr _ data ); ▁} ▁static ▁un signed ▁char ▁* ▁handle _ short _ csrattrs _ request ▁( int ▁* csr _ len , ▁char ▁* path _ seg , ▁void ▁* app _ data ) ▁{ ▁un signed ▁char ▁* csr _ data ; ▁* csr _ len ▁= ▁str len ( TEST _ ATTR 7 ); ▁csr _ data ▁= ▁malloc (* csr _ len ▁+ ▁1); ▁strncpy ( ( char ▁*) ▁csr _ data , ▁TEST _ ATTR 7, ▁* csr _ len ); ▁csr _ data [ * csr _ len ] ▁= ▁0; ▁return ▁( csr _ data ); ▁} ▁static ▁un signed ▁char ▁* ▁handle _ long _ csrattrs _ request ▁( int ▁* csr _ len , ▁char ▁* path _ seg , ▁void ▁* app _ data ) ▁{ ▁un signed ▁char ▁* csr _ data ; ▁* csr _ len ▁= ▁str len ( TEST _ LONG _ ATTR ); ▁csr _ data ▁= ▁malloc (* csr _ len ▁+ ▁1); ▁strncpy ( ( char ▁*) ▁csr _ data , ▁TEST _ LONG _ ATTR , ▁* csr _ len ); ▁csr _ data [ * csr _ len ] ▁= ▁0; ▁return ▁( csr _ data ); ▁} ▁static ▁un signed ▁char ▁* ▁handle _ no pop _ csrattrs _ request ▁( int ▁* csr _ len , ▁char ▁* path _ seg , ▁void ▁* app _ data ) ▁{ ▁un signed ▁char ▁* csr _ data ; ▁* csr _ len ▁= ▁str len ( TEST _ ATTR _ NOPOP ); ▁csr _ data ▁= ▁malloc (* csr _ len ▁+ ▁1); ▁strncpy ( ( char ▁*) ▁csr _ data , ▁TEST _ ATTR _ NOPOP , ▁* csr _ len ); ▁csr _ data [ * csr _ len ] ▁= ▁0; ▁return ▁( csr _ data ); ▁} ▁static ▁un signed ▁char ▁* ▁handle _ empty _ csrattrs _ request ▁( int ▁* csr _ len , ▁char ▁* path _ seg , ▁void ▁* app _ data ) ▁{ ▁un signed ▁char ▁* csr _ data ; ▁* csr _ len ▁= ▁0; ▁csr _ data ▁= ▁NULL ; ▁return ▁( csr _ data ); ▁} ▁/* ▁* ▁C allback ▁function ▁passed ▁to ▁est _ client _ init () ▁*/ ▁static ▁int ▁client _ manual _ cert _ verify ▁( X 509 ▁* cur _ cert , ▁int ▁openssl _ cert _ error ) ▁{ ▁BIO ▁* ▁bio _ err ; ▁bio _ err ▁= ▁BIO _ new _ fp ( stderr , ▁BIO _ NO CLOSE ); ▁int ▁approve ▁= ▁0; ▁/* ▁* ▁Pr int ▁out ▁the ▁specific s ▁of ▁this ▁cert ▁*/ ▁ printf ( ▁"% s : ▁OpenSSL / EST ▁server ▁cert ▁verification ▁failed ▁with ▁the ▁following ▁error : ▁openssl _ cert _ error ▁= ▁% d ▁(% s ) \ n ", ▁ _ _ FUNCTION _ _ , ▁openssl _ cert _ error , ▁X 509_ verify _ cert _ error _ string ( openssl _ cert _ error ) ); ▁ printf (" Fail ing ▁Cert : \ n "); ▁X 509_ print _ fp ( stdout , ▁cur _ cert ); ▁/* ▁* ▁ Next ▁call ▁print s ▁out ▁the ▁signature ▁which ▁can ▁be ▁used ▁as ▁the ▁fingerprint ▁* ▁This ▁fingerprint ▁can ▁be ▁checked ▁against ▁the ▁anti cip ated ▁value ▁to ▁determine ▁* ▁whether ▁or ▁not ▁the ▁server ' s ▁cert ▁should ▁be ▁approved . ▁*/ ▁X 509_ signature _ print ( bio _ err , ▁cur _ cert -> sig _ alg , ▁cur _ cert -> signature ); ▁if ▁( openssl _ cert _ error ▁ == ▁X 509_ V _ ERR _ U NABLE _ TO _ GET _ CRL ) ▁{ ▁approve ▁= ▁1; ▁} ▁BIO _ free ( bio _ err ); ▁return ▁approve ; ▁} ▁/* ▁* ▁Test 1 ▁- ▁ex erc ise ▁the ▁est _ server _ init _ csrattrs () ▁API . ▁*/ ▁static ▁void ▁us 900_ test 1 ▁( void ) ▁{ ▁int ▁rc ; ▁ LOG _ FUNC _ NM ▁; ▁/* ▁NULL ▁ctx ▁- ▁should ▁fail ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( NULL , ▁" US 900 ▁test 1", ▁10); ▁CU _ ASSERT ( rc ▁ != ▁EST _ ERR _ NONE ); ▁/* ▁NULL ▁string ▁- ▁should ▁pass ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁NULL , ▁10); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁ Z ero ▁length ▁- ▁should ▁fail ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁" US 900 ▁test 1", ▁0); ▁CU _ ASSERT ( rc ▁ != ▁EST _ ERR _ NONE ); ▁/* ▁Length ▁too ▁long ▁- ▁should ▁fail ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁" US 900 ▁test 1", ▁ MAX _ CSRATTRS ▁+ ▁1); ▁CU _ ASSERT ( rc ▁ != ▁EST _ ERR _ NONE ); ▁/* ▁Not ▁a ▁real ▁base 64 ▁string ▁- ▁should ▁fail ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁" US 900 ▁test 1", ▁11 ); ▁CU _ ASSERT ( rc ▁ != ▁EST _ ERR _ NONE ); ▁/* ▁Real ▁base 64 ▁string ▁- ▁should ▁pass ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR _ POP , ▁str len ( TEST _ ATTR _ POP ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁Set ting ▁the ▁small est ▁base 64 ▁size ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR 2 , ▁str len ( TEST _ ATTR 2)) ; ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁Set ting ▁an ▁illegal ly ▁small ▁base 64 ▁size ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR 7, ▁str len ( TEST _ ATTR 7)) ; ▁CU _ ASSERT ( rc ▁ != ▁EST _ ERR _ NONE ); ▁/* ▁Set ting ▁the ▁size ▁ 122 ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR 4_122 , ▁str len ( TEST _ ATTR 4_122 ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁Set ting ▁the ▁size ▁ 117 ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR 5_117 , ▁str len ( TEST _ ATTR 5_117 ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁enable ▁PoP ▁*/ ▁st _ enable _ pop (); ▁/* ▁Real ▁base 64 ▁string ▁needs ▁PoP ▁add ed ▁- ▁should ▁pass ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ▁ectx , ▁TEST _ ATTR _ NOPOP , ▁str len ( TEST _ ATTR _ NOPOP ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁Not ▁a ▁real ▁base 64 ▁string ▁- ▁should ▁fail ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁" US 900 ▁test 1", ▁11 ); ▁CU _ ASSERT ( rc ▁ != ▁EST _ ERR _ NONE ); ▁/* ▁Set ting ▁the ▁small est ▁size ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR 2 , ▁str len ( TEST _ ATTR 2)) ; ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁Set ting ▁the ▁size ▁ 122 ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR 4_122 , ▁str len ( TEST _ ATTR 4_122 ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁Set ting ▁the ▁size ▁ 117 ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR 5_117 , ▁str len ( TEST _ ATTR 5_117 ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁Set ting ▁the ▁size ▁ 116 ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR 6_116 , ▁str len ( TEST _ ATTR 6_116 ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁Set ting ▁the ▁size ▁ 244 ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR _244 , ▁str len ( TEST _ ATTR _244 ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁Set ting ▁the ▁size ▁ 245 ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR _245 , ▁str len ( TEST _ ATTR _245 ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁Set ting ▁the ▁size ▁ 250 ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR _250 , ▁str len ( TEST _ ATTR _250 ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁All ▁ASN .1 ▁types ▁supported ▁by ▁Cisco SSL ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ALL _ ATTR , ▁str len ( TEST _ ALL _ ATTR ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁disable ▁PoP ▁*/ ▁st _ disable _ pop (); ▁/* ▁All ▁ASN .1 ▁types ▁supported ▁by ▁Cisco SSL ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ALL _ ATTR , ▁str len ( TEST _ ALL _ ATTR ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁Real ▁base 64 ▁string ▁PoP ▁should ▁not ▁be ▁add ed ▁- ▁should ▁pass ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ▁ectx , ▁TEST _ ATTR _ NOPOP , ▁str len ( TEST _ ATTR _ NOPOP ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Test 2 ▁- ▁ex erc ise ▁the ▁server ▁side ▁variations ▁tri gger ed ▁* ▁by ▁est _ client _ get _ csrattrs () ▁*/ ▁static ▁void ▁us 900_ test 2 ▁( void ) ▁{ ▁EST _ CTX ▁* ctx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁un signed ▁char ▁* retrieved _ cacerts ▁= ▁NULL ; ▁int ▁retrieved _ cacerts _ len ▁= ▁0; ▁E VP _ PKEY ▁* ▁priv _ key ; ▁int ▁csr _ len ; ▁un signed ▁char ▁* csr _ data ▁= ▁NULL ; ▁SL EEP (1); ▁ LOG _ FUNC _ NM ▁; ▁/* ▁* ▁Rea d ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁Rea d ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁ == ▁NULL ) ▁{ ▁ printf (" \ n Error ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ctx ▁= ▁est _ client _ init ( ▁cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ctx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁est _ client _ set _ server ( ctx , ▁US 900_ SERVER _ IP , ▁US 900_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁issue ▁the ▁get ▁ca ▁certs ▁request ▁*/ ▁rc ▁= ▁est _ client _ get _ cacerts ( ctx , ▁& retrieved _ cacerts _ len ); ▁/* ▁* ▁should ▁be ▁successful , ▁and ▁should ▁have ▁obtained ▁a ▁valid ▁buffer ▁* ▁containing ▁the ▁CA ▁certs ▁*/ ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( retrieved _ cacerts _ len ▁> ▁0); ▁retrieved _ cacerts ▁= ▁malloc ( retrieved _ cacerts _ len ); ▁rc ▁= ▁est _ client _ copy _ cacerts ( ctx , ▁retrieved _ cacerts ); ▁/* ▁* ▁output ▁the ▁retrieved ▁ca ▁certs ▁and ▁compare ▁to ▁what ▁they ▁should ▁be ▁*/ ▁if ▁( retrieved _ cacerts ) ▁{ ▁ printf (" \ nR etrieved ▁CA ▁Certs ▁buffer : \ n ▁% s \ n ", ▁retrieved _ cacerts ); ▁ printf (" Retrieve d ▁CA ▁certs ▁buffer ▁length : ▁% d \ n ", ▁retrieved _ cacerts _ len ); ▁} ▁free ( retrieved _ cacerts ); ▁/* ▁clear ▁callback ▁*/ ▁if ▁( est _ set _ csr _ cb ( ectx , ▁NULL )) ▁{ ▁ printf (" \ nU nable ▁to ▁set ▁EST ▁CSR ▁Attributes ▁callback . ▁A bort ing !!! \ n "); ▁exit (1); ▁} ▁/* ▁clear ▁csrattrs ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁NULL , ▁0); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁should ▁get ▁204 ▁with ▁no ▁data ▁*/ ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁0); ▁CU _ ASSERT ( csr _ data ▁ == ▁NULL ); ▁/* ▁Real ▁base 64 ▁string ▁- ▁should ▁pass ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR _ POP , ▁str len ( TEST _ ATTR _ POP ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR _ POP ) ); ▁CU _ ASSERT ( strnc mp ( TEST _ ATTR _ POP , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁if ▁( est _ set _ csr _ cb ( ectx , ▁& handle _ corrupt _ csrattrs _ request )) ▁{ ▁ printf (" \ nU nable ▁to ▁set ▁EST ▁CSR ▁Attributes ▁callback . ▁A bort ing !!! \ n "); ▁exit (1); ▁} ▁/* ▁callback ▁should ▁sup ersed e ▁init ▁csrattrs ▁*/ ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁0); ▁if ▁( est _ set _ csr _ cb ( ectx , ▁& handle _ short _ csrattrs _ request )) ▁{ ▁ printf (" \ nU nable ▁to ▁set ▁EST ▁CSR ▁Attributes ▁callback . ▁A bort ing !!! \ n "); ▁exit (1); ▁} ▁/* ▁callback ▁should ▁sup ersed e ▁init ▁csrattrs ▁*/ ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁0); ▁if ▁( est _ set _ csr _ cb ( ectx , ▁& handle _ long _ csrattrs _ request )) ▁{ ▁ printf (" \ nU nable ▁to ▁set ▁EST ▁CSR ▁Attributes ▁callback . ▁A bort ing !!! \ n "); ▁exit (1); ▁} ▁/* ▁callback ▁should ▁sup ersed e ▁init ▁csrattrs ▁*/ ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁0); ▁if ▁( est _ set _ csr _ cb ( ectx , ▁& handle _ correct _ csrattrs _ request )) ▁{ ▁ printf (" \ nU nable ▁to ▁set ▁EST ▁CSR ▁Attributes ▁callback . ▁A bort ing !!! \ n "); ▁exit (1); ▁} ▁/* ▁callback ▁should ▁sup ersed e ▁init ▁csrattrs ▁*/ ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR 1)) ; ▁CU _ ASSERT ( strnc mp ( TEST _ ATTR 1, ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁/* ▁clear ▁csrattrs ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁NULL , ▁0); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR 1)) ; ▁CU _ ASSERT ( strnc mp ( TEST _ ATTR 1, ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁/* ▁clear ▁callback ▁*/ ▁if ▁( est _ set _ csr _ cb ( ectx , ▁NULL )) ▁{ ▁ printf (" \ nU nable ▁to ▁set ▁EST ▁CSR ▁Attributes ▁callback . ▁A bort ing !!! \ n "); ▁exit (1); ▁} ▁/* ▁Set ting ▁the ▁small est ▁size ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR 2 , ▁str len ( TEST _ ATTR 2)) ; ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR 2)) ; ▁CU _ ASSERT ( strnc mp ( TEST _ ATTR 2 , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR 3 , ▁str len ( TEST _ ATTR 3)) ; ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR 3)) ; ▁CU _ ASSERT ( strnc mp ( TEST _ ATTR 3 , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁/* ▁clear ▁csrattrs ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁NULL , ▁0); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁0); ▁rc ▁= ▁est _ server _ init _ csrattrs ( ▁ectx , ▁TEST _1024_ NOPOP , ▁str len ( TEST _1024_ NOPOP ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _1024_ NOPOP ) ); ▁CU _ ASSERT ( strnc mp ( TEST _1024_ NOPOP , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁/* ▁E nable ▁PoP ▁and ▁test ▁responses ▁with ▁PoP ▁add ed ▁*/ ▁st _ enable _ pop (); ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR _ POP , ▁str len ( TEST _ ATTR _ POP ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ data ▁ != ▁NULL ); ▁CU _ ASSERT ( csr _ len ▁= ▁20 ); ▁CU _ ASSERT ( strnc mp ( TEST _ ATTR _ POP , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁rc ▁= ▁est _ server _ init _ csrattrs ( ▁ectx , ▁TEST _1024_ NOPOP , ▁str len ( TEST _1024_ NOPOP ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _1024_ POP ) ); ▁CU _ ASSERT ( strnc mp ( TEST _1024_ POP , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁/* ▁Set ting ▁the ▁size ▁ 122 ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR 4_122 , ▁str len ( TEST _ ATTR 4_122 ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR 4_122 POP ) ); ▁CU _ ASSERT ( ▁strnc mp ( TEST _ ATTR 4_122 POP , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁/* ▁Set ting ▁the ▁size ▁ 117 ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR 5_117 , ▁str len ( TEST _ ATTR 5_117 ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR 5_117 POP ) ); ▁CU _ ASSERT ( ▁strnc mp ( TEST _ ATTR 5_117 POP , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁/* ▁Real ▁base 64 ▁string ▁needs ▁PoP ▁add ed ▁- ▁should ▁pass ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ▁ectx , ▁TEST _ ATTR _ NOPOP , ▁str len ( TEST _ ATTR _ NOPOP ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR _ NOPOPPOP ) ); ▁CU _ ASSERT ( ▁strnc mp ( TEST _ ATTR _ NOPOPPOP , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁/* ▁Not ▁a ▁real ▁base 64 ▁string ▁- ▁should ▁fail ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁" US 900 ▁test 1", ▁11 ); ▁CU _ ASSERT ( rc ▁ != ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR _ POP ) ); ▁CU _ ASSERT ( strnc mp ( TEST _ ATTR _ POP , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁/* ▁Set ting ▁the ▁small est ▁size ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR 2 , ▁str len ( TEST _ ATTR 2)) ; ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR 2 _ POP ) ); ▁CU _ ASSERT ( strnc mp ( TEST _ ATTR 2 _ POP , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁/* ▁Set ting ▁the ▁size ▁ 116 ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR 6_116 , ▁str len ( TEST _ ATTR 6_116 ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁Set ting ▁the ▁size ▁ 244 ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR _244 , ▁str len ( TEST _ ATTR _244 ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁Set ting ▁the ▁size ▁ 245 ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR _245 , ▁str len ( TEST _ ATTR _245 ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁Set ting ▁the ▁size ▁ 250 ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ATTR _250 , ▁str len ( TEST _ ATTR _250 ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR _250 POP ) ); ▁CU _ ASSERT ( strnc mp ( TEST _ ATTR _250 POP , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁if ▁( est _ set _ csr _ cb ( ectx , ▁& handle _ correct _ csrattrs _ request )) ▁{ ▁ printf (" \ nU nable ▁to ▁set ▁EST ▁CSR ▁Attributes ▁callback . ▁A bort ing !!! \ n "); ▁exit (1); ▁} ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR 1)) ; ▁CU _ ASSERT ( strnc mp ( TEST _ ATTR 1, ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁if ▁( est _ set _ csr _ cb ( ectx , ▁& handle _ no pop _ csrattrs _ request )) ▁{ ▁ printf (" \ nU nable ▁to ▁set ▁EST ▁CSR ▁Attributes ▁callback . ▁A bort ing !!! \ n "); ▁exit (1); ▁} ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR _ NOPOPPOP ) ); ▁CU _ ASSERT ( ▁strnc mp ( TEST _ ATTR _ NOPOPPOP , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁if ▁( est _ set _ csr _ cb ( ectx , ▁& handle _ empty _ csrattrs _ request )) ▁{ ▁ printf (" \ nU nable ▁to ▁set ▁EST ▁CSR ▁Attributes ▁callback . ▁A bort ing !!! \ n "); ▁exit (1); ▁} ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR 2 _ POP ) ); ▁CU _ ASSERT ( strnc mp ( TEST _ ATTR 2 _ POP , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁/* ▁disable ▁PoP ▁*/ ▁st _ disable _ pop (); ▁/* ▁clear ▁callback ▁*/ ▁if ▁( est _ set _ csr _ cb ( ectx , ▁NULL )) ▁{ ▁ printf (" \ nU nable ▁to ▁set ▁EST ▁CSR ▁Attributes ▁callback . ▁A bort ing !!! \ n "); ▁exit (1); ▁} ▁/* ▁Real ▁base 64 ▁string ▁PoP ▁should ▁not ▁be ▁add ed ▁- ▁should ▁pass ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ▁ectx , ▁TEST _ ATTR _ NOPOP , ▁str len ( TEST _ ATTR _ NOPOP ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ATTR _ NOPOP ) ); ▁CU _ ASSERT ( strnc mp ( TEST _ ATTR _ NOPOP , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁/* ▁All ▁ASN .1 ▁types ▁supported ▁by ▁Cisco SSL ▁*/ ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ ALL _ ATTR , ▁str len ( TEST _ ALL _ ATTR ) ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& csr _ data , ▁& csr _ len ); ▁CU _ ASSERT ( rc ▁ == ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( csr _ len ▁ == ▁str len ( TEST _ ALL _ ATTR ) ); ▁CU _ ASSERT ( strnc mp ( TEST _ ALL _ ATTR , ▁( const ▁char ▁*) ▁csr _ data , ▁csr _ len ) ▁ == ▁0); ▁rc ▁= ▁est _ server _ init _ csrattrs ( ▁ectx , ▁TEST _102 5 _ NOPOP , ▁str len ( TEST _102 5 _ NOPOP ) ); ▁CU _ ASSERT ( rc ▁ != ▁EST _ ERR _ NONE ); ▁rc ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁TEST _ LONG _ ATTR , ▁str len ( TEST _ LONG _ ATTR ) ); ▁CU _ ASSERT ( rc ▁ != ▁EST _ ERR _ NONE ); ▁if ▁( ctx ) ▁{ ▁est _ destroy ( ctx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁The ▁main () ▁function ▁for ▁setting ▁up ▁and ▁running ▁the ▁tests . ▁* ▁Returns ▁a ▁CU E _ SUCCESS ▁on ▁successful ▁running , ▁another ▁* ▁ CUnit ▁error ▁code ▁on ▁failure . ▁*/ ▁int ▁us 900_ add _ suite ▁( void ) ▁{ ▁# if def ▁HA VE _ C UNIT ▁CU _ pSuite ▁pSuite ▁= ▁NULL ; ▁/* ▁add ▁a ▁suite ▁to ▁the ▁ registry ▁*/ ▁pSuite ▁= ▁CU _ add _ suite (" us 900_ srv _ csrattrs ", ▁us 900_ init _ suite , ▁us 900_ destroy _ suite ); ▁if ▁( NULL ▁ == ▁pSuite ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁/* ▁add ▁the ▁tests ▁to ▁the ▁suite ▁*/ ▁if ▁( ( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" CSR ▁Server ▁Attributes ▁API 1", ▁us 900_ test 1)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" CSR ▁Server ▁Attributes ▁API 2 ", ▁us 900_ test 2))) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁return ▁CU E _ SUCCESS ; ▁# endif ▁}