▁/* -- ---------------- ---------------- ---------------- ---------------- ▁* ▁us 903 . c ▁- ▁ Unit ▁Test s ▁for ▁User ▁Stor y ▁ 903 ▁- ▁Server ▁simple ▁enroll ▁* ▁* ▁August , ▁2013 ▁* ▁* ▁Copy right ▁( c ) ▁2013 , ▁2016 ▁by ▁ cisco ▁S ystems , ▁Inc . ▁* ▁All ▁ right s ▁ reserved . ▁* -- ---------------- ---------------- ---------------- ---------------- ▁*/ ▁# include ▁ < std io . h > ▁# if n def ▁W IN 32 ▁# include ▁ < uni std . h > ▁# endif ▁# include ▁ < est . h > ▁# include ▁ < curl / curl . h > ▁# include ▁" curl _ util s . h " ▁# include ▁" test _ util s . h " ▁# include ▁" st _ server . h " ▁# include ▁ < openssl / ssl . h > ▁# if def ▁HA VE _ C UNIT ▁# include ▁" CUnit / Basic . h " ▁# include ▁" CUnit / A utomat ed . h " ▁# endif ▁# if n def ▁W IN 32 ▁static ▁char ▁test 5 _ outfile [ FILE NAME _ MAX ] ▁= ▁" US 903/ test 5 . hdr "; ▁# define ▁US 903_ CACERTS ▁" CA / estCA / cacert . crt " ▁# define ▁US 903_ EXPLICIT _ CERT ▁" US 903/ cert - RA . pem " ▁# define ▁US 903_ EXPLICIT _ KEY ▁" US 903/ key - RA . pem " ▁# define ▁US 903_ CACERTS ▁" CA / estCA / cacert . crt " ▁# define ▁US 903_ TRUSTED _ CERT ▁" CA / trustedcerts . crt " ▁# define ▁US 903_ SERVER _ CERT _ AND _ KEY ▁" CA / estCA / private / estserver cert and key . pem " ▁# else ▁static ▁char ▁test 5 _ outfile [ FILE NAME _ MAX ] ▁= ▁" US 903\\ test 5 . hdr "; ▁# define ▁US 903_ CACERTS ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 903_ EXPLICIT _ CERT ▁" US 903\\ cert - RA . pem " ▁# define ▁US 903_ EXPLICIT _ KEY ▁" US 903\\ key - RA . pem " ▁# define ▁US 903_ CACERTS ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 903_ TRUSTED _ CERT ▁" CA \\ trustedcerts . crt " ▁# define ▁US 903_ SERVER _ CERT _ AND _ KEY ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# endif ▁static ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁static ▁int ▁cacerts _ len ▁= ▁0; ▁# define ▁US 903_ RETRY _ INTERVAL ▁3600 ▁# define ▁US 903_ TCP _ PORT ▁ 29001 ▁/* ▁* ▁The ▁following ▁CSR ▁was ▁ generated ▁using ▁the ▁following ▁openssl ▁command ▁and ▁then ▁* ▁using ▁cat ▁on ▁the ▁rsa . req ▁file : ▁* ▁* ▁openssl ▁req ▁- new key ▁rsa : 2048 ▁- key out ▁rsa key . pem ▁- key form ▁PEM ▁- out ▁rsa . req ▁- out form ▁PEM ▁*/ ▁# define ▁US 903_ PKCS 10_ RSA 2048 ▁" MIIC v TCCAa U CAQAw e DEL MAkG A 1 UEB h MCV VM x CzA J BgNVBA g MAk 5 DM Qw wC gYDVQQ H \ nDANSVFAxE j AQ BgNVBAoMC VJ TQW Nl cn Rj bz EM MA oGA 1 UEC wwD cnN h MR AwDgYDV QQD \ nDA d yc 2 EgZG 9 lMR o wGA YJKoZIhvcNAQkBFg ty c 2 FA ZG 9 l Lm Nvb T CCASIwDQYJKoZI \ n hvcNAQEBBQADgg EPADCCAQoCggEBA N 6 pC TB rK 7 T 0 29 Bg a nq 0 QH XH y NL 8 op v xc 7 JY \ n Xa Qz 39 R 3 J 9 BoB E 72 XZ 0 QX sB tU EY GNh HO La IS ASN zs 2 ZK Wp vM HJ W mP YN t 39 OC i 48 Y \ n FO gL Db An 83 mA OK Sf c ML bi bC c sh 4 HO l haa F rWs kRT As ew 16 MU Oz Fu 6 vB kw / A hI 82 J \ nK PY ws 0 dY Ox uW FI gE 1 HL + m / gpl bz q 7 Fr BI d rq k NL + dd gy Xo Dd 5 Nu LM JG DAK 7 vB 1 Ww \ n 9/ Ba w /6 Ai 9 V 5 ps ye 1 v 8 f WD r 6 HW 2 gg 9 X n VtM wB 4 pC g 1 rl 1 l SY stum T GY bM 6 cx Jy we \ nL uM nD jj 1 Zw D sZ 1 wI Xa BA XZa x EIS / rX OX 0 H nZ MT ef xY / gp Fk 1 Kv 0 CAwEAAa AAMA 0 G \ n CS qGS Ib 3 DQEBBQUA A 4 IBAQB 6 r Iw Nj E 8 l 8 jF KR 1 hQ / qe Sv ee / bAQ a 58 Ru fZ 4 US Ku K \ nl si h 7 UC f 8 b kQ vg lj nh s c Qu cz Ibn Jz eq EP qS dn om FW 6 Cv Mc / ah + Qf X 87 FG Y xJ gp wF \ n ut nU if j Di Zh rW gf / jN N bt H rke cw / Z ex 4 sZ / HC 127 j tE 3 cy E kD srA 1 oB xYR Cq 93 tC \ nW 2 q 9 PL Vm Ll yjc Z cS 1 KH VD 2 n ya 79 kfS 0 Y GM ocs w 1 Ge l VL 2 iz / oca yA S 5 GB 9 Y 2 s E Bw \ nR kC aY Zw 6 v hj 5 qj p CU zJ 3 E 8 Cl 3 VD 4 Kp i 3 j 3 bZGD JA 9 md md 8 j 5 Zy PY 56 e Au xa rW ssD \ n ci UM / h 6 E 99 w 3 tm rU Zb Ll jk jJ 7 pBX Rn ont gm 5 WZ mQ FH 4 X " ▁/* ▁* ▁The ▁following ▁CSR ▁was ▁ generated ▁using ▁the ▁following ▁openssl ▁command ▁and ▁then ▁* ▁using ▁cat ▁on ▁the ▁ec . req ▁file : ▁* ▁* ▁openssl ▁req ▁- new key ▁ec : 256 parms ▁- key out ▁eckey . pem ▁- key form ▁PEM ▁- out ▁ec . req ▁- out form ▁PEM ▁*/ ▁# define ▁US 903_ PKCS 10_ DSA 1024 ▁" MIIC f jCCA j 0 CAQAw f DEL MAkG A 1 UEB h MCV VM x CzA J BgNVBA g MAk 5 DM Qw wC gYDVQQ H \ nDANSVFAxE zA R BgNVBAoMC kRTQ U Nvb X Bhb nk xD zA N BgNVBA s MB kRTQ W 9 yZzE Q MA 4 G \ nA 1 UEAww H ZHNh IGRv ZT EaM Bg GCS qGS Ib 3 DQEJ ARY L ZHNh Q GRvZ S 5 jb 20 wgg G 2 MIIB \ n KwY HKoZIzjgEA TCCA R 4 CgYEA q If by k 7 rE AaU L IP B 1 Gc H Hc 0 ctx 6 g 0 dh Bf d Ud OP NG \ nB SE + TP 5 UF 5 lw 8 Qm 6 o CX stU 3 nY EJ al mMv k jF wb g vB ws 8 a JBn j 09 dD Dn 8 s pK EG cG 0 M \ n Zp qd My s 6+ b 4 QJ jq 5 Y AxE a ATV Y /1 L / rBg G Gm 1 EF Dhc /6 E zm 2 T 3 C Ge Qk lw o 5 a BZQ Cc \ n aI sCF QD C 1 ol BF uE + ph Ohj X AwE E 5 EP Jk R Jw KBgD + vZ + t L CT jB zV FN jAO 8 X / SM am wW \ no ra Nf dyZ + ZC EA mYI / D 4 838 n C GA jVR Qy Db 1 q 5 ak kL yx oJ X 1 YV 7 g Nba BN Uy s 3 wa qd u \ nso 1 Ht uE ur 2 cb hU 5 iO eKB Wp j 6 MI Wl P dD 3 uC Ru 4 ui BF 9 XB iAN a RID 8 CT 2 kc hh wy 4 Ok \ nF f QM uY Oz 4 e BhM Qq mA 4 G EAA KBgD u wR 7 H 3 U 4 C fu Qj We T t rI 50 M 1 Tx hlV Z 3 T on RtV Ix \ n EH pu X xA ou x ATV kt h J ta CBK c 0 EH i i 1 bE / kg N Ug GX / Zd F jB Ub / X fp k Ys RT 3 QR LF 0+ s \ n PZ GY /0 T ov O 9 pK jq iw 0 C 10 le N KF b EV dl XY t Ak jX Ub Hm yN og 31 95/ t 7 oK XH MT 1 A / 5 p \ n hUC R oAAw CQ YHKoZIzjgEA w Mw ADA tA hU Ah PCq QG 3 gK UU PK dw BN Cm Zf z WD qj sCF Ah 0\ nz n 9 H uj lXN a TA 1 Ohj mP m cJ SxT " ▁/* ▁* ▁The ▁following ▁CSR ▁was ▁ generated ▁using ▁the ▁following ▁openssl ▁command ▁and ▁then ▁* ▁using ▁cat ▁on ▁the ▁dsa . req ▁file : ▁* ▁* ▁openssl ▁req ▁- new key ▁dsa : dsa parms ▁- key out ▁dsa key . pem ▁- key form ▁PEM ▁- out ▁dsa . req ▁- out form ▁PEM ▁*/ ▁# define ▁US 903_ PKCS 10_ ECDSA 256 ▁" MIIB MT CB 2 gIBADB 4 MQswCQYDVQQGEwJ VU zE L MAkG A 1 UECAw CT kM xD DAK BgNVBA cM \ nA 1 JU U DES MB AGA 1 UECgw JR UND b 21 wYW 55 MQ 4 wDAYDVQQLDAVFQ 29 yZzE P MA 0 GA 1 UE \ n AwwG R UM gZG 9 l MRkwFwY JKoZIhvcNAQkBFg p lY 0 Bkb 2 U uY 29 t MF kwE wYHKoZIzj 0 C \ nAQ YI KoZIzj 0 DAQ c DQ gA EO 1 us z CK dXN Fz yg NL N eS 8 az QK od 151 6 GT 9 qd Dd d t 9 iJ N 4\ nL pB Tnv +7 K 7+ t ji 5 kt s 1 kW SY yv qL xv nq 8 Q / TU 1 i QJ 56 AAMA k GBy qGS M 49 BA E DR wAw \ nR AIg P 6 qd a +0 TE KZ F Pop gU fwF MRs xc N mu QU e 2 y uz 1 64 60/ SQ C IB fL vm uM ey YO qb bD \ nX 0 I fde 9 y zk RO VB C EP vK 0 h cU 5 KsT O " ▁# define ▁US 903_ PKCS 10_ CORRUPT ▁" MIIB MT CB 2 gIBADB 4 MQswCQYDVQQGEwJ VU zE L MAkG A 1 UECAw CT kM xD DAK BgNVBA cM \ nA 1 JU U DES MB AGA 1 UECgw JR UND b 21 wYW 55 MQ 4 wDAYDVQQLDAVFQ 39 yZzE P MA 0 GA 1 UE \ n AwwG R UM gZG 9 l MRkwFwY JKoZIhvcNAQkBFg p lY 0 Bkb 2 U uY 29 t MF kwE wYHKoZIzj 0 C \ nAQ YI KoZIzj 0 DAQ c DQ gA EO 1 us z CK dXN Fz yg NL N eS 8 az QK od 151 6 GT 9 qd Dd d t 9 iJ N 4\ nL pB Tnv +7 K 7+ t ji 5 kt s 1 kW SY yv qL xv nq 8 Q / TU 1 i QJ 56 AAMA k GBy qGS M 49 BA E DR wAw \ nR AIg P 6 qd a +0 TE KZ F Pop gU fwF MRs xc N mu QU e 2 y uz 1 64 60/ SQ C IB fL vm uM ey YO qb bD \ nX 0 I fde 9 y zk RO VB C EP vK 0 h cU 5 KsT O " ▁/* ▁* ▁The ▁following ▁is ▁a ▁valid ▁CSR ▁that ▁al ready ▁contains ▁a ▁PoP ▁* ▁c hallengePassword . ▁This ▁was ▁c oll ected ▁using ▁est server ▁with ▁* ▁the ▁dump bin () ▁function . ▁This ▁CSR ▁should ▁ne ver ▁work ▁since ▁* ▁the ▁PoP ▁value ▁in ▁it ▁will ▁be ▁sta le . ▁*/ ▁# define ▁US 903_ PKCS 10_ STA LE _ POP ▁" MIIB cj CB 3 A IBADA R MQ 8 wDQ YDVQQDE wZ URV NU Q 04 w gZ 8 wDQYJKoZI hvcNAQEBBQAD \ n gY 0 A MIG JAoGBA PD Hv rk VB 3 + r FH l + Ku I sr ZG i xld RY RD 50 S 2 vF s 8 mW 5 wW Vx DS 3 x FR \ nz cK t qg 7 JU yW 8 NY OF N WX 0 oz h Ce 87 XP 2 h 7 tUp Hy H lL /8 N /8 4 zuM tA t KT LU 3 Bjg q 1 xg \ nu u 8 a 1 ht 10 wi y 8 u 2 r / u EK MhQ w pv t 56 UY 5 pH zu qm ql O 0 ql m E + M 58 WN 49 Ih AgMBAAGg \ n IjA g Bgkq hk iG 9 w 0 BCQcxE xYR Uj dGN 1 ZUN Uw yd 2 Vu eW t Mc A ow DQYJKoZIhvcNAQEF \ n BQADgYEA y enrs km fR IX cp eKB vL 3 V nW 5 N 4 Hc LT wI 9 Hc br 74 4 SW FQ aw / R + ru + UX d 2 j \ n 99 AG Br / Gv Tk T gh IN Wg 2 C 7 v z GF / z hI uG 6 Ok 9 Ft iM n N r 9 hZ +5 SL Yh fS FJ bu Iv 65 rW H \ n vf LR 9 N 9 M 2 Q 9 jl f 7 p 4 AY fW XD 2 qD 2 X OT Zw 2 t 4 tr G ZG KA 2 JR / O iB 40 =" ▁# define ▁US 903_ ENROLL _ URL _ BA ▁" http s ://127.0.0.1:290 01/ . well - known / est / simpleenroll " ▁# define ▁US 903_ PKCS 10_ CT ▁" Content - Type : ▁application / pkcs 10" ▁# define ▁US 903_ UIDPWD _ GOOD ▁" estuser : estpwd " ▁static ▁E VP _ PKEY ▁* ▁generate _ private _ key ▁( void ) ▁{ ▁RSA ▁* rsa ▁= ▁RSA _ new (); ▁B IG NUM ▁* bn ▁= ▁ BN _ new (); ▁E VP _ PKEY ▁* pkey ; ▁/* ▁* ▁create ▁an ▁RSA ▁ keypair ▁and ▁assign ▁them ▁to ▁a ▁ PKEY ▁and ▁return ▁it . ▁*/ ▁ BN _ set _ word ( bn , ▁0 x 1000 1); ▁RSA _ generate _ key _ ex ( rsa , ▁1024 , ▁bn , ▁NULL ); ▁pkey ▁= ▁E VP _ PKEY _ new (); ▁if ▁( pkey ▁ == ▁NULL ) ▁{ ▁ printf (" \ n Error ▁allocat ing ▁ PKEY ▁structure ▁for ▁new ▁key ▁pair \ n "); ▁return ▁NULL ; ▁} ▁if ▁(! E VP _ PKEY _ set 1 _ RSA ( pkey , ▁rsa )) ▁{ ▁ printf (" \ n Error ▁assign ing ▁RSA ▁key ▁pair ▁to ▁ PKEY ▁structure \ n "); ▁return ▁NULL ; ▁} ▁RSA _ free ( rsa ); ▁ BN _ free ( bn ); ▁return ▁( pkey ); ▁} ▁/* ▁* ▁C allback ▁function ▁passed ▁to ▁est _ client _ init () ▁*/ ▁static ▁int ▁client _ manual _ cert _ verify ▁( X 509 ▁* cur _ cert , ▁int ▁openssl _ cert _ error ) ▁{ ▁BIO ▁* ▁bio _ err ; ▁bio _ err ▁= ▁BIO _ new _ fp ( stderr , ▁BIO _ NO CLOSE ); ▁int ▁approve ▁= ▁0; ▁/* ▁* ▁Pr int ▁out ▁the ▁specific s ▁of ▁this ▁cert ▁*/ ▁ printf ( ▁"% s : ▁OpenSSL / EST ▁server ▁cert ▁verification ▁failed ▁with ▁the ▁following ▁error : ▁openssl _ cert _ error ▁= ▁% d ▁(% s ) \ n ", ▁ _ _ FUNCTION _ _ , ▁openssl _ cert _ error , ▁X 509_ verify _ cert _ error _ string ( openssl _ cert _ error ) ); ▁ printf (" Fail ing ▁Cert : \ n "); ▁X 509_ print _ fp ( stdout , ▁cur _ cert ); ▁/* ▁* ▁ Next ▁call ▁print s ▁out ▁the ▁signature ▁which ▁can ▁be ▁used ▁as ▁the ▁fingerprint ▁* ▁This ▁fingerprint ▁can ▁be ▁checked ▁against ▁the ▁anti cip ated ▁value ▁to ▁determine ▁* ▁whether ▁or ▁not ▁the ▁server ' s ▁cert ▁should ▁be ▁approved . ▁*/ ▁X 509_ signature _ print ( bio _ err , ▁cur _ cert -> sig _ alg , ▁cur _ cert -> signature ); ▁if ▁( openssl _ cert _ error ▁ == ▁X 509_ V _ ERR _ U NABLE _ TO _ GET _ CRL ) ▁{ ▁approve ▁= ▁1; ▁} ▁BIO _ free ( bio _ err ); ▁return ▁approve ; ▁} ▁static ▁ FILE ▁* outfile ; ▁static ▁size _ t ▁write _ func ▁( void ▁* ptr , ▁size _ t ▁size , ▁size _ t ▁nmemb , ▁void ▁* user data ) ▁{ ▁size _ t ▁written ; ▁written ▁= ▁f write ( ptr , ▁size , ▁nmemb , ▁outfile ); ▁return ▁written ; ▁} ▁static ▁void ▁us 903_ clean ▁( void ) ▁{ ▁} ▁static ▁int ▁us 903_ start _ server ▁( int ▁manual _ enroll , ▁int ▁nid ) ▁{ ▁int ▁rv ; ▁rv ▁= ▁st _ start ( US 903_ TCP _ PORT , ▁US 903_ SERVER _ CERT _ AND _ KEY , ▁US 903_ SERVER _ CERT _ AND _ KEY , ▁" US 903 ▁test ▁realm ", ▁US 903_ CACERTS , ▁US 903_ TRUSTED _ CERT , ▁" CA / est Example CA . cnf ", ▁manual _ enroll , ▁0, ▁nid ); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁initialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁allocate ▁data ▁or ▁open ▁any ▁* ▁resource s ▁required ▁for ▁all ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 903_ init _ suite ▁( void ) ▁{ ▁int ▁rv ; ▁est _ init _ logger ( EST _ LOG _ L VL _ INFO , ▁NULL ); ▁/* ▁* ▁Rea d ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( US 903_ CACERTS , ▁& cacerts ); ▁if ▁( cacerts _ len ▁ < = ▁0) ▁{ ▁return ▁1; ▁} ▁us 903_ clean (); ▁/* ▁* ▁Start ▁an ▁instance ▁of ▁the ▁EST ▁server ▁with ▁* ▁automatic ▁enrollment ▁enabled . ▁*/ ▁rv ▁= ▁us 903_ start _ server ( 0 , ▁0); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁uninitialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁de allocate ▁data ▁or ▁close ▁any ▁* ▁resource s ▁that ▁we re ▁used ▁for ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 903_ des tory _ suite ▁( void ) ▁{ ▁st _ stop (); ▁free ( cacerts ); ▁return ▁0; ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁RSA ▁2048 ▁* ▁* ▁This ▁test ▁case ▁uses ▁libcurl ▁to ▁test ▁simple ▁* ▁enrollment ▁of ▁a ▁2048 ▁bit ▁RSA ▁CSR . ▁HTTP ▁Basic ▁* ▁authentication ▁is ▁used . ▁*/ ▁static ▁void ▁us 903_ test 1 ▁( void ) ▁{ ▁long ▁rv ; ▁ LOG _ FUNC _ NM ▁; ▁rv ▁= ▁curl _ http _ post ( US 903_ ENROLL _ URL _ BA , ▁US 903_ PKCS 10_ CT , ▁US 903_ PKCS 10_ RSA 2048, ▁US 903_ UIDPWD _ GOOD , ▁US 903_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁/* ▁* ▁S ince ▁we ▁passed ▁in ▁a ▁valid ▁user ID / password , ▁* ▁we ▁expect ▁the ▁server ▁to ▁respond ▁with ▁200 ▁*/ ▁CU _ ASSERT ( rv ▁ == ▁200 ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁EC ▁prime ▁256 ▁* ▁* ▁This ▁test ▁case ▁uses ▁libcurl ▁to ▁test ▁simple ▁* ▁enrollment ▁of ▁a ▁256 ▁bit ▁EC ▁CSR . ▁HTTP ▁Basic ▁* ▁authentication ▁is ▁used . ▁*/ ▁static ▁void ▁us 903_ test 2 ▁( void ) ▁{ ▁long ▁rv ; ▁ LOG _ FUNC _ NM ▁; ▁rv ▁= ▁curl _ http _ post ( US 903_ ENROLL _ URL _ BA , ▁US 903_ PKCS 10_ CT , ▁US 903_ PKCS 10_ ECDSA 256, US 903_ UIDPWD _ GOOD , ▁US 903_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁/* ▁* ▁S ince ▁we ▁passed ▁in ▁a ▁valid ▁user ID / password , ▁* ▁we ▁expect ▁the ▁server ▁to ▁respond ▁with ▁200 ▁*/ ▁CU _ ASSERT ( rv ▁ == ▁200 ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁ DSA ▁prime ▁1024 ▁* ▁* ▁This ▁test ▁case ▁uses ▁libcurl ▁to ▁test ▁simple ▁* ▁enrollment ▁of ▁a ▁1024 ▁bit ▁ DSA ▁CSR . ▁HTTP ▁Basic ▁* ▁authentication ▁is ▁used . ▁*/ ▁static ▁void ▁us 903_ test 3 ▁( void ) ▁{ ▁long ▁rv ; ▁ LOG _ FUNC _ NM ▁; ▁rv ▁= ▁curl _ http _ post ( US 903_ ENROLL _ URL _ BA , ▁US 903_ PKCS 10_ CT , ▁US 903_ PKCS 10_ DSA 1024, ▁US 903_ UIDPWD _ GOOD , ▁US 903_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁/* ▁* ▁S ince ▁we ▁passed ▁in ▁a ▁valid ▁user ID / password , ▁* ▁we ▁expect ▁the ▁server ▁to ▁respond ▁with ▁200 ▁*/ ▁CU _ ASSERT ( rv ▁ == ▁200 ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁Corrupt ed ▁PKCS 10 ▁* ▁* ▁This ▁test ▁case ▁uses ▁libcurl ▁to ▁test ▁simple ▁* ▁enrollment ▁using a ▁corrupted ▁CSR . ▁HTTP ▁Basic ▁* ▁authentication ▁is ▁used . ▁*/ ▁static ▁void ▁us 903_ test 4 ▁( void ) ▁{ ▁long ▁rv ; ▁ LOG _ FUNC _ NM ▁; ▁rv ▁= ▁curl _ http _ post ( US 903_ ENROLL _ URL _ BA , ▁US 903_ PKCS 10_ CT , ▁US 903_ PKCS 10_ CORRUPT , ▁US 903_ UIDPWD _ GOOD , ▁US 903_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁/* ▁* ▁S ince ▁the ▁CSR ▁is ▁not ▁valid , ▁the ▁server ▁should ▁* ▁respond ▁with ▁a ▁400 . ▁*/ ▁CU _ ASSERT ( rv ▁ == ▁400 ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁manual ▁enrollment ▁* ▁* ▁This ▁test ▁case ▁verifie s ▁the ▁server ▁is ▁* ▁send ing ▁the ▁appro pri ate ▁retry - after ▁response . ▁*/ ▁static ▁void ▁us 903_ test 5 ▁( void ) ▁{ ▁long ▁rv ; ▁ LOG _ FUNC _ NM ▁; ▁/* ▁Sto p ▁the ▁EST ▁server ▁*/ ▁st _ stop (); ▁/* ▁Re start ▁the ▁server ▁with ▁manual ▁enrollment ▁enabled ▁*/ ▁us 903_ start _ server ( 1, ▁0); ▁outfile ▁= ▁f open ( test 5 _ outfile , ▁" w "); ▁rv ▁= ▁curl _ http _ post ( US 903_ ENROLL _ URL _ BA , ▁US 903_ PKCS 10_ CT , ▁US 903_ PKCS 10_ RSA 2048, ▁US 903_ UIDPWD _ GOOD , ▁US 903_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁& write _ func ); ▁f close ( outfile ); ▁/* ▁* ▁S ince ▁the ▁server ▁has n ' t ▁see n ▁this ▁CSR ▁in ▁the ▁past , ▁* ▁it ▁should ▁respond ▁with ▁a ▁retry - after ▁202 ▁response . ▁*/ ▁CU _ ASSERT ( rv ▁ == ▁202 ); ▁/* ▁* ▁Verify ▁the ▁retry - after ▁value ▁*/ ▁rv ▁= ▁grep ( test 5 _ outfile , ▁" R etry - After : ▁3600 "); ▁CU _ ASSERT ( rv ▁ == ▁0); ▁/* ▁* ▁We ▁will ▁a void ▁waiting ▁the ▁full ▁retry ▁ period ▁since ▁we ' re ▁* ▁only ▁simulat ing ▁manual ▁enrollment . ▁W ait ▁a ▁second ▁and ▁then ▁* ▁try ▁to ▁enroll ▁the ▁cert ▁again . ▁*/ ▁SL EEP (1); ▁rv ▁= ▁curl _ http _ post ( US 903_ ENROLL _ URL _ BA , ▁US 903_ PKCS 10_ CT , ▁US 903_ PKCS 10_ RSA 2048, ▁US 903_ UIDPWD _ GOOD , ▁US 903_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁/* ▁* ▁This ▁enrollment ▁request ▁should ▁succeed ▁this ▁time ▁* ▁O ur ▁simulat ed ▁manual ▁enrollment ▁will ▁automatically ▁* ▁enroll ▁on ▁the ▁second ▁attempt . ▁*/ ▁CU _ ASSERT ( rv ▁ == ▁200 ); ▁/* ▁Sto p ▁the ▁EST ▁server ▁*/ ▁st _ stop (); ▁/* ▁Re start ▁the ▁server ▁with ▁manual ▁enrollment ▁disabled ▁*/ ▁us 903_ start _ server ( 0 , ▁0); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁PoP ▁check ▁fails ▁with ▁curl ▁* ▁* ▁This ▁test ▁case ▁verifie s ▁the ▁server ▁is ▁* ▁verifying ▁the ▁PoP ▁from ▁the ▁client ▁CSR . ▁S ince ▁curl ▁does ▁not ▁* ▁set ▁the ▁PoP , ▁the ▁EST ▁enrollment ▁should ▁fail . ▁*/ ▁static ▁void ▁us 903_ test 6 ▁( void ) ▁{ ▁long ▁rv ; ▁ LOG _ FUNC _ NM ▁; ▁st _ enable _ pop (); ▁/* ▁* ▁S end ▁a ▁valid ▁enroll ▁request ▁using ▁curl . ▁Curl ▁does ▁not ▁* ▁include ▁the ▁PoP ▁*/ ▁rv ▁= ▁curl _ http _ post ( US 903_ ENROLL _ URL _ BA , ▁US 903_ PKCS 10_ CT , ▁US 903_ PKCS 10_ RSA 2048, ▁US 903_ UIDPWD _ GOOD , ▁US 903_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁/* ▁* ▁The ▁server ▁should ▁respond ▁with ▁a ▁failure ▁code ▁*/ ▁CU _ ASSERT ( rv ▁ == ▁400 ); ▁st _ disable _ pop (); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁PoP ▁check ▁succeeds ▁with ▁est client ▁* ▁* ▁This ▁test ▁case ▁verifie s ▁the ▁server ▁is ▁* ▁verifying ▁the ▁PoP ▁from ▁the ▁client ▁CSR . ▁We ▁use ▁* ▁est client ▁since ▁it ▁support s ▁the ▁PoP . ▁*/ ▁static ▁void ▁us 903_ test 7 ▁( void ) ▁{ ▁long ▁rv ; ▁EST _ CTX ▁* c _ ctx ; ▁E VP _ PKEY ▁* new _ pkey ; ▁un signed ▁char ▁* pkcs 7 ; ▁int ▁pkcs 7_ len ; ▁un signed ▁char ▁* attr _ data ; ▁int ▁attr _ len ; ▁int ▁http _ status ; ▁ LOG _ FUNC _ NM ▁; ▁/* ▁* ▁This ▁test ▁case ▁requires ▁PoP ▁to ▁be ▁enabled ▁*/ ▁st _ enable _ pop (); ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁c _ ctx ▁= ▁est _ client _ init ( ▁cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( c _ ctx ▁ != ▁NULL ); ▁if ▁(! c _ ctx ) ▁{ ▁return ; ▁} ▁/* ▁* ▁Specify ▁user ▁ID ▁and ▁password ▁since ▁the ▁server ▁is ▁running ▁* ▁in ▁Basic ▁Authentication ▁mode . ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( c _ ctx , ▁" estuser ", ▁" estpwd ", ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁est _ client _ set _ server ( c _ ctx , ▁"127.0.0.1", ▁US 903_ TCP _ PORT , ▁NULL ); ▁/* ▁* ▁get ▁a ▁ keypair ▁to ▁be ▁used ▁in ▁the ▁enroll . ▁*/ ▁new _ pkey ▁= ▁generate _ private _ key (); ▁rv ▁= ▁est _ client _ get _ csrattrs ( c _ ctx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Attempt ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( c _ ctx , ▁" US 903 - test 7 ▁CN ", ▁& pkcs 7_ len , ▁new _ pkey ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁ Check ▁HTTP ▁status ▁code ▁received ▁from ▁server ▁is ▁200 ▁*/ ▁http _ status ▁= ▁est _ client _ get _ last _ http _ status ( c _ ctx ); ▁CU _ ASSERT ( http _ status ▁ == ▁200 ); ▁/* ▁* ▁Client ▁library ▁has ▁obtained ▁the ▁new ▁client ▁certificate . ▁* ▁No w ▁retrieve ▁it ▁from ▁the ▁library . ▁*/ ▁pkcs 7 ▁= ▁malloc ( pkcs 7_ len ); ▁if ▁(! pkcs 7) ▁{ ▁return ; ▁} ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( c _ ctx , ▁pkcs 7 ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Clean ▁up ▁*/ ▁est _ destroy ( c _ ctx ); ▁E VP _ PKEY _ free ( new _ pkey ); ▁free ( pkcs 7 ); ▁/* ▁* ▁Disabl e ▁PoP ▁for ▁future ▁test ▁cases ▁*/ ▁st _ disable _ pop (); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁Use ▁a ▁non - default ▁ ECDHE ▁curve ▁* ▁* ▁This ▁test ▁case ▁verifie s ▁the ▁est _ server _ set _ ecdhe _ curve () ▁* ▁function ▁is ▁working . ▁*/ ▁static ▁void ▁us 903_ test 8 ▁( void ) ▁{ ▁long ▁rv ; ▁ LOG _ FUNC _ NM ▁; ▁/* ▁Sto p ▁the ▁EST ▁server ▁*/ ▁st _ stop (); ▁/* ▁Re start ▁the ▁server ▁using ▁the ▁ secp 384 r 1 ▁curve ▁*/ ▁us 903_ start _ server ( 0 , ▁NID _ secp 384 r 1); ▁rv ▁= ▁curl _ http _ post ( ▁US 903_ ENROLL _ URL _ BA , ▁US 903_ PKCS 10_ CT , ▁US 903_ PKCS 10_ RSA 2048, ▁US 903_ UIDPWD _ GOOD , ▁US 903_ CACERTS , ▁CURL AUTH _ BASIC , ▁" ECDHE - ECDSA - AES 256 - GC M - SHA 384 ", ▁NULL , ▁NULL ); ▁/* ▁* ▁S ince ▁we ▁passed ▁in ▁a ▁valid ▁user ID / password , ▁* ▁we ▁expect ▁the ▁server ▁to ▁respond ▁with ▁200 ▁*/ ▁CU _ ASSERT ( rv ▁ == ▁200 ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁PoP ▁is ▁disabled , ▁the ▁CSR ▁contains ▁a ▁* ▁valid ▁PoP . ▁* ▁* ▁This ▁test ▁case ▁ensure s ▁the ▁server ▁can ▁handle ▁the ▁* ▁scenario ▁ where ▁the ▁CSR ▁include s ▁a ▁valid ▁PoP ▁even ▁when ▁* ▁the ▁server ▁did n ' t ▁request ▁it . ▁We ▁have ▁to ▁use ▁* ▁Cisco EST ▁as ▁the ▁client ▁to ▁generate ▁a ▁CSR ▁containing ▁* ▁a ▁valid ▁PoP . ▁There ' s ▁no ▁ way ▁to ▁include ▁a ▁valid ▁PoP ▁* ▁using ▁Curl ▁since ▁the ▁TLS ▁channel ▁binding ▁information ▁* ▁is ▁not ▁known ▁in ▁advance . ▁*/ ▁// The ▁following ▁include ▁should ▁ne ver ▁be ▁used ▁by ▁an ▁application ▁// be ▁we ▁use ▁it ▁here ▁to ▁hack ▁the ▁EST _ CTX ▁values ▁mid - way ▁// through ▁this ▁test ▁# include ▁"../../ src / est / est _ loc l . h " ▁static ▁void ▁us 903_ test 9 ▁( void ) ▁{ ▁EST _ CTX ▁* ctx ; ▁int ▁rv ; ▁un signed ▁char ▁* cacerts ; ▁int ▁caclen ▁= ▁0; ▁E VP _ PKEY ▁* new _ pkey ; ▁un signed ▁char ▁* pkcs 7 ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* attr _ data ; ▁int ▁attr _ len ; ▁ LOG _ FUNC _ NM ▁; ▁/* ▁* ▁M ake ▁sure ▁our ▁EST ▁server ▁has ▁PoP ▁disabled ▁*/ ▁st _ disable _ pop (); ▁/* ▁* ▁Rea d ▁in ▁the ▁CA ▁certs ▁*/ ▁caclen ▁= ▁read _ binary _ file ( US 903_ CACERTS , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁Init ▁the ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( ▁cacerts , ▁caclen , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁/* ▁* ▁We ' ll ▁use ▁simple ▁HTTP ▁auth ▁to ▁identify ▁ourselves ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁" estuser ", ▁" estpwd ", ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁est _ client _ set _ server ( ctx , ▁"127.0.0.1", ▁US 903_ TCP _ PORT , ▁NULL ); ▁/* ▁* ▁C reate ▁some ▁space ▁to ▁hold ▁the ▁cert ▁and ▁generate ▁* ▁a ▁private ▁key ▁*/ ▁new _ pkey ▁= ▁generate _ private _ key (); ▁rv ▁= ▁est _ client _ get _ csrattrs ( ctx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Attempt ▁to ▁enroll ▁*/ ▁ctx -> csr _ pop _ required ▁= ▁1; ▁// This ▁is ▁a ▁hack ▁for ▁testing ▁only , ▁do ▁not ▁attempt ▁this ▁// We ▁need ▁to ▁force ▁the ▁c hallengePassword ▁into ▁the ▁CSR ▁rv ▁= ▁est _ client _ enroll ( ctx , ▁" Test Case 9", ▁& pkcs 7_ len , ▁new _ pkey ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁pkcs 7 ▁= ▁malloc ( pkcs 7_ len ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ctx , ▁pkcs 7 ); ▁free ( pkcs 7 ); ▁est _ destroy ( ctx ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁PoP ▁is ▁disabled , ▁the ▁CSR ▁contains ▁a ▁* ▁invalid ▁PoP . ▁* ▁* ▁This ▁test ▁case ▁ensure s ▁the ▁server ▁can ▁handle ▁the ▁* ▁scenario ▁ where ▁the ▁CSR ▁include s ▁an ▁invalid ▁PoP ▁even ▁when ▁* ▁the ▁server ▁did n ' t ▁request ▁it . ▁*/ ▁static ▁void ▁us 903_ test 10 ▁( void ) ▁{ ▁long ▁rv ; ▁ LOG _ FUNC _ NM ▁; ▁/* ▁* ▁M ake ▁sure ▁our ▁EST ▁server ▁has ▁PoP ▁disabled ▁*/ ▁st _ disable _ pop (); ▁rv ▁= ▁curl _ http _ post ( US 903_ ENROLL _ URL _ BA , ▁US 903_ PKCS 10_ CT , ▁US 903_ PKCS 10_ STA LE _ POP , ▁US 903_ UIDPWD _ GOOD , ▁US 903_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁/* ▁* ▁The ▁enroll ▁request ▁should ▁fail ▁since ▁the ▁PoP ▁was ▁invalid ▁* ▁We ▁expect ▁a ▁400 ▁response . ▁*/ ▁CU _ ASSERT ( rv ▁ == ▁400 ); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁PoP ▁is ▁enabled , ▁the ▁CSR ▁contains ▁a ▁* ▁invalid ▁PoP , ▁and ▁the ▁client ▁uses ▁* ▁a ▁cert ▁that ▁contains ▁id - kp - cmcRA . ▁* ▁* ▁This ▁test ▁case ▁ensure s ▁the ▁server ▁disable s ▁the ▁PoP ▁* ▁check ▁when ▁the ▁client ▁is ▁using ▁a ▁cert ▁that ▁contains ▁* ▁id - kp - cmcRA , ▁which ▁indicate s ▁the ▁client ▁is ▁an ▁RA . ▁*/ ▁static ▁void ▁us 903_ test 11 ▁( void ) ▁{ ▁long ▁rv ; ▁ LOG _ FUNC _ NM ▁; ▁/* ▁* ▁M ake ▁sure ▁our ▁EST ▁server ▁has ▁PoP ▁disabled ▁*/ ▁st _ enable _ pop (); ▁rv ▁= ▁curl _ http _ post _ cert uid ( ▁US 903_ ENROLL _ URL _ BA , ▁US 903_ PKCS 10_ CT , ▁US 903_ PKCS 10_ STA LE _ POP , ▁US 903_ UIDPWD _ GOOD , ▁US 903_ EXPLICIT _ CERT , ▁US 903_ EXPLICIT _ KEY , ▁US 903_ CACERTS , ▁NULL ); ▁/* ▁* ▁E ven ▁though ▁the ▁PoP ▁value ▁does n ' t ▁match ▁in ▁this ▁CSR , ▁* ▁the ▁enroll ▁will ▁succeed ▁since ▁the ▁client ▁is ▁using ▁* ▁an ▁RA ▁certificate . ▁We ▁expect ▁a ▁200 ▁response . ▁*/ ▁CU _ ASSERT ( rv ▁ == ▁200 ); ▁} ▁/* ▁The ▁main () ▁function ▁for ▁setting ▁up ▁and ▁running ▁the ▁tests . ▁* ▁Returns ▁a ▁CU E _ SUCCESS ▁on ▁successful ▁running , ▁another ▁* ▁ CUnit ▁error ▁code ▁on ▁failure . ▁*/ ▁int ▁us 903_ add _ suite ▁( void ) ▁{ ▁# if def ▁HA VE _ C UNIT ▁CU _ pSuite ▁pSuite ▁= ▁NULL ; ▁/* ▁add ▁a ▁suite ▁to ▁the ▁ registry ▁*/ ▁pSuite ▁= ▁CU _ add _ suite (" us 903_ srv _ simp enroll ", ▁us 903_ init _ suite , ▁us 903_ des tory _ suite ); ▁if ▁( NULL ▁ == ▁pSuite ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁/* ▁add ▁the ▁tests ▁to ▁the ▁suite ▁*/ ▁if ▁( ( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Enroll ▁RSA ▁cert ", ▁us 903_ test 1)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Enroll ▁ ECDSA ▁cert ", ▁us 903_ test 2)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Enroll ▁ DSA ▁cert ", ▁us 903_ test 3)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Enroll ▁corrupted ▁ ECDSA ▁cert ", ▁us 903_ test 4)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Enroll ▁retry - after ▁manual ▁approval ▁" , ▁us 903_ test 5)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Enroll ▁PoP ▁fail ▁with ▁Curl ", ▁us 903_ test 6)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Enroll ▁PoP ▁succeed ▁with ▁est client ", ▁us 903_ test 7)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Non - default ▁ ECDHE ▁curve ", ▁us 903_ test 8)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Enroll ▁w / PoP ▁disabled , ▁CSR ▁include s ▁valid ▁PoP ", ▁us 903_ test 9 )) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Enroll ▁w / PoP ▁disabled , ▁CSR ▁include s ▁invalid ▁PoP ", ▁us 903_ test 10)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Enroll ▁w / PoP ▁enabled ▁using ▁RA ▁cert , ▁CSR ▁include s ▁invalid ▁PoP ", ▁us 903_ test 11)) ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁return ▁CU E _ SUCCESS ; ▁# endif ▁}