▁/* -- ---------------- ---------------- ---------------- ---------------- ▁* ▁us 1159. c ▁- ▁ Unit ▁Test s ▁for ▁User ▁Stor y ▁ 1159 ▁- ▁CSR ▁Attributes ▁enforce ▁* ▁* ▁October , ▁2014 ▁* ▁* ▁Copy right ▁( c ) ▁2014 , ▁2016 ▁by ▁ cisco ▁S ystems , ▁Inc . ▁* ▁All ▁ right s ▁ reserved . ▁* -- ---------------- ---------------- ---------------- ---------------- ▁*/ ▁# include ▁ < std io . h > ▁# if n def ▁W IN 32 ▁# include ▁ < uni std . h > ▁# endif ▁# include ▁ < est . h > ▁# include ▁" test _ util s . h " ▁# include ▁ < openssl / ssl . h > ▁# include ▁ < openssl / x 509 v 3 . h > ▁# include ▁" st _ server . h " ▁# if def ▁HA VE _ C UNIT ▁# include ▁" CUnit / Basic . h " ▁# include ▁" CUnit / A utomat ed . h " ▁# endif ▁# if n def ▁W IN 32 ▁# define ▁US 1159_ CACERTS ▁" CA / estCA / cacert . crt " ▁# define ▁US 1159_ CACERT ▁" CA / estCA / cacert . crt " ▁# define ▁US 1159_ SERVER _ CERT ▁" CA / estCA / private / estserver cert and key . pem " ▁# define ▁US 1159_ SERVER _ KEY ▁" CA / estCA / private / estserver cert and key . pem " ▁# else ▁# define ▁US 1159_ CACERTS ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 1159_ CACERT ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 1159_ SERVER _ CERT ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# define ▁US 1159_ SERVER _ KEY ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# endif ▁# define ▁US 1159_ UID ▁" estuser " ▁# define ▁US 1159_ PWD ▁" estpwd " ▁# define ▁US 1159_ SERVER _ PORT ▁1589 7 ▁# define ▁US 1159_ SERVER _ IP ▁"127.0.0.1" ▁# define ▁US 1159_ ATTR _ POP _ ONLY ▁" MA s GCS qGS Ib 3 DQEJBw == \0" ▁# define ▁US 1159_ ATTR _ CN _ ONLY ▁" MA UGA 1 UEAw == \0" ▁# define ▁US 1159_ ATTR _ TEST ▁" MHE GBysGAQEBARY wI g YDiDcBMR sT GV Bhc nNl IF NF VC Bhc yA yL jk 5 OS 4 xIGRhdGE w LA YDiDcCMS UGA 4 g 3 AwYDiDcEE xlQ YXJ z ZSB T RV QgY XMg Mi 45 OTkuMiBkYXRhBg Ur g QQ AI gYDVQQD BggqhkjOPQQDA g == \0" ▁extern ▁EST _ CTX ▁* ectx ; ▁static ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁static ▁int ▁cacerts _ len ▁= ▁0; ▁static ▁char ▁* attrs ; ▁static ▁un signed ▁char ▁* ▁handle _ csrattrs _ request ▁( int ▁* csr _ len , ▁char ▁* path _ seg , ▁void ▁* app _ data ) ▁{ ▁un signed ▁char ▁* csr _ data ; ▁* csr _ len ▁= ▁str len ( attrs ); ▁csr _ data ▁= ▁malloc (* csr _ len ▁+ ▁1); ▁strncpy ( ( char ▁*) ▁csr _ data , ▁attrs , ▁* csr _ len ); ▁csr _ data [ * csr _ len ] ▁= ▁0; ▁return ▁( csr _ data ); ▁} ▁static ▁void ▁us 1159_ clean ▁( void ) ▁{ ▁} ▁int ▁us 1159_ start _ server ▁( ) ▁{ ▁int ▁rv ▁= ▁0; ▁/* ▁* ▁Start ▁an ▁EST ▁server ▁a cting ▁as ▁the ▁CA ▁*/ ▁rv ▁= ▁st _ start ( US 1159_ SERVER _ PORT , ▁US 1159_ SERVER _ CERT , ▁US 1159_ SERVER _ KEY , ▁" estrealm ", ▁US 1159_ CACERT , ▁" CA / trustedcerts . crt ", ▁" CA / est Example CA . cnf ", ▁0, ▁// ▁manual ▁enroll ▁0, ▁// ▁disable ▁PoP ▁0); ▁// ▁ ecdhe ▁nid ▁info ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁ printf (" \ nU nable ▁to ▁start ▁EST ▁server ▁for ▁US 1159. \ n "); ▁return ▁rv ; ▁} ▁st _ enable _ csrattr _ enforce (); ▁rv ▁= ▁est _ set _ csr _ cb ( ectx , ▁& handle _ csrattrs _ request ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁ printf (" \ nU nable ▁to ▁set ▁EST ▁CSR ▁Attributes ▁callback ▁for ▁US 1159. \ n "); ▁return ▁( rv ); ▁} ▁SL EEP (1); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁initialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁allocate ▁data ▁or ▁open ▁any ▁* ▁resource s ▁required ▁for ▁all ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 1159_ init _ suite ▁( void ) ▁{ ▁int ▁rv ; ▁us 1159_ clean (); ▁ printf ( ▁"\ n Start ing ▁server ▁for ▁CSR ▁attributes ▁enforce ment ▁ unit ▁tests ▁( US 1159 ) . \ n "); ▁attrs ▁= ▁US 1159_ ATTR _ POP _ ONLY ; ▁est _ init _ logger ( EST _ LOG _ L VL _ INFO , ▁NULL ); ▁/* ▁* ▁Rea d ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( US 1159_ CACERTS , ▁& cacerts ); ▁if ▁( cacerts _ len ▁ < = ▁0) ▁{ ▁return ▁1; ▁} ▁/* ▁* ▁Start ▁an ▁instance ▁of ▁the ▁EST ▁server ▁with ▁* ▁automatic ▁enrollment ▁enabled . ▁*/ ▁rv ▁= ▁us 1159_ start _ server (); ▁return ▁rv ; ▁} ▁void ▁us 1159_ stop _ server ▁( ) ▁{ ▁st _ stop (); ▁SL EEP ( 2 ); ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁uninitialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁de allocate ▁data ▁or ▁close ▁any ▁* ▁resource s ▁that ▁we re ▁used ▁for ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 1159_ destroy _ suite ▁( void ) ▁{ ▁us 1159_ stop _ server (); ▁free ( cacerts ); ▁ printf (" C ompleted ▁CSR ▁attributes ▁enforce ment ▁ unit ▁tests . \ n "); ▁return ▁0; ▁} ▁static ▁E VP _ PKEY ▁* ▁generate _ private _ key ▁( void ) ▁{ ▁RSA ▁* rsa ▁= ▁RSA _ new (); ▁B IG NUM ▁* bn ▁= ▁ BN _ new (); ▁E VP _ PKEY ▁* pkey ; ▁/* ▁* ▁create ▁an ▁RSA ▁ keypair ▁and ▁assign ▁them ▁to ▁a ▁ PKEY ▁and ▁return ▁it . ▁*/ ▁ BN _ set _ word ( bn , ▁0 x 1000 1); ▁RSA _ generate _ key _ ex ( rsa , ▁1024 , ▁bn , ▁NULL ); ▁pkey ▁= ▁E VP _ PKEY _ new (); ▁if ▁( pkey ▁ == ▁NULL ) ▁{ ▁ printf (" \ n Error ▁allocat ing ▁ PKEY ▁structure ▁for ▁new ▁key ▁pair \ n "); ▁return ▁NULL ; ▁} ▁if ▁(! E VP _ PKEY _ set 1 _ RSA ( pkey , ▁rsa )) ▁{ ▁ printf (" \ n Error ▁assign ing ▁RSA ▁key ▁pair ▁to ▁ PKEY ▁structure \ n "); ▁return ▁NULL ; ▁} ▁RSA _ free ( rsa ); ▁ BN _ free ( bn ); ▁return ▁( pkey ); ▁} ▁/* ▁* ▁This ▁function ▁generate s ▁an ▁EC ▁public / private ▁key ▁* ▁pair ▁that ▁will ▁be ▁used ▁with ▁the ▁certificate ▁* ▁we ▁provision . ▁*/ ▁static ▁E VP _ PKEY ▁* ▁generate _ ec _ private _ key ▁( int ▁nid ) ▁{ ▁EC _ KEY ▁* eckey ; ▁EC _ GROUP ▁* group ▁= ▁NULL ; ▁BIO ▁* out ; ▁un signed ▁char ▁* tdata ; ▁un signed ▁char ▁* key _ data ; ▁int ▁key _ len ; ▁BIO ▁* keyin ; ▁E VP _ PKEY ▁* new _ priv _ key ; ▁int ▁as n 1 _ flag ▁= ▁O PEN SSL _ EC _ NAME D _ CU RVE ; ▁point _ conversion _ form _ t ▁form ▁= ▁PO INT _ CON VERSION _ UN COMP RESS ED ; ▁/* ▁* ▁Generat e ▁an ▁EC ▁key ▁*/ ▁group ▁= ▁EC _ GROUP _ new _ by _ curve _ name ( nid ▁/* NID _ X 9 _ 62 _ prime 256 v 1 */ ); ▁EC _ GROUP _ set _ asn 1 _ flag ( group , ▁as n 1 _ flag ); ▁EC _ GROUP _ set _ point _ conversion _ form ( group , ▁form ); ▁eckey ▁= ▁EC _ KEY _ new (); ▁EC _ KEY _ set _ group ( eckey , ▁group ); ▁if ▁(! EC _ KEY _ generate _ key ( eckey )) ▁{ ▁ printf (" Failed ▁to ▁generate ▁EC ▁key \ n "); ▁return ▁NULL ; ▁} ▁out ▁= ▁BIO _ new ( BIO _ s _ mem () ); ▁PEM _ write _ bio _ EC PK Parameters ( out , ▁group ); ▁PEM _ write _ bio _ EC PrivateKey ( out , ▁eckey , ▁NULL , ▁NULL , ▁0, ▁NULL , ▁NULL ); ▁key _ len ▁= ▁BIO _ get _ mem _ data ( out , ▁& tdata ); ▁key _ data ▁= ▁malloc ( key _ len ▁+ ▁1); ▁memcpy ( key _ data , ▁t data , ▁key _ len ); ▁EC _ KEY _ free ( eckey ); ▁BIO _ free ( out ); ▁/* ▁* ▁read ▁it ▁back ▁in ▁to ▁an ▁E VP _ PKEY ▁struct ▁*/ ▁keyin ▁= ▁BIO _ new ( BIO _ s _ mem () ); ▁keyin ▁= ▁BIO _ new _ mem _ buf ( key _ data , ▁key _ len ); ▁/* ▁* ▁This ▁reads ▁in ▁the ▁private ▁key ▁file , ▁which ▁is ▁expected ▁to ▁be ▁a ▁PEM ▁* ▁encoded ▁private ▁key . ▁If ▁using ▁DER ▁encoding , ▁you ▁woul d ▁invoke ▁* ▁d 2 i _ PrivateKey _ bio () ▁instead . ▁*/ ▁new _ priv _ key ▁= ▁PEM _ read _ bio _ PrivateKey ( keyin , ▁NULL , ▁NULL , ▁NULL ); ▁if ▁( new _ priv _ key ▁ == ▁NULL ) ▁{ ▁ printf (" \ n Error ▁while ▁reading ▁PEM ▁encoded ▁private ▁key \ n "); ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁NULL ; ▁} ▁BIO _ free ( keyin ); ▁free ( key _ data ); ▁return ▁( new _ priv _ key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁with ▁the ▁* ▁client ▁provid ing ▁no ▁CSR ▁attributes ▁other ▁than ▁* ▁c hallengePassword . ▁The ▁enroll ▁should ▁succeed . ▁*/ ▁static ▁void ▁us 1159_ test 1 ▁( void ) ▁{ ▁EST _ CTX ▁* ctx ; ▁E VP _ PKEY ▁* key ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁ LOG _ FUNC _ NM ▁; ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ctx , ▁" Test ▁ 1", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁ Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁ == ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ctx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ctx ); ▁} ▁/* ▁* ▁This ▁routine ▁build s ▁a ▁PKCS 10 ▁CSR . ▁*/ ▁static ▁EST _ ERROR ▁populate _ x 509_ request ▁( X 509_ REQ ▁* req , ▁E VP _ PKEY ▁* pkey , ▁char ▁* cn ) ▁{ ▁X 509_ NAME ▁* subj ; ▁int ▁rv ; ▁/* ▁set up ▁version ▁number ▁*/ ▁rv ▁= ▁X 509_ REQ _ set _ version ( req , ▁0 L ); ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ X 509_ VER ); ▁} ▁/* ▁* ▁Add ▁Common ▁Name ▁entry ▁*/ ▁subj ▁= ▁X 509_ REQ _ get _ subject _ name ( req ); ▁rv ▁= ▁X 509_ NAME _ add _ entry _ by _ txt ( subj , ▁" CN ", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁cn , ▁-1, ▁-1, ▁0); ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ X 509_ CN ); ▁} ▁/* ▁* ▁Add ▁s erial ▁number ▁Name ▁entry ▁*/ ▁rv ▁= ▁X 509_ NAME _ add _ entry _ by _ NID ( subj , ▁NID _ s erialNumber , ▁MB STRING _ ASC , ▁( un signed ▁char *) ▁"1234 9999 B ", ▁-1, ▁-1, ▁0); ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ X 509_ CN ); ▁} ▁/* ▁* ▁Add ▁all ▁the ▁other ▁attributes ▁that ▁the ▁server ▁will ▁be ▁expecting ▁*/ ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁" 1.3.6.1.1.1.1.22 ", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" dummy mac ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁"2.999. 1", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" dummy ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁"2.999. 2 ", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" dummy ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁"2.999. 3 ", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" dummy ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁"2.999. 4", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" dummy ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁"1.2.840.10045. 2.1 ", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" 1.3.132.0.34 ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁"1.2.840.10045. 4.3.3 ", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁"", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ NID ( req , ▁NID _ s erialNumber , ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁"123456789 A ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁/* ▁* ▁Set ▁the ▁public ▁key ▁on ▁the ▁request ▁*/ ▁rv ▁= ▁X 509_ REQ _ set _ pub key ( req , ▁pkey ); ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁return ▁( EST _ ERR _ X 509_ PUBKEY ); ▁} ▁X 509_ REQ _ print _ fp ( stderr , ▁req ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁# if ▁0 ▁/* ▁* ▁Sign ▁an ▁X 509 ▁certificate ▁request ▁using ▁the ▁digest ▁and ▁the ▁key ▁passed . ▁* ▁Returns ▁OpenSSL ▁error ▁code ▁from ▁X 509_ REQ _ sign _ ctx (); ▁*/ ▁static ▁int ▁sign _ X 509_ REQ ( X 509_ REQ ▁* x , ▁E VP _ PKEY ▁* pkey , ▁const ▁E VP _ MD ▁* md ) ▁{ ▁int ▁rv ; ▁E VP _ PKEY _ CTX ▁* pkctx ▁= ▁NULL ; ▁E VP _ MD _ CTX ▁ mctx ; ▁E VP _ MD _ CTX _ init (& mctx ); ▁if ▁(! E VP _ Digest Sign Init (& mctx , ▁& pkctx , ▁md , ▁NULL , ▁pkey )) ▁{ ▁return ▁0; ▁} ▁/* ▁* ▁E ncode ▁using ▁DER ▁( ASN .1) ▁* ▁* ▁We ▁have ▁to ▁set ▁the ▁modifi ed ▁flag ▁on ▁the ▁X 509_ REQ ▁because ▁* ▁OpenSSL ▁keep s ▁a ▁cached ▁copy ▁of ▁the ▁DER ▁encoded ▁data ▁in ▁some ▁* ▁cases . ▁Set ting ▁this ▁flag ▁tell s ▁OpenSSL ▁to ▁run ▁the ▁ASN ▁* ▁encoding ▁again ▁ra ther ▁than ▁using ▁the ▁cached ▁copy . ▁*/ ▁x -> req _ info -> enc . modifi ed ▁= ▁1; ▁rv ▁= ▁X 509_ REQ _ sign _ ctx ( x , ▁& mctx ); ▁E VP _ MD _ CTX _ cleanup (& mctx ); ▁return ▁( rv ); ▁} ▁# endif ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁with ▁the ▁* ▁client ▁provid ing ▁all ▁the ▁required ▁CSR ▁attributes ▁in ▁* ▁the ▁CSR . ▁The ▁enroll ▁should ▁succeed . ▁*/ ▁static ▁void ▁us 1159_ test 2 ▁( void ) ▁{ ▁X 509_ REQ ▁* req ▁= ▁NULL ; ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁ LOG _ FUNC _ NM ▁; ▁/* ▁* ▁This ▁sets ▁the ▁full ▁list ▁of ▁attributes ▁on ▁the ▁server ▁*/ ▁attrs ▁= ▁US 1159_ ATTR _ TEST ; ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ ec _ private _ key ( NID _ secp 384 r 1); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁req ▁= ▁X 509_ REQ _ new (); ▁CU _ ASSERT ( req ▁ != ▁NULL ); ▁rv ▁= ▁populate _ x 509_ request ( req , ▁key , ▁" Test ▁2 "); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁# if ▁0 ▁/* ▁* ▁Sign ▁the ▁request ▁*/ ▁ossl _ rv ▁= ▁sign _ X 509_ REQ ( req , ▁key , ▁E VP _ sha 256() ); ▁CU _ ASSERT ( ossl _ rv ▁ == ▁0); ▁if ▁(! ossl _ rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁} ▁# endif ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll _ csr ( ctx , ▁req , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁ Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁ == ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ctx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( req ) ▁X 509_ REQ _ free ( req ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁with ▁the ▁* ▁client ▁provid ing ▁all ▁the ▁required ▁CSR ▁attributes ▁in ▁* ▁the ▁CSR ▁ex cept ▁that ▁the ▁521 - bit ▁curve ▁is ▁used . ▁The ▁enroll ▁* ▁should ▁fail ▁since ▁the ▁server ▁CSR ▁attrs ▁specif y ▁to ▁* ▁use ▁the ▁ 384 - bit ▁curve . ▁*/ ▁static ▁void ▁us 1159_ test 3 ▁( void ) ▁{ ▁X 509_ REQ ▁* req ▁= ▁NULL ; ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁ LOG _ FUNC _ NM ▁; ▁/* ▁* ▁This ▁sets ▁the ▁full ▁list ▁of ▁attributes ▁on ▁the ▁server ▁*/ ▁attrs ▁= ▁US 1159_ ATTR _ TEST ; ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ ec _ private _ key ( NID _ secp 521 r 1); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁req ▁= ▁X 509_ REQ _ new (); ▁CU _ ASSERT ( req ▁ != ▁NULL ); ▁rv ▁= ▁populate _ x 509_ request ( req , ▁key , ▁" Test ▁ 3 "); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll _ csr ( ctx , ▁req , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ HTTP _ BAD _ REQ ); ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( req ) ▁X 509_ REQ _ free ( req ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁with ▁the ▁* ▁client ▁provid ing ▁all ▁the ▁required ▁CSR ▁attributes ▁in ▁* ▁the ▁CSR ▁ex cept ▁that ▁SHA - 384 ▁is ▁used ▁for ▁the ▁* ▁signature . ▁The ▁enroll ▁should ▁fail ▁since ▁the ▁server ▁* ▁CSR ▁attrs ▁require ▁SHA -256 . ▁*/ ▁static ▁void ▁us 1159_ test 4 ▁( void ) ▁{ ▁X 509_ REQ ▁* req ▁= ▁NULL ; ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁ LOG _ FUNC _ NM ▁; ▁/* ▁* ▁This ▁sets ▁the ▁full ▁list ▁of ▁attributes ▁on ▁the ▁server ▁*/ ▁attrs ▁= ▁US 1159_ ATTR _ TEST ; ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ ec _ private _ key ( NID _ secp 384 r 1); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁req ▁= ▁X 509_ REQ _ new (); ▁CU _ ASSERT ( req ▁ != ▁NULL ); ▁rv ▁= ▁populate _ x 509_ request ( req , ▁key , ▁" Test ▁ 3 "); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Change ▁to ▁SHA - 384 ▁for ▁the ▁signature ▁*/ ▁rv ▁= ▁est _ client _ set _ sign _ digest ( ctx , ▁NID _ sha 384 ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll _ csr ( ctx , ▁req , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ HTTP _ BAD _ REQ ); ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( req ) ▁X 509_ REQ _ free ( req ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁when ▁the ▁* ▁server ▁has ▁no ▁CSR ▁attributes ▁configured ▁to ▁only ▁* ▁require ▁the ▁CommonName . ▁The ▁CSR ▁attributes ▁on ▁* ▁the ▁server ▁are ▁configured ▁through ▁the ▁static ▁API , ▁* ▁not ▁the ▁callback . ▁*/ ▁static ▁void ▁us 1159_ test 10 ▁( void ) ▁{ ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁ LOG _ FUNC _ NM ▁; ▁/* ▁* ▁Disabl e ▁the ▁CSR ▁attr ▁callback ▁on ▁the ▁server ▁context ▁*/ ▁rv ▁= ▁est _ set _ csr _ cb ( ectx , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁C onfigure ▁the ▁static ▁CSR ▁attributes ▁value ▁*/ ▁rv ▁= ▁est _ server _ init _ csrattrs ( ectx , ▁US 1159_ ATTR _ CN _ ONLY , ▁str len ( US 1159_ ATTR _ CN _ ONLY ) ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Enroll ▁a ▁new ▁cert ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ctx , ▁" Test ▁ 10", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁with ▁the ▁* ▁client ▁provid ing ▁all ▁the ▁required ▁CSR ▁attributes ▁in ▁* ▁the ▁CSR . ▁The ▁client ▁also ▁provide s ▁a ▁large ▁* ▁qua ntity ▁of ▁a dditional ▁attri utes . ▁*/ ▁static ▁void ▁us 1159_ test 20 ▁( void ) ▁{ ▁X 509_ REQ ▁* req ▁= ▁NULL ; ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁int ▁i ; ▁char ▁t _ attr _ str [ 50 ]; ▁ LOG _ FUNC _ NM ▁; ▁/* ▁* ▁This ▁sets ▁the ▁full ▁list ▁of ▁attributes ▁on ▁the ▁server ▁*/ ▁attrs ▁= ▁US 1159_ ATTR _ TEST ; ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ ec _ private _ key ( NID _ secp 384 r 1); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁req ▁= ▁X 509_ REQ _ new (); ▁CU _ ASSERT ( req ▁ != ▁NULL ); ▁rv ▁= ▁populate _ x 509_ request ( req , ▁key , ▁" Test ▁20 "); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁J am ▁another ▁25 ▁attributes ▁into ▁the ▁request ▁* ▁We ▁c ould ▁do ▁more , ▁but ▁this ▁cause s ▁a ▁failure ▁on ▁the ▁EST ▁server ▁when ▁* ▁base 64 ▁decoding ▁the ▁CSR ▁du e ▁to ▁a ▁safe C ▁constraint . ▁The ▁max ▁string ▁* ▁size ▁in ▁safe C ▁defaults ▁to ▁4096 ▁bytes . ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁ < ▁25 ; ▁i ++) ▁{ ▁s printf ( t _ attr _ str , ▁"2. 899. % d ", ▁i ); ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁t _ attr _ str , ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" whatever ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁} ▁} ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll _ csr ( ctx , ▁req , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁ Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁ == ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ctx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( req ) ▁X 509_ REQ _ free ( req ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁with ▁the ▁* ▁client ▁provid ing ▁all ▁the ▁required ▁CSR ▁attributes ▁in ▁* ▁the ▁CSR . ▁The ▁client ▁also ▁provide s ▁an ▁attribute ▁with ▁* ▁a ▁ very ▁long ▁name ▁and ▁value . ▁*/ ▁static ▁void ▁us 1159_ test 21 ▁( void ) ▁{ ▁X 509_ REQ ▁* req ▁= ▁NULL ; ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁ LOG _ FUNC _ NM ▁; ▁/* ▁* ▁This ▁sets ▁the ▁full ▁list ▁of ▁attributes ▁on ▁the ▁server ▁*/ ▁attrs ▁= ▁US 1159_ ATTR _ TEST ; ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ ec _ private _ key ( NID _ secp 384 r 1); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁req ▁= ▁X 509_ REQ _ new (); ▁CU _ ASSERT ( req ▁ != ▁NULL ); ▁rv ▁= ▁populate _ x 509_ request ( req , ▁key , ▁" Test ▁21 "); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Add ▁an ▁attribute ▁with ▁a ▁long ▁value ▁*/ ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁"2.993.8 ", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁" This ▁is ▁an ▁attribute ▁with ▁a ▁ very ▁long ▁value ▁that ▁c ould ▁potential ly ▁cause ▁a ▁problem ▁on ▁the ▁EST ▁server . ▁ 01234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 67890123456789" , ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁} ▁/* ▁* ▁Add ▁an ▁attribute ▁with ▁a ▁long ▁name ▁*/ ▁rv ▁= ▁X 509_ REQ _ add 1 _ attr _ by _ txt ( req , ▁"2.993.8 . 82 8 .85 .8 142.9999.2.1883. 2.993.8 . 82 8 .85 .8 142.9999.2.1883. 2.993.8 . 82 8 .85 .8 142.9999.2.1883. 2.993.8 . 82 8 .85 .8 142.9999.2.1883. 2.993.8 . 82 8 .85 .8 142.9999.2.1883. 7", ▁MB STRING _ ASC , ▁( const ▁un signed ▁char *) ▁"0123456789 ", ▁-1) ; ▁CU _ ASSERT ( rv ▁ != ▁0); ▁if ▁(! rv ) ▁{ ▁ ERR _ print _ errors _ fp ( stderr ); ▁} ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll _ csr ( ctx , ▁req , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁ Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁ == ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ctx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( req ) ▁X 509_ REQ _ free ( req ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁when ▁the ▁* ▁server ▁has ▁no ▁CSR ▁attributes ▁configured ▁with ▁* ▁PoP ▁enabled . ▁*/ ▁static ▁void ▁us 1159_ test 50 ▁( void ) ▁{ ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁ LOG _ FUNC _ NM ▁; ▁st _ enable _ pop (); ▁/* ▁* ▁Disabl e ▁the ▁CSR ▁attr ▁callback ▁on ▁the ▁server ▁context ▁*/ ▁rv ▁= ▁est _ set _ csr _ cb ( ectx , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ ec _ private _ key ( NID _ secp 384 r 1); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ force _ pop ( ctx ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Enroll ▁a ▁new ▁cert ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ctx , ▁" Test ▁50 ", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁* ▁This ▁test ▁attempts ▁does ▁a ▁simple ▁enroll ▁when ▁the ▁* ▁server ▁has ▁no ▁CSR ▁attributes ▁configured ▁with ▁* ▁PoP ▁disabled . ▁*/ ▁static ▁void ▁us 1159_ test 51 ▁( void ) ▁{ ▁E VP _ PKEY ▁* key ▁= ▁NULL ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁int ▁rv ; ▁EST _ CTX ▁* ctx ▁= ▁NULL ; ▁ LOG _ FUNC _ NM ▁; ▁st _ disable _ pop (); ▁/* ▁* ▁Disabl e ▁the ▁CSR ▁attr ▁callback ▁on ▁the ▁server ▁context ▁*/ ▁rv ▁= ▁est _ set _ csr _ cb ( ectx , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ ec _ private _ key ( NID _ secp 384 r 1); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ctx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁CU _ ASSERT ( ctx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ctx , ▁US 1159_ UID , ▁US 1159_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ctx , ▁US 1159_ SERVER _ IP , ▁US 1159_ SERVER _ PORT , ▁NULL ); ▁/* ▁* ▁Enroll ▁a ▁new ▁cert ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ctx , ▁" Test ▁ 5 1", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( ctx ) ▁est _ destroy ( ctx ); ▁if ▁( key ) ▁E VP _ PKEY _ free ( key ); ▁} ▁/* ▁The ▁main () ▁function ▁for ▁setting ▁up ▁and ▁running ▁the ▁tests . ▁* ▁Returns ▁a ▁CU E _ SUCCESS ▁on ▁successful ▁running , ▁another ▁* ▁ CUnit ▁error ▁code ▁on ▁failure . ▁*/ ▁int ▁us 1159_ add _ suite ▁( void ) ▁{ ▁# if def ▁HA VE _ C UNIT ▁CU _ pSuite ▁pSuite ▁= ▁NULL ; ▁/* ▁add ▁a ▁suite ▁to ▁the ▁ registry ▁*/ ▁pSuite ▁= ▁CU _ add _ suite (" us 1159_ csr _ attr _ enforce ", ▁us 1159_ init _ suite , ▁us 1159_ destroy _ suite ); ▁if ▁( NULL ▁ == ▁pSuite ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁/* ▁add ▁the ▁tests ▁to ▁the ▁suite ▁*/ ▁/* ▁NOTE ▁- ▁OR DER ▁IS ▁ IMPORTANT ▁- ▁MUST ▁TEST ▁f read () ▁ AFTER ▁f printf () ▁*/ ▁if ▁( ( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" No ▁attributes ▁required ▁w / pop ", ▁us 1159_ test 1)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" All ▁attributes ▁provided ▁w / pop ", ▁us 1159_ test 2)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" EC ▁public ▁key ▁wro ng ▁curve ▁w / pop ", ▁us 1159_ test 3)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" Wr ong ▁has h ▁algorithm ▁in ▁signature ▁w / pop ", ▁us 1159_ test 4)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" CN ▁only ▁using ▁static ▁config ▁w / pop ", ▁us 1159_ test 10)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" A ▁lo t ▁of ▁attributes ▁w / pop ", ▁us 1159_ test 20 )) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" L ong ▁attribute ▁w / pop ", ▁us 1159_ test 2 1)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" No ▁CSR ▁attrs ▁on ▁server ▁w / pop ", ▁us 1159_ test 50)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" No ▁CSR ▁attrs ▁on ▁server ▁w / o ▁pop ", ▁us 1159_ test 5 1)) ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁return ▁CU E _ SUCCESS ; ▁# endif ▁}