▁/* -- ---------------- ---------------- ---------------- ---------------- ▁* ▁us 1883. c ▁- ▁ Unit ▁Test s ▁for ▁User ▁Stor y ▁ 1883 ▁- ▁E nable ▁token ▁auth ▁mode ▁for ▁* ▁the ▁EST ▁Client . ▁* ▁* ▁March , ▁2015 ▁* ▁* ▁Copy right ▁( c ) ▁2015 , ▁2016 ▁by ▁ cisco ▁S ystems , ▁Inc . ▁* ▁All ▁ right s ▁ reserved . ▁* -- ---------------- ---------------- ---------------- ---------------- ▁*/ ▁# include ▁ < std io . h > ▁# if n def ▁W IN 32 ▁# include ▁ < uni std . h > ▁# endif ▁# include ▁ < est . h > ▁# include ▁ < curl / curl . h > ▁# include ▁" curl _ util s . h " ▁# include ▁" test _ util s . h " ▁# include ▁" st _ server . h " ▁# include ▁ < openssl / ssl . h > ▁# if def ▁HA VE _ C UNIT ▁# include ▁" CUnit / Basic . h " ▁# include ▁" CUnit / A utomat ed . h " ▁# endif ▁# include ▁ < errno . h > ▁static ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁static ▁int ▁cacerts _ len ▁= ▁0; ▁# define ▁US 1883_ SERVER _ IP ▁"127.0.0.1" ▁# define ▁US 1883_ TCP _ PORT ▁ 29001 ▁/* ▁* ▁The ▁following ▁CSR ▁was ▁ generated ▁using ▁the ▁following ▁openssl ▁command ▁and ▁then ▁* ▁using ▁cat ▁on ▁the ▁rsa . req ▁file : ▁* ▁* ▁openssl ▁req ▁- new key ▁rsa : 2048 ▁- key out ▁rsa key . pem ▁- key form ▁PEM ▁- out ▁rsa . req ▁- out form ▁PEM ▁*/ ▁# define ▁US 1883_ PKCS 10_ RSA 2048 ▁" MIIC v TCCAa U CAQAw e DEL MAkG A 1 UEB h MCV VM x CzA J BgNVBA g MAk 5 DM Qw wC gYDVQQ H \ nDANSVFAxE j AQ BgNVBAoMC VJ TQW Nl cn Rj bz EM MA oGA 1 UEC wwD cnN h MR AwDgYDV QQD \ nDA d yc 2 EgZG 9 lMR o wGA YJKoZIhvcNAQkBFg ty c 2 FA ZG 9 l Lm Nvb T CCASIwDQYJKoZI \ n hvcNAQEBBQADgg EPADCCAQoCggEBA N 6 pC TB rK 7 T 0 29 Bg a nq 0 QH XH y NL 8 op v xc 7 JY \ n Xa Qz 39 R 3 J 9 BoB E 72 XZ 0 QX sB tU EY GNh HO La IS ASN zs 2 ZK Wp vM HJ W mP YN t 39 OC i 48 Y \ n FO gL Db An 83 mA OK Sf c ML bi bC c sh 4 HO l haa F rWs kRT As ew 16 MU Oz Fu 6 vB kw / A hI 82 J \ nK PY ws 0 dY Ox uW FI gE 1 HL + m / gpl bz q 7 Fr BI d rq k NL + dd gy Xo Dd 5 Nu LM JG DAK 7 vB 1 Ww \ n 9/ Ba w /6 Ai 9 V 5 ps ye 1 v 8 f WD r 6 HW 2 gg 9 X n VtM wB 4 pC g 1 rl 1 l SY stum T GY bM 6 cx Jy we \ nL uM nD jj 1 Zw D sZ 1 wI Xa BA XZa x EIS / rX OX 0 H nZ MT ef xY / gp Fk 1 Kv 0 CAwEAAa AAMA 0 G \ n CS qGS Ib 3 DQEBBQUA A 4 IBAQB 6 r Iw Nj E 8 l 8 jF KR 1 hQ / qe Sv ee / bAQ a 58 Ru fZ 4 US Ku K \ nl si h 7 UC f 8 b kQ vg lj nh s c Qu cz Ibn Jz eq EP qS dn om FW 6 Cv Mc / ah + Qf X 87 FG Y xJ gp wF \ n ut nU if j Di Zh rW gf / jN N bt H rke cw / Z ex 4 sZ / HC 127 j tE 3 cy E kD srA 1 oB xYR Cq 93 tC \ nW 2 q 9 PL Vm Ll yjc Z cS 1 KH VD 2 n ya 79 kfS 0 Y GM ocs w 1 Ge l VL 2 iz / oca yA S 5 GB 9 Y 2 s E Bw \ nR kC aY Zw 6 v hj 5 qj p CU zJ 3 E 8 Cl 3 VD 4 Kp i 3 j 3 bZGD JA 9 md md 8 j 5 Zy PY 56 e Au xa rW ssD \ n ci UM / h 6 E 99 w 3 tm rU Zb Ll jk jJ 7 pBX Rn ont gm 5 WZ mQ FH 4 X " ▁# define ▁US 1883_ PKCS 10_ 4096 _ REQ ▁" MIIE Z jCCA k 4 CAQAw IT EP MA 0 GA 1 UEAww GS kp U ZXN 0 MQ 4 wDAYDVQQ F EwU wMD AwMT CC \ n Ai IwDQYJKoZI hvcNAQEBBQADgg I PADCCA g oCgg IBA Lf LlH x qz Ob i K WD fX 8 sa Z 4 l 3 \ n 1 Jy rCP 4 xm yQ it Y 2 pI IGl Lv HT 7 t 1 WZ 0 LO 9 uo 0 uB 7 b /8 iG bX ki 8 Fg qS m 1 j RO e 5 lw CN \ nD Ih TJ dG 4 b 70 5 c 6 X mD 3 Mh 43 6 De 9 d 4 gz pj edA 2 q ur SI 9+ GV NV gU 0 Z OWJ Fu 9 g + y 3 i RH \ ndf s jO 9 u 0 E 2 Mf ZW WR 8 M 72 gB qz vb DD PN 4 BDw La 9 T kQ 2 Rsx f 3 h 2 d 7 bN 2 DNS h NS YX / d E \ n IX 89 d 9 uC 6 F eg s HQ xH IN UO dZ ze An 3 yu QM BU + F wo h El 9 Ub 8 Qu 9 gu b 2 MJ Ur YN RQ ni i 7\ ndu vq 5 / Uj khj NW zI h 7 LA b d aM +0 w Sm Ce 0 ju + wK ba yU ZZ kr qo VK 6 b WZ zF s 4 dY t n 95/ S \ n VV Ov 95 MD 5 D 1 E ok Xw 3 Ii h 7 GR Jy g tW n 5 e 4 / YO 68 LON BF 7 UE 24 vg Bw Eie F 6 J 0 b FA l xw \ n 15 s 7 pI alk GF 7 CU bit Rhb B 3 kT jG fU DR 8 Y pS sKd qx HN mW B XY 7 Z Vk 4 T 8 K 7 168 c NW SOL \ net Zp Tk 4 B to U JBn WP 8 Uq 38 YO i 63 89 U 24 gm ZtG pS pJ EE t Dy 1 MJ 8 Ha 4 PZ E / Vk Ft mU Wq \ n bE TOx 2 ku bGw c 9 v X vW fi 5 Bx E 2 Vv et GNs y 2 E QE ZP Vw s c Ya Cy 0 / yO 3 fu 06 coE tr 7 Ek r \ ng ap DDE zV ti P 9 N Pe 5 q 18 A zu + T 9 ngo Ox 3 Pq rCP G 1 BD N 6 z 1 Ue 2 tS Dd Ox KN FM NM wq YI n \ n ZP 9 MX h + tz 8 RaK vs cl v 9 J AgMBAAGg AD ANBgkq hk iG 9 w 0 BAQUFAAOCA gEA JM wZ 4 I UB \ n US H 5 wQ Bf s YT 4 Sx tKs Zt v un 6 QX 0 +7 j NM tz zQ U Oq O 79 Kx / D Kp zs Kx L Nv HK mF qc xA 7 g \ ng bE w Xk AP 5+ Va MD 92 Dg hcN jX Oq GK cl Zd m Gj 2 o RE qZ wz vT DR o 4 zP 1 yen 5 vg L / Yz 7 SA \ n x ze 8 wP g 2 W hlV 9+ qv kV Cp HN 3 E UI fO + rBg i 2 re o / vF 7 xq 5 CA U 4 U tQ 1 h 4 g Hax 67 Y ww 8\ n Jm y py GG a 0 ad 0 Z 8 ru ic lI / Qt lu AD Ux y 1 YM 0 Up 2 FC 0 s 7 j 72 xz r Rp El 1 f Pl Oi / b Fa Zp \ n sr 4 z ll O pw nR d xv ff XO 7 gXt XV I r 4 I HV HN Wj 6 km Dz yk 0 ov at 2 M s 5 aGU c MD N 6 Jm 8 K IB \ n NB VH 5 Fg k BV QOP S n gkw nE Oj 0 R sa K SxT 5 E fmO xm 9 pC r AE 3 r N d VO gO 4 t 8 wZ 6 DQ Uq ye / \ n BU dm gXt W oG s KI g 8 oR 5 HA W BER 8 yw / qd i Rl BG gN / PK Zd p mYI 2 TE fZ vp / nX wG 7 Q Lj Gx \ n s j 5 T We R KN gg hUC u 3 uF +1 s 0 R + gq gY 1 S 9 Gg iD S if L 7+ h + b XJ 4 nc yRG q + XP n rf Mi Rk B \ n eS yv 3 ky Ix t Zf AB 6 T jk Ub tV fo 2 Kr fq N xu 4 lb JY E 2 b 6 h s 1 L 6 t 7 YP h ju bz 9 a ES 7 w ES 7\ nk + ZZ PZ n / k / Gs qU ps WH n EFE vi 5 C 5 WP rn pv VN 6 rK h 0 fB + Au kGr S +9 EK 4 KN ZW fV / yf 8\ nX N 5 qW yO t gd 4 oL UU s gF DJ s qN h 6 A 1 ml mx 6 C nY =\ n " ▁# define ▁US 1883_ ENROLL _ URL _ BA ▁" http s ://127.0.0.1:290 01/ . well - known / est / simpleenroll " ▁# define ▁US 1883_ PKCS 10_ CT ▁" Content - Type : ▁application / pkcs 10" ▁# define ▁US 1883_ UIDPWD _ GOOD ▁" estuser : estpwd " ▁# if n def ▁W IN 32 ▁# define ▁US 1883_ CACERTS ▁" CA / estCA / cacert . crt " ▁# define ▁US 1883_ CACERT ▁" CA / estCA / cacert . crt " ▁# define ▁US 1883_ SERVER _ CERT ▁" CA / estCA / private / estserver cert and key . pem " ▁# define ▁US 1883_ SERVER _ KEY ▁" CA / estCA / private / estserver cert and key . pem " ▁# define ▁US 1883_ CLIENT _ CERT ▁" CA / estCA / private / estserver cert and key . pem " ▁# define ▁US 1883_ CLIENT _ KEY ▁" CA / estCA / private / estserver cert and key . pem " ▁# else ▁# define ▁US 1883_ CACERTS ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 1883_ CACERT ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 1883_ SERVER _ CERT ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# define ▁US 1883_ SERVER _ KEY ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# define ▁US 1883_ CLIENT _ CERT ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# define ▁US 1883_ CLIENT _ KEY ▁" CA \\ estCA \\ private / estserver cert and key . pem " ▁static ▁CR ITI CAL _ SE CTION ▁logger _ critical _ section ; ▁static ▁void ▁us 1883_ logger _ stderr ▁( char ▁* format , ▁va _ list ▁l ) ▁{ ▁E nter CriticalSection (& logger _ critical _ section ); ▁ vf printf ( stderr , ▁format , ▁l ); ▁f flu sh ( stderr ); ▁ Leav eCriticalSection (& logger _ critical _ section ); ▁} ▁# endif ▁static ▁void ▁us 1883_ clean ▁( void ) ▁{ ▁} ▁static ▁int ▁us 1883_ start _ server ▁( int ▁manual _ enroll , ▁int ▁nid ) ▁{ ▁int ▁rv ; ▁rv ▁= ▁st _ start ( US 1883_ TCP _ PORT , ▁" CA / estCA / private / estserver cert and key . pem ", ▁" CA / estCA / private / estserver cert and key . pem ", ▁" estrealm ", ▁" CA / estCA / cacert . crt ", ▁" CA / trustedcerts . crt ", ▁" CA / est Example CA . cnf ", ▁manual _ enroll , ▁0, ▁nid ); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁initialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁allocate ▁data ▁or ▁open ▁any ▁* ▁resource s ▁required ▁for ▁all ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 1883_ init _ suite ▁( void ) ▁{ ▁int ▁rv ; ▁# if def ▁W IN 32 ▁Initialize CriticalSection ▁(& logger _ critical _ section ); ▁est _ init _ logger ( EST _ LOG _ L VL _ INFO , ▁& us 1883_ logger _ stderr ); ▁# endif ▁/* ▁* ▁Rea d ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( US 1883_ CACERTS , ▁& cacerts ); ▁if ▁( cacerts _ len ▁ < = ▁0) ▁{ ▁return ▁1; ▁} ▁us 1883_ clean (); ▁/* ▁* ▁Start ▁an ▁instance ▁of ▁the ▁EST ▁server ▁with ▁* ▁automatic ▁enrollment ▁enabled . ▁*/ ▁rv ▁= ▁us 1883_ start _ server ( 0 , ▁0); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁uninitialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁de allocate ▁data ▁or ▁close ▁any ▁* ▁resource s ▁that ▁we re ▁used ▁for ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 1883_ destroy _ suite ▁( void ) ▁{ ▁st _ stop (); ▁free ( cacerts ); ▁return ▁0; ▁} ▁/* ▁* ▁C allback ▁function ▁passed ▁to ▁est _ client _ init () ▁*/ ▁static ▁int ▁client _ manual _ cert _ verify ▁( X 509 ▁* cur _ cert , ▁int ▁openssl _ cert _ error ) ▁{ ▁BIO ▁* bio _ err ; ▁bio _ err = BIO _ new _ fp ( stderr , BIO _ NO CLOSE ); ▁int ▁approve ▁= ▁0; ▁/* ▁* ▁Pr int ▁out ▁the ▁specific s ▁of ▁this ▁cert ▁*/ ▁ printf ("% s : ▁OpenSSL / EST ▁server ▁cert ▁verification ▁failed ▁with ▁the ▁following ▁error : ▁openssl _ cert _ error ▁= ▁% d ▁(% s ) \ n ", ▁ _ _ FUNCTION _ _ , ▁openssl _ cert _ error , ▁X 509_ verify _ cert _ error _ string ( openssl _ cert _ error ) ); ▁ printf (" Fail ing ▁Cert : \ n "); ▁X 509_ print _ fp ( stdout , cur _ cert ); ▁/* ▁* ▁ Next ▁call ▁print s ▁out ▁the ▁signature ▁which ▁can ▁be ▁used ▁as ▁the ▁fingerprint ▁* ▁This ▁fingerprint ▁can ▁be ▁checked ▁against ▁the ▁anti cip ated ▁value ▁to ▁determine ▁* ▁whether ▁or ▁not ▁the ▁server ' s ▁cert ▁should ▁be ▁approved . ▁*/ ▁X 509_ signature _ print ( bio _ err , ▁cur _ cert -> sig _ alg , ▁cur _ cert -> signature ); ▁if ▁( openssl _ cert _ error ▁ == ▁X 509_ V _ ERR _ U NABLE _ TO _ GET _ CRL ) ▁{ ▁approve ▁= ▁1; ▁} ▁BIO _ free ( bio _ err ); ▁return ▁approve ; ▁} ▁static ▁E VP _ PKEY ▁* ▁generate _ private _ key ▁( void ) ▁{ ▁RSA ▁* rsa ▁= ▁RSA _ new (); ▁B IG NUM ▁* bn ▁= ▁ BN _ new (); ▁E VP _ PKEY ▁* pkey ; ▁/* ▁* ▁create ▁an ▁RSA ▁ keypair ▁and ▁assign ▁them ▁to ▁a ▁ PKEY ▁and ▁return ▁it . ▁*/ ▁ BN _ set _ word ( bn , ▁0 x 1000 1); ▁RSA _ generate _ key _ ex ( rsa , ▁1024 , ▁bn , ▁NULL ); ▁pkey ▁= ▁E VP _ PKEY _ new (); ▁if ▁( pkey == NULL ) ▁{ ▁ printf (" \ n Error ▁allocat ing ▁ PKEY ▁structure ▁for ▁new ▁key ▁pair \ n "); ▁return ▁NULL ; ▁} ▁if ▁(! E VP _ PKEY _ set 1 _ RSA ( pkey , ▁rsa )) ▁{ ▁ printf (" \ n Error ▁assign ing ▁RSA ▁key ▁pair ▁to ▁ PKEY ▁structure \ n "); ▁return ▁NULL ; ▁} ▁RSA _ free ( rsa ); ▁ BN _ free ( bn ); ▁return ▁( pkey ); ▁} ▁# define ▁GOOD _ TOKEN ▁" WW 91 IGRv bid 0 IGhhdmUg dG 8 gaG 9 sb GVy IEkg a GVhc iB 5 b 3 U =" ▁# define ▁DI FFER ENT _ TOKEN ▁" V 2 VsbC wgSSd 2 ZSB nb 3 QgdG 8 gc nVuIH RvIG tl ZXAg Z nJvbSB oa WRpbicNCkFuZCBJJ 20 gYm 91 bmQgdG 8 ga 2 Vl c CBvb iBy a WRpbicNCkFuZCBJJ 3 Zl IGdv d CBvb mUgbW 9 yZSB zaW x 2 ZXIgZ G 9 sb GFy DQp CdX Q gSSdtIG 5 vdCB nb 2 5 u YSB s ZXQg J 2 Vt IGN hdG No IG 1 lLCB ub w 0 KT m 90 IGdv bm 5 hIG xld CA n ZW 0 gY 2 F 0 Y 2 g gdGhlIG 1 pZG 5 pZ 2 h 0 IHJpZ GVy " ▁# define ▁NULL _ TOKEN ▁NULL ; ▁# define ▁LONG _ TOKEN ▁" S SBj YW 4 ndCB hZ 3 Jl ZSB 0 byB ka XN hZ 3 Jl ZSANCk Zp Z 2 h 0 aW 5 nIG xpa 2 U gSSdtIG Zp Z 2 h 0 aW 5 n IGZvciB saW ZlI A 0 KV GhleS dyZSB vbm x 5 IHd v cm Rz IGJ 1 dCB 0 aGV 5 IGN 1 dCB sa WtlIG E gYmxh ZG UgDQp T d 2 luZ 2 luZyB 3 aWRlIH dp d Ggg YWxs IG 9 mIG 15 IG 1 pZ 2 h 0 IA 0 KDQp B aCB 5 ZWFoLCB JIG d 1 ZXN zIG l 0 J 3 MgY WxsI G 9 m IHRo YXQg Y 29 mZ mVl LCB 0 aGF 0 J 3 MgZ 290 IG 15 IG 1 p bmQg aW 4 g YSB 3 aG ly bC ANCkknbSBzdG l sbCB j dXN zaW 5 nIG FuZCB ia X Rj a GluZyB hbmQg d GhlcmUgY Wl uJ 3 Qgb m 9 ib 2 R 5 IGhlcmUg DQoNCk 9 oIHl lYW g sIHlvdSB kb 24 ndCB oYX Zl IHRvIG h vb Gxl ci BJIGh lY XI geW 91 IA 0 KSSdtI HN 0 YW 5 k aW 5 n IHJpZ 2 h 0 IGhlcmUg Ym Vz aWRlIH lvdSANCk 9 oL CA 5 O SBza GF kZ XMg b 2 Y gY 3 JhenksI E knbS A 5 O SBza GF kZ XMg b 2 Y gY 3 JhenkgDQp Dc mF 6 eSwg Y 3 JhenksI GN yY Xp 5 LCB jc mF 6 eSANC g 0 KU G 91 ci Bhbm 90 aGVy IGR yaW 5 r LCB tY WtlIG l 0 IG EgZG 91 Ymx l IGZvciB t ZSANCk 1 h eW Jl IEkg Y 2 Fu IGR yaW 5 r IHRoaXMg YX dh eSANCk l 0 J 3 M gbmV 2 ZXIgZ nVuIH d oZW 4 gdGhl eSB wd WxsI G 91 dCB 0 aGUg Z 3 VuI A 0 KQ mVh dCB 5 b 3 U gYmxh Y 2 s gYW 5 k IGJ s d WU s IGJv eSANC l lvdSB nb 3 R 0 YSBwYXk sIHlvdSB nb 3 R 0 YSBwYXk gDQoNCk 9 oLCB 3 aGVyZSB 0 aGUg aGV sbCB h bSB J Py BJIGh vc GUg YXQg b GVhc 3 QgSS BoY WQ gZnVuI A 0 KSSdtI HN 0 dW 1 ib GluZyB 0 aH JvdW do IE 5 ld yB P c mx lYW 5 zIG 9 oLCB 0 byB 0 aGUgc ml zaW 5 n IHN 1 b iAN Cg 0 KT 2 gge WV h aCwg eW 91 IGRv bid 0 IGhhdmUg dG 8 gaG 9 sb GVy IEkg a GVhc iB 5 b 3 UgDQp JJ 20 gc 3 Rhb mR pbmcg cml n aHQ g aGVyZSB i ZXN pZG U geW 91 IA 0 KT 2 gsI Dk 5 IHN oYW Rl cyB vZ iB jc mF 6 eSwg SSdtI Dk 5 IHN oYW Rl cyB vZ iB jc mF 6 eSANCk N yY Xp 5 LCB jc mF 6 eSwg Y 3 JhenksI GN yY Xp 5 IA 0 KDQp Mb 3 Jk IGhhdmUg b WV yY 3 kgb 24 gbW UgDQp Ob 3 Zl b nR hIG 51 ZXZ h IHRv bm 9 zIGR lIG xv Y 28 gDQoNCk kgb mVl ZCB zb 21 lIH B lY WNlLCB q dXN 0 IHN v bWUg cmV saWV m IA 0 KR nJvbSB 0 aGlzIH Z va WNlLCB r aWx saW 5 nIG 1 l IA 0 K WW 91 IHN 0 Y XJlIG F 0 IG 1 lLCB hbmQg eW 91 IGd s Y XJlIG F 0 IG 1 l IA 0 KQ Wxs IHRoaXMg c GF pbiB pdC dz IGF sbCB 0 aGUgc 2 F tZS wga XQ ncy BhbGwg aW 5 zYW 5 l IA 0 KK HlvdSB z ZW Up IA 0 KDQp J cyB 0 aGlzIH Jl YWxs eSB oYX Bw ZW 5 pbmcg b 3 IgZG lkIEkg bW Fr ZSB pdC BhbGwg d XA / IA 0 KSSdtI G JvdW 5 k IGZvciB D aGF 0 dGF ob 29 j aGV lIG 9 u IGEg dH Vy bm lw IHR yd WN r IA 0 K DQpPaC B 5 ZWFoLCB 5 b 3 U gZG 9 uJ 3 QgaG F 2 ZSB 0 byB ob 2 x s ZXIg SSBo ZWF y IHlvdS ANCkknbSBzdG FuZ GluZyB yaW do dCBo Z XJlIG Jlc 2 lkZSB 5 b 3 UgDQp P aCwg OTk gc 2 hh ZGV zIG 9 mIG N yY Xp 5 L CBJJ 20 g OTk gc 2 hh ZGV zIG 9 mIG N yY Xp 5 IA 0 KQ 3 JhenksI GN yY Xp 5 LCB jc mF 6 eSwg Y 3 Jhenk gDQoNCk Fo IHlvdS dyZSB jc mF 6 eSB 5 b 3 Un cmUgY 3 JhenkgDQp Ib 2 x kIG 15 IGZlZXQ s IGZlZXQ gdG 8 gdGhlIG Zp cmUgDQ p Zb 3 UgaG 9 s ZCB t eSB mZ WV 0 IHRv IHRo ZSB ma XJlI A 0 KSS Bu ZXZ lciB zYW lkIEkg d 2 Fz IGRv d 24 gd 2 l 0 aCB 5 b 3 U =" ▁char ▁* test _ token ▁= ▁" WW 91 IGRv bid 0 IGhhdmUg dG 8 gaG 9 sb GVy IEkg a GVhc iB 5 b 3 U =" ; ▁int ▁auth _ cred _ callback _ called ▁= ▁0; ▁int ▁auth _ cred _ force _ error ▁= ▁0; ▁/* ▁* ▁auth _ credentials _ token _ cb () ▁is ▁the ▁application ▁layer ▁callback ▁function ▁that ▁will ▁* ▁return ▁a ▁token ▁based ▁authentication ▁credential ▁when ▁called . ▁It ' s ▁registered ▁* ▁with ▁the ▁EST ▁Client ▁using ▁the ▁est _ client _ set _ auth _ cred _ cb (). ▁* ▁The ▁test ▁function ▁is ▁required ▁to ▁set ▁some ▁global ▁values ▁in ▁order ▁to ▁make ▁this ▁* ▁callback ▁operate ▁the ▁ way ▁that ▁the ▁test ▁case ▁wants . ▁* ▁- ▁auth _ cred _ force _ error ▁= ▁tell ▁this ▁function ▁to ▁force ▁a ▁response ▁code ▁error ▁* ▁- ▁test _ token ▁= ▁pointer ▁to ▁a ▁hard ▁code d ▁string ▁that ▁is ▁the ▁token ▁string ▁to ▁return ▁* ▁* ▁This ▁callback ▁must ▁provide ▁the ▁token ▁credentials ▁in ▁a ▁heap ▁based ▁buffer , ▁and ▁* ▁own er sh ip ▁of ▁that ▁buffer ▁is ▁implicitly ▁transferred ▁to ▁the ▁E T ▁client ▁library ▁upon ▁* ▁return . ▁*/ ▁EST _ HTTP _ AUTH _ C RED _ RC ▁auth _ credentials _ token _ cb ( EST _ HTTP _ AUTH _ HDR ▁* auth _ credentials ) ▁{ ▁char ▁* token _ ptr ▁= ▁NULL ; ▁int ▁token _ len ▁= ▁0; ▁CU _ ASSERT ( auth _ credentials -> mode ▁ == ▁AUTH _ TOKEN ); ▁/* ▁* ▁report ▁that ▁the ▁callback ▁has ▁been ▁called . ▁*/ ▁auth _ cred _ callback _ called ▁= ▁1; ▁/* ▁* ▁Se e ▁if ▁the ▁test ▁is ▁requesting ▁to ▁force ▁an ▁error ▁response ▁code ▁from ▁the ▁* ▁callback ▁*/ ▁if ▁( auth _ cred _ force _ error ) ▁{ ▁return ( EST _ HTTP _ AUTH _ C RED _ NOT _ AVAILABLE ); ▁} ▁if ▁( auth _ credentials -> mode ▁ == ▁AUTH _ TOKEN ) ▁{ ▁/* ▁* ▁If ▁the ▁test _ token ▁is ▁set ▁to ▁anything , ▁then ▁we ▁need ▁to ▁allocate ▁* ▁space ▁from ▁the ▁heap ▁and ▁copy ▁in ▁the ▁value . ▁*/ ▁if ▁( test _ token ▁ != ▁NULL ) ▁{ ▁token _ len ▁= ▁str len ( test _ token ); ▁/* ▁use ▁str len () ▁so ▁that ▁the ▁string ▁can ▁be ▁as ▁large ▁as ▁needed ▁to ▁test ▁the ▁EST ▁client ▁*/ ▁if ▁( token _ len ▁ == ▁0) ▁{ ▁ printf (" \ n Error ▁determin ing ▁length ▁of ▁token ▁string ▁used ▁for ▁credentials \ n "); ▁return ▁EST _ HTTP _ AUTH _ C RED _ NOT _ AVAILABLE ; ▁} ▁token _ ptr ▁= ▁malloc ( token _ len +1 ); ▁if ▁( token _ ptr ▁ == ▁NULL ) { ▁ printf (" \ n Error ▁allocat ing ▁token ▁string ▁used ▁for ▁credentials \ n "); ▁return ▁EST _ HTTP _ AUTH _ C RED _ NOT _ AVAILABLE ; ▁} ▁strncpy ( token _ ptr , ▁test _ token , ▁str len ( test _ token ) ); ▁token _ ptr [ token _ len ] ▁= ▁'\0'; ▁} ▁/* ▁* ▁If ▁we ▁made ▁it ▁this ▁far , ▁token _ ptr ▁is ▁point ing ▁to ▁a ▁string ▁* ▁containing ▁the ▁token ▁to ▁be ▁returned . ▁As sign ▁it ▁and ▁return ▁success ▁*/ ▁auth _ credentials -> auth _ token ▁= ▁token _ ptr ; ▁return ▁( EST _ HTTP _ AUTH _ C RED _ SUCCESS ); ▁} ▁return ▁( EST _ HTTP _ AUTH _ C RED _ NOT _ AVAILABLE ); ▁} ▁/* ▁* ▁auth _ credentials _ basic _ cb () ▁is ▁the ▁same ▁as ▁the ▁token ▁based ▁one ▁above , ▁but ▁* ▁instead ▁returns ▁the ▁basic ▁credentials ▁of ▁userid ▁and ▁password ▁*/ ▁EST _ HTTP _ AUTH _ C RED _ RC ▁auth _ credentials _ basic _ cb ( EST _ HTTP _ AUTH _ HDR ▁* auth _ credentials ) ▁{ ▁CU _ ASSERT ( auth _ credentials -> mode ▁ == ▁AUTH _ BASIC ); ▁/* ▁* ▁report ▁that ▁the ▁callback ▁has ▁been ▁called . ▁*/ ▁auth _ cred _ callback _ called ▁= ▁1; ▁/* ▁* ▁Se e ▁if ▁the ▁test ▁is ▁requesting ▁to ▁force ▁an ▁error ▁response ▁code ▁from ▁the ▁* ▁callback ▁*/ ▁if ▁( auth _ cred _ force _ error ) ▁{ ▁return ( EST _ HTTP _ AUTH _ C RED _ NOT _ AVAILABLE ); ▁} ▁if ▁( auth _ credentials -> mode ▁ == ▁AUTH _ BASIC ) ▁{ ▁auth _ credentials -> user ▁= ▁malloc ( sizeof (" estuser ") ); ▁strncpy ( auth _ credentials -> user , ▁" estuser ", ▁sizeof (" estuser ") ); ▁auth _ credentials -> pwd ▁= ▁malloc ( sizeof (" estpwd ") ); ▁strncpy ( auth _ credentials -> pwd , ▁" estpwd ", ▁sizeof (" estpwd ") ); ▁return ▁( EST _ HTTP _ AUTH _ C RED _ SUCCESS ); ▁} ▁return ▁( EST _ HTTP _ AUTH _ C RED _ NOT _ AVAILABLE ); ▁} ▁/* ▁* ▁auth _ credentials _ digest _ cb () ▁is ▁the ▁same ▁as ▁the ▁basic ▁based ▁one ▁above , ▁but ▁* ▁instead ▁ver fie s ▁that ▁the ▁auth _ mode ▁passed ▁is ▁digest ▁*/ ▁EST _ HTTP _ AUTH _ C RED _ RC ▁auth _ credentials _ digest _ cb ( EST _ HTTP _ AUTH _ HDR ▁* auth _ credentials ) ▁{ ▁CU _ ASSERT ( auth _ credentials -> mode ▁ == ▁AUTH _ DIGEST ); ▁/* ▁* ▁report ▁that ▁the ▁callback ▁has ▁been ▁called . ▁*/ ▁auth _ cred _ callback _ called ▁= ▁1; ▁/* ▁* ▁Se e ▁if ▁the ▁test ▁is ▁requesting ▁to ▁force ▁an ▁error ▁response ▁code ▁from ▁the ▁* ▁callback ▁*/ ▁if ▁( auth _ cred _ force _ error ) ▁{ ▁return ( EST _ HTTP _ AUTH _ C RED _ NOT _ AVAILABLE ); ▁} ▁if ▁( auth _ credentials -> mode ▁ == ▁AUTH _ DIGEST ) ▁{ ▁auth _ credentials -> user ▁= ▁malloc ( sizeof (" estuser ") ); ▁strncpy ( auth _ credentials -> user , ▁" estuser ", ▁sizeof (" estuser ") ); ▁auth _ credentials -> pwd ▁= ▁malloc ( sizeof (" estpwd ") ); ▁strncpy ( auth _ credentials -> pwd , ▁" estpwd ", ▁sizeof (" estpwd ") ); ▁return ▁( EST _ HTTP _ AUTH _ C RED _ SUCCESS ); ▁} ▁return ▁( EST _ HTTP _ AUTH _ C RED _ NOT _ AVAILABLE ); ▁} ▁/* ▁* ▁Test ▁the ▁est _ client _ set _ auth _ cred _ cb ▁API ▁* ▁* ▁E xe rc ise ▁the ▁parameters ▁*/ ▁static ▁void ▁us 1883_ test 1 ▁( void ) ▁{ ▁EST _ ERROR ▁e _ rc ; ▁EST _ CTX ▁* ectx ▁= ▁NULL ; ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁For got ▁to ▁specif y ▁any ▁parameters . ▁Context ▁will ▁* ▁get ▁caught ▁*/ ▁e _ rc ▁= ▁est _ client _ set _ auth _ cred _ cb ( NULL , ▁NULL ); ▁CU _ ASSERT ( e _ rc ▁ == ▁EST _ ERR _ NO _ CTX ); ▁/* ▁* ▁valid ▁call ▁*/ ▁e _ rc ▁= ▁est _ client _ set _ auth _ cred _ cb ( ectx , ▁auth _ credentials _ token _ cb ); ▁CU _ ASSERT ( e _ rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁attempt ▁to ▁reset ▁the ▁callback ▁function ▁*/ ▁e _ rc ▁= ▁est _ client _ set _ auth _ cred _ cb ( ectx , ▁NULL ); ▁CU _ ASSERT ( e _ rc ▁ == ▁EST _ ERR _ NONE ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁us 1883_ simple _ enroll () ▁is ▁used ▁by ▁test ▁cases ▁to ▁perform ▁a ▁simple ▁enroll . ▁*/ ▁static ▁void ▁us 1883_ simple _ enroll ▁( char ▁* cn , ▁char ▁* server , ▁EST _ ERROR ▁expected _ enroll _ rv , ▁auth _ credentials _ cb ▁callback ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁EST _ ERROR ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁EST _ ERROR ▁e _ rc ; ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁e _ rc ▁= ▁est _ client _ set _ auth _ cred _ cb ( ectx , ▁callback ); ▁CU _ ASSERT ( e _ rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁server , ▁US 1883_ TCP _ PORT , ▁NULL ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁cn , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁expected _ enroll _ rv ); ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁Perform ▁a ▁simple ▁enroll ▁first ▁in ▁order ▁to ▁get ▁a ▁valid ▁cert , ▁then ▁perform ▁the ▁* ▁reenroll . ▁The ▁simple ▁enroll ▁needs ▁to ▁be ▁successful , ▁so ▁it ' s ▁currently ▁* ▁being ▁done ▁using ▁basic ▁mode ▁because ▁the ▁EST ▁server ▁does ▁not ▁yet ▁have ▁token ▁* ▁based ▁support . ▁* ▁PDB ▁NOTE : ▁O nce ▁the ▁server ▁side ▁token ▁support ▁have ▁been ▁implemented , ▁this ▁* ▁this ▁function ▁can ▁optional ly ▁be ▁updated ▁to ▁do ▁token ▁mode ▁on ▁the ▁first ▁enroll , ▁* ▁but ▁it ' s ▁not ▁absolute ly ▁necessary ▁since ▁the ▁purpose ▁of ▁this ▁is ▁to ▁test ▁reenroll ▁* ▁and ▁the ▁initial ▁enroll ▁is ▁needed ▁just ▁to ▁get ▁the ▁cert . ▁*/ ▁static ▁void ▁us 1883_ simple _ reenroll ▁( char ▁* cn , ▁char ▁* server , ▁EST _ ERROR ▁expected _ enroll _ rv , ▁auth _ credentials _ cb ▁callback ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁EST _ ERROR ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁PKCS 7 ▁* p 7 ▁= ▁NULL ; ▁BIO ▁* b 64, ▁* out ; ▁X 509 ▁* cert ▁= ▁NULL ; ▁ST ACK _ OF ( X 509) ▁* certs ▁= ▁NULL ; ▁int ▁i ; ▁EST _ ERROR ▁e _ rc ; ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁M ake ▁sure ▁the ▁server ▁is ▁currently ▁in ▁BASIC ▁auth ▁mode ▁*/ ▁st _ enable _ http _ basic _ auth (); ▁e _ rc ▁= ▁est _ client _ set _ auth _ cred _ cb ( ectx , ▁auth _ credentials _ basic _ cb ); ▁CU _ ASSERT ( e _ rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁server , ▁US 1883_ TCP _ PORT , ▁NULL ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁cn , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁ Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁ == ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ectx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁ == ▁EST _ ERR _ NONE ); ▁} ▁est _ destroy ( ectx ); ▁ectx ▁= ▁NULL ; ▁/* ▁* ▁C reate ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁No w ▁that ▁we ▁have ▁the ▁cert , ▁switch ▁the ▁server ▁over ▁to ▁token ▁mode ▁*/ ▁st _ enable _ http _ token _ auth (); ▁e _ rc ▁= ▁est _ client _ set _ auth _ cred _ cb ( ectx , ▁callback ); ▁CU _ ASSERT ( e _ rc ▁ == ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁server , ▁US 1883_ TCP _ PORT , ▁NULL ); ▁/* ▁* ▁ And ▁attempt ▁a ▁reenroll ▁while ▁in ▁token ▁mode ▁* ▁* ▁Convert ▁the ▁cert ▁to ▁an ▁X 509. ▁Be ▁warn ed ▁this ▁is ▁* ▁pur e ▁hack ery . ▁* ▁PDB : ▁This ▁conversion ▁code ▁come s ▁from ▁other ▁test ▁cases . ▁*/ ▁b 64 ▁= ▁BIO _ new ( BIO _ f _ base 64 () ); ▁out ▁= ▁BIO _ new _ mem _ buf ( new _ cert , ▁pkcs 7_ len ); ▁out ▁= ▁BIO _ push ( b 64, ▁out ); ▁p 7 ▁= ▁d 2 i _ PKCS 7_ bio ( out , NULL ); ▁CU _ ASSERT ( p 7 ▁ != ▁NULL ); ▁BIO _ free _ all ( out ); ▁i = OBJ _ obj 2 nid ( p 7-> type ); ▁switch ▁( i ) ▁{ ▁case ▁NID _ pkcs 7_ signed : ▁certs ▁= ▁p 7-> d . sign -> cert ; ▁break ; ▁case ▁NID _ pkcs 7_ signed And Enveloped : ▁certs ▁= ▁p 7-> d . signed _ and _ e nveloped -> cert ; ▁break ; ▁default : ▁break ; ▁} ▁CU _ ASSERT ( certs ▁ != ▁NULL ); ▁if ▁(! certs ) ▁return ; ▁/* ▁our ▁new ▁cert ▁should ▁be ▁the ▁one ▁and ▁only ▁* ▁cert ▁in ▁the ▁pkcs 7 ▁blob . ▁We ▁should n ' t ▁have ▁to ▁* ▁it erate ▁through ▁the ▁full ▁list ▁to ▁find ▁it . ▁*/ ▁cert ▁= ▁sk _ X 509_ value ( certs , ▁0); ▁CU _ ASSERT ( cert ▁ != ▁NULL ); ▁/* ▁* ▁PDB ▁NOTE : ▁At ▁the ▁moment , ▁this ▁is ▁expected ▁to ▁fail ▁since ▁* ▁the ▁server ▁does ▁not ▁yet ▁understand ▁requests ▁with ▁token ▁authentication . ▁* ▁O nce ▁188 4 ▁is ▁complete , ▁the ▁below ▁ ASSERT ▁will ▁begin ▁to ▁fail ▁and ▁will ▁need ▁* ▁to ▁be ▁changed ▁to ▁a ▁pass ing ▁response . ▁*/ ▁rv ▁= ▁est _ client _ reenroll ( ectx , ▁cert , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁ == ▁expected _ enroll _ rv ); ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁Test 2 ▁- ▁Application ▁layer ▁did ▁not ▁register ▁callback , ▁ca using ▁an ▁* ▁HTTP ▁ Ai thentication ▁header ▁with ▁an ▁empty ▁token ▁credential ▁* ▁* ▁In ▁this ▁test , ▁* ▁- ▁application ▁layer ▁DO ES ▁NOT ▁register ▁its ▁callback ▁* ▁- ▁EST ▁Client ▁get s ▁the ▁challenge , ▁finds ▁no ▁callback ▁registered ▁and ▁goes ▁with ▁* ▁the ▁credentials ▁it ▁has ▁stored ▁in ▁the ▁Context , ▁which ▁is ▁nothing . ▁* ▁NOTE : ▁This ▁is ▁the ▁ way ▁the ▁pre loaded ▁credential ▁flow ▁has ▁al way s ▁worked . ▁* ▁- ▁enroll ▁is ▁sent ▁with ▁no ▁token ▁credentials ▁* ▁- ▁server ▁fails ▁and ▁does ▁not ▁give ▁a ▁certificate ▁*/ ▁static ▁void ▁us 1883_ test 2 ▁( void ) ▁{ ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁S witch ▁the ▁server ▁over ▁to ▁Token ▁mode . ▁* ▁* ▁NOTE : ▁I ▁see ▁the ▁equ ival ent ▁calls ▁being ▁made ▁in ▁numer ous ▁places , ▁and ▁* ▁it ' s ▁ probab ly ▁safe ▁in ▁a ▁test ▁setting , ▁but ▁it ' s ▁da nger ous ▁to ▁change ▁* ▁this ▁on ▁the ▁fly ▁in ▁an ▁operation al ▁setting . ▁A lso ▁note , ▁no ▁return ▁code ▁* ▁for ▁any ▁of ▁these ▁set / enable ▁functions . ▁*/ ▁st _ enable _ http _ token _ auth (); ▁/* ▁* ▁tell ▁the ▁server ▁which ▁token ▁to ▁check ▁against . ▁*/ ▁st _ set _ token ( GOOD _ TOKEN ); ▁auth _ cred _ callback _ called ▁= ▁0; ▁auth _ cred _ force _ error ▁= ▁0; ▁/* ▁* ▁Set ▁up ▁the ▁EST ▁Client ▁and ▁have ▁it ▁perform ▁a ▁simple ▁enroll . ▁* ▁Pass ▁no ▁callback ▁function ▁to ▁c atch ▁and ▁handle ▁the ▁request ▁for ▁a ▁token ▁auth . ▁* ▁* ▁enroll ▁be tter ▁fail ▁du e ▁to ▁missing ▁credentials ▁*/ ▁us 1883_ simple _ enroll (" TC 1883- 2 ", ▁US 1883_ SERVER _ IP , ▁EST _ ERR _ AUTH _ FAIL , ▁NULL ); ▁/* ▁* ▁callback ▁was ▁ne ver ▁registered , ▁so ▁it ▁should ▁not ▁have ▁been ▁invoked . ▁*/ ▁CU _ ASSERT ( auth _ cred _ callback _ called ▁ == ▁0); ▁} ▁/* ▁* ▁Test 3 ▁- ▁Application ▁layer ▁register s ▁callback , ▁B UT ▁does ▁not ▁set ▁any ▁* ▁credentials ▁when ▁invoked . ▁S ame ▁result ▁as ▁previous ▁test ▁* ▁* ▁In ▁this ▁test , ▁* ▁- ▁application ▁layer ▁register s ▁its ▁callback ▁* ▁- ▁EST ▁Client ▁get s ▁the ▁challenge , ▁calls ▁the ▁callback , ▁get s ▁back ▁an ▁* ▁empty ▁credential ▁structure ▁and ▁end s ▁up ▁send ing ▁an ▁HTTP ▁auth ▁header ▁* ▁with ▁no ▁credentials . ▁* ▁NOTE : ▁This ▁is ▁the ▁ way ▁the ▁pre loaded ▁credential ▁flow ▁has ▁al way s ▁worked . ▁* ▁- ▁enroll ▁is ▁sent ▁with ▁no ▁token ▁credentials ▁* ▁- ▁server ▁fails ▁and ▁does ▁not ▁give ▁a ▁certificate ▁*/ ▁static ▁void ▁us 1883_ test 3 ▁( void ) ▁{ ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁S witch ▁the ▁server ▁over ▁to ▁Token ▁mode . ▁* ▁* ▁NOTE : ▁I ▁see ▁the ▁equ ival ent ▁calls ▁being ▁made ▁in ▁numer ous ▁places , ▁and ▁* ▁it ' s ▁ probab ly ▁safe ▁in ▁a ▁test ▁setting , ▁but ▁it ' s ▁da nger ous ▁to ▁change ▁* ▁this ▁on ▁the ▁fly ▁in ▁an ▁operation al ▁setting . ▁A lso ▁note , ▁no ▁return ▁code ▁* ▁for ▁any ▁of ▁these ▁set / enable ▁functions . ▁*/ ▁st _ enable _ http _ token _ auth (); ▁/* ▁* ▁tell ▁the ▁server ▁which ▁token ▁to ▁check ▁against . ▁*/ ▁st _ set _ token ( GOOD _ TOKEN ); ▁auth _ cred _ callback _ called ▁= ▁0; ▁auth _ cred _ force _ error ▁= ▁0; ▁test _ token ▁= ▁NULL _ TOKEN ; ▁/* ▁* ▁Set ▁up ▁the ▁EST ▁Client ▁and ▁have ▁it ▁perform ▁a ▁simple ▁enroll . ▁* ▁Register ▁the ▁token ▁based ▁callback , ▁but ▁set ▁it ▁so ▁that ▁it ▁passes ▁back ▁no ▁token . ▁* ▁* ▁enroll ▁be tter ▁fail ▁du e ▁to ▁missing ▁credentials ▁*/ ▁us 1883_ simple _ enroll (" TC 1883- 3 ", ▁US 1883_ SERVER _ IP , ▁EST _ ERR _ AUTH _ FAIL , ▁auth _ credentials _ token _ cb ); ▁/* ▁* ▁callback ▁should ▁have ▁been ▁called ▁*/ ▁CU _ ASSERT ( auth _ cred _ callback _ called ▁ == ▁1); ▁} ▁/* ▁* ▁Test 4 ▁- ▁Go od ▁token ▁is ▁sent ▁to ▁server ▁and ▁is ▁accepted . ▁Cert ▁should ▁* ▁be ▁ generated ▁and ▁returned ▁* ▁* ▁In ▁this ▁test , ▁* ▁- ▁application ▁layer ▁register s ▁its ▁callback ▁and ▁responds ▁with ▁a ▁valid ▁token ▁* ▁- ▁enroll ▁is ▁sent ▁with ▁this ▁token ▁credential ▁* ▁- ▁server ▁is ▁set ▁to ▁match ▁on ▁this ▁token ▁and ▁send ▁back ▁a ▁cert ▁*/ ▁static ▁void ▁us 1883_ test 4 ▁( void ) ▁{ ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁S witch ▁the ▁server ▁over ▁to ▁Token ▁mode . ▁* ▁* ▁NOTE : ▁I ▁see ▁the ▁equ ival ent ▁calls ▁being ▁made ▁in ▁numer ous ▁places , ▁and ▁* ▁it ' s ▁ probab ly ▁safe ▁in ▁a ▁test ▁setting , ▁but ▁it ' s ▁da nger ous ▁to ▁change ▁* ▁this ▁on ▁the ▁fly ▁in ▁an ▁operation al ▁setting . ▁A lso ▁note , ▁no ▁return ▁code ▁* ▁for ▁any ▁of ▁these ▁set / enable ▁functions . ▁*/ ▁st _ enable _ http _ token _ auth (); ▁/* ▁* ▁tell ▁the ▁server ▁which ▁token ▁to ▁check ▁against . ▁*/ ▁st _ set _ token ( GOOD _ TOKEN ); ▁auth _ cred _ callback _ called ▁= ▁0; ▁auth _ cred _ force _ error ▁= ▁0; ▁test _ token ▁= ▁GOOD _ TOKEN ; ▁/* ▁* ▁Set ▁up ▁the ▁EST ▁Client ▁and ▁have ▁it ▁perform ▁a ▁simple ▁enroll . ▁* ▁* ▁Enroll ▁should ▁succeed . ▁*/ ▁us 1883_ simple _ enroll (" TC 1883- 4", ▁US 1883_ SERVER _ IP , ▁EST _ ERR _ NONE , ▁auth _ credentials _ token _ cb ); ▁/* ▁* ▁callback ▁should ▁have ▁been ▁called ▁*/ ▁CU _ ASSERT ( auth _ cred _ callback _ called ▁ == ▁1); ▁} ▁/* ▁* ▁Test ▁EST ▁client ▁receiv ing ▁a ▁token ▁auth ▁challenge ▁* ▁* ▁In ▁this ▁test , ▁the ▁application ▁layer ▁register s ▁its ▁callback ▁and ▁responds ▁* ▁with ▁a ▁fail ing ▁return ▁code . ▁*/ ▁static ▁void ▁us 1883_ test 5 ▁( void ) ▁{ ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁S witch ▁the ▁server ▁over ▁to ▁Token ▁mode . ▁* ▁* ▁NOTE : ▁I ▁see ▁the ▁equ ival ent ▁calls ▁being ▁made ▁in ▁numer ous ▁places , ▁and ▁* ▁it ' s ▁ probab ly ▁safe ▁in ▁a ▁test ▁setting , ▁but ▁it ' s ▁da nger ous ▁to ▁change ▁* ▁this ▁on ▁the ▁fly ▁in ▁an ▁operation al ▁setting . ▁A lso ▁note , ▁no ▁return ▁code ▁* ▁for ▁any ▁of ▁these ▁set / enable ▁functions . ▁*/ ▁st _ enable _ http _ token _ auth (); ▁auth _ cred _ callback _ called ▁= ▁0; ▁/* ▁For ce ▁the ▁callback ▁to ▁give ▁a ▁fail ing ▁return ▁code ▁*/ ▁auth _ cred _ force _ error ▁= ▁1; ▁test _ token ▁= ▁GOOD _ TOKEN ; ▁/* ▁* ▁Set ▁up ▁the ▁EST ▁Client ▁and ▁have ▁it ▁perform ▁a ▁simple ▁enroll . ▁* ▁* ▁enroll ▁be tter ▁fail ▁du e ▁to ▁credentials ▁not ▁being ▁suppl ied ▁by ▁the ▁application ▁layer ▁* ▁and ▁event ual ▁failure ▁at ▁the ▁server ▁du e ▁to ▁missing ▁credentials . ▁*/ ▁us 1883_ simple _ enroll (" TC 1883- 5 ", ▁US 1883_ SERVER _ IP , ▁EST _ ERR _ AUTH _ FAIL , ▁auth _ credentials _ token _ cb ); ▁/* ▁* ▁callback ▁should ▁have ▁been ▁called ▁*/ ▁CU _ ASSERT ( auth _ cred _ callback _ called ▁ == ▁1); ▁} ▁/* ▁* ▁Test 6 ▁- ▁ Sanity ▁test ▁BASIC ▁auth ▁mode ▁* ▁* ▁In ▁this ▁test , ▁* ▁- ▁server ▁into ▁BASIC ▁mode ▁* ▁- ▁Client ▁application ▁register s ▁its ▁BASIC ▁based ▁callback ▁* ▁- ▁Client ▁should ▁send ▁the ▁ estuser / estpwd ▁credentials ▁and ▁get ▁a ▁cert ▁*/ ▁static ▁void ▁us 1883_ test 6 ▁( void ) ▁{ ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁S witch ▁the ▁server ▁over ▁to ▁BASIC ▁mode . ▁* ▁* ▁NOTE : ▁I ▁see ▁the ▁equ ival ent ▁calls ▁being ▁made ▁in ▁numer ous ▁places , ▁and ▁* ▁it ' s ▁ probab ly ▁safe ▁in ▁a ▁test ▁setting , ▁but ▁it ' s ▁da nger ous ▁to ▁change ▁* ▁this ▁on ▁the ▁fly ▁in ▁an ▁operation al ▁setting . ▁A lso ▁note , ▁no ▁return ▁code ▁* ▁for ▁any ▁of ▁these ▁set / enable ▁functions . ▁*/ ▁st _ enable _ http _ basic _ auth (); ▁auth _ cred _ callback _ called ▁= ▁0; ▁auth _ cred _ force _ error ▁= ▁0; ▁/* ▁* ▁Set ▁up ▁the ▁EST ▁Client ▁and ▁have ▁it ▁perform ▁a ▁simple ▁enroll . ▁* ▁Pass ▁a ▁callback ▁function ▁to ▁c atch ▁and ▁handle ▁the ▁request ▁for ▁a ▁token ▁auth . ▁* ▁* ▁enroll ▁should ▁pass ▁because ▁BASIC ▁mode ▁ fully ▁works . ▁M ake ▁sure ▁that ▁the ▁* ▁callback ▁is ▁called . ▁This ▁will ▁ensure ▁that ▁the ▁credentials ▁ca me ▁from ▁* ▁the ▁callback . ▁*/ ▁us 1883_ simple _ enroll (" TC 1883- 6 ", ▁US 1883_ SERVER _ IP , ▁EST _ ERR _ NONE , ▁auth _ credentials _ basic _ cb ); ▁/* ▁* ▁callback ▁should ▁have ▁been ▁called ▁*/ ▁CU _ ASSERT ( auth _ cred _ callback _ called ▁ == ▁1); ▁} ▁/* ▁* ▁Test 7 ▁- ▁M ake ▁sure ▁re - enroll ▁works ▁with ▁the ▁credential ▁callback ▁flow ▁* ▁to ▁obtain ▁credentials ▁* ▁* ▁In ▁this ▁test , ▁* ▁- ▁server ▁into ▁TOKEN ▁mode ▁* ▁- ▁Client ▁application ▁register s ▁its ▁TOKEN ▁based ▁callback ▁* ▁- ▁Client ▁should ▁send ▁the ▁valid ▁token ▁credential ▁and ▁get ▁a ▁cert ▁*/ ▁static ▁void ▁us 1883_ test 7 ▁( void ) ▁{ ▁ LOG _ FUNC _ NM ; ▁auth _ cred _ callback _ called ▁= ▁0; ▁auth _ cred _ force _ error ▁= ▁0; ▁test _ token ▁= ▁GOOD _ TOKEN ; ▁st _ enable _ http _ token _ auth (); ▁/* ▁* ▁tell ▁the ▁server ▁which ▁token ▁to ▁check ▁against . ▁*/ ▁st _ set _ token ( GOOD _ TOKEN ); ▁/* ▁* ▁Set ▁up ▁the ▁EST ▁Client ▁and ▁have ▁it ▁perform ▁a ▁simple ▁enroll . ▁* ▁* ▁Re - enroll ▁should ▁succeed . ▁* ▁*/ ▁us 1883_ simple _ reenroll (" TC 1883- 7", ▁US 1883_ SERVER _ IP , ▁EST _ ERR _ NONE , ▁auth _ credentials _ token _ cb ); ▁/* ▁* ▁callback ▁should ▁have ▁been ▁called ▁*/ ▁CU _ ASSERT ( auth _ cred _ callback _ called ▁ == ▁1); ▁} ▁/* ▁* ▁Test 7 ▁- ▁Token ▁credentials ▁that ▁are ▁too ▁long ▁* ▁* ▁In ▁this ▁test , ▁* ▁- ▁server ▁into ▁TOKEN ▁mode ▁and ▁to ld ▁to ▁match ▁against ▁the ▁GOOD ▁token ▁* ▁- ▁Client ▁application ▁register s ▁its ▁TOKEN ▁based ▁callback ▁and ▁is ▁to ld ▁to ▁* ▁give ▁back ▁a ▁token ▁that ▁is ▁ TOO ▁LONG . ▁* ▁- ▁Client ▁should ▁send ▁a ▁corrupted ▁token ▁that ▁does ▁not ▁match ▁the ▁GOOD ▁token . ▁*/ ▁static ▁void ▁us 1883_ test 8 ▁( void ) ▁{ ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁S witch ▁the ▁server ▁over ▁to ▁Token ▁mode . ▁* ▁* ▁NOTE : ▁I ▁see ▁the ▁equ ival ent ▁calls ▁being ▁made ▁in ▁numer ous ▁places , ▁and ▁* ▁it ' s ▁ probab ly ▁safe ▁in ▁a ▁test ▁setting , ▁but ▁it ' s ▁da nger ous ▁to ▁change ▁* ▁this ▁on ▁the ▁fly ▁in ▁an ▁operation al ▁setting . ▁A lso ▁note , ▁no ▁return ▁code ▁* ▁for ▁any ▁of ▁these ▁set / enable ▁functions . ▁*/ ▁st _ enable _ http _ token _ auth (); ▁/* ▁* ▁tell ▁the ▁server ▁which ▁token ▁to ▁check ▁against . ▁*/ ▁st _ set _ token ( GOOD _ TOKEN ); ▁auth _ cred _ callback _ called ▁= ▁0; ▁/* ▁For ce ▁the ▁callback ▁to ▁give ▁a ▁fail ing ▁return ▁code ▁*/ ▁auth _ cred _ force _ error ▁= ▁0; ▁test _ token ▁= ▁LONG _ TOKEN ; ▁/* ▁* ▁Set ▁up ▁the ▁EST ▁Client ▁and ▁have ▁it ▁perform ▁a ▁simple ▁enroll . ▁* ▁Pass ▁a ▁callback ▁function ▁to ▁c atch ▁and ▁handle ▁the ▁request ▁for ▁a ▁token ▁auth . ▁* ▁*/ ▁us 1883_ simple _ enroll (" TC 1883- 8 ", ▁US 1883_ SERVER _ IP , ▁EST _ ERR _ AUTH _ FAIL , ▁auth _ credentials _ token _ cb ); ▁/* ▁* ▁callback ▁should ▁have ▁been ▁called ▁*/ ▁CU _ ASSERT ( auth _ cred _ callback _ called ▁ == ▁1); ▁} ▁/* ▁* ▁Test 7 ▁- ▁Test ▁ DIGEST ▁mode ▁with ▁on ▁de mand ▁credential ▁flow ▁* ▁* ▁In ▁this ▁test , ▁* ▁- ▁server ▁into ▁ DIGEST ▁mode ▁* ▁NOTE : ▁This ▁mean s ▁the ▁server ▁is ▁expecting : ▁" estuser "/" estpwd " ▁and ▁" estrealm " ▁* ▁These ▁values ▁are ▁hard coded ▁into ▁data ▁in ▁the ▁st _ server , ▁so ▁st _ server ▁* ▁must ▁be ▁start ed ▁with ▁ estrealm ▁so ▁that ▁it ▁returns ▁this ▁realm ▁to ▁client ▁* ▁so ▁that ▁the ▁client ▁returns ▁it ▁in ▁its ▁request . ▁* ▁- ▁Client ▁application ▁register s ▁its ▁ DIGEST ▁based ▁callback ▁* ▁- ▁Client ▁should ▁send ▁a ▁valid ▁ DIGEST ▁and ▁get ▁a ▁cert ▁*/ ▁static ▁void ▁us 1883_ test 9 ▁( void ) ▁{ ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁S witch ▁the ▁server ▁over ▁to ▁ DIGEST ▁mode . ▁* ▁* ▁NOTE : ▁I ▁see ▁the ▁equ ival ent ▁calls ▁being ▁made ▁in ▁numer ous ▁places , ▁and ▁* ▁it ' s ▁ probab ly ▁safe ▁in ▁a ▁test ▁setting , ▁but ▁it ' s ▁da nger ous ▁to ▁change ▁* ▁this ▁on ▁the ▁fly ▁in ▁an ▁operation al ▁setting . ▁A lso ▁note , ▁no ▁return ▁code ▁* ▁for ▁any ▁of ▁these ▁set / enable ▁functions . ▁*/ ▁st _ enable _ http _ digest _ auth (); ▁auth _ cred _ callback _ called ▁= ▁0; ▁auth _ cred _ force _ error ▁= ▁0; ▁/* ▁* ▁Set ▁up ▁the ▁EST ▁Client ▁and ▁have ▁it ▁perform ▁a ▁simple ▁enroll . ▁* ▁Pass ▁a ▁callback ▁function ▁to ▁c atch ▁and ▁handle ▁the ▁request ▁for ▁a ▁token ▁auth . ▁* ▁* ▁enroll ▁should ▁pass ▁because ▁ DIGEST ▁mode ▁ fully ▁works . ▁M ake ▁sure ▁that ▁the ▁* ▁callback ▁is ▁called . ▁This ▁will ▁ensure ▁that ▁the ▁credentials ▁ca me ▁from ▁* ▁the ▁callback . ▁*/ ▁us 1883_ simple _ enroll (" TC 1883- 6 ", ▁US 1883_ SERVER _ IP , ▁EST _ ERR _ NONE , ▁auth _ credentials _ digest _ cb ); ▁/* ▁* ▁callback ▁should ▁have ▁been ▁called ▁*/ ▁CU _ ASSERT ( auth _ cred _ callback _ called ▁ == ▁1); ▁} ▁/* ▁* ▁Test 4 ▁- ▁Valid ▁token ▁is ▁provided ▁by ▁appli action ▁callback , ▁but ▁it ' s ▁the ▁ WRONG ▁* ▁token ▁* ▁* ▁In ▁this ▁test , ▁* ▁- ▁application ▁layer ▁register s ▁its ▁callback ▁and ▁responds ▁with ▁a ▁valid ▁token ▁* ▁- ▁Server ▁is ▁set ▁up ▁for ▁token ▁mode , ▁but ▁with ▁a ▁diff erent ▁token . ▁* ▁- ▁enroll ▁is ▁sent ▁with ▁this ▁token ▁credential ▁* ▁- ▁server ▁is ▁set ▁to ▁match ▁on ▁this ▁token ▁and ▁send ▁back ▁a ▁cert ▁*/ ▁static ▁void ▁us 1883_ test 10 ▁( void ) ▁{ ▁ LOG _ FUNC _ NM ; ▁/* ▁* ▁S witch ▁the ▁server ▁over ▁to ▁Token ▁mode . ▁* ▁* ▁NOTE : ▁I ▁see ▁the ▁equ ival ent ▁calls ▁being ▁made ▁in ▁numer ous ▁places , ▁and ▁* ▁it ' s ▁ probab ly ▁safe ▁in ▁a ▁test ▁setting , ▁but ▁it ' s ▁da nger ous ▁to ▁change ▁* ▁this ▁on ▁the ▁fly ▁in ▁an ▁operation al ▁setting . ▁A lso ▁note , ▁no ▁return ▁code ▁* ▁for ▁any ▁of ▁these ▁set / enable ▁functions . ▁*/ ▁st _ enable _ http _ token _ auth (); ▁/* ▁* ▁tell ▁the ▁server ▁which ▁token ▁to ▁check ▁against . ▁*/ ▁st _ set _ token ( DI FFER ENT _ TOKEN ); ▁auth _ cred _ callback _ called ▁= ▁0; ▁auth _ cred _ force _ error ▁= ▁0; ▁test _ token ▁= ▁GOOD _ TOKEN ; ▁/* ▁* ▁Set ▁up ▁the ▁EST ▁Client ▁and ▁have ▁it ▁perform ▁a ▁simple ▁enroll . ▁* ▁* ▁Enroll ▁should ▁ FAIL ▁because ▁the ▁token s ▁will ▁not ▁match ▁*/ ▁us 1883_ simple _ enroll (" TC 1883- 4", ▁US 1883_ SERVER _ IP , ▁EST _ ERR _ AUTH _ FAIL , ▁auth _ credentials _ token _ cb ); ▁/* ▁* ▁callback ▁should ▁have ▁been ▁called ▁*/ ▁CU _ ASSERT ( auth _ cred _ callback _ called ▁ == ▁1); ▁} ▁/* ▁The ▁main () ▁function ▁for ▁setting ▁up ▁and ▁running ▁the ▁tests . ▁* ▁Returns ▁a ▁CU E _ SUCCESS ▁on ▁successful ▁running , ▁another ▁* ▁ CUnit ▁error ▁code ▁on ▁failure . ▁*/ ▁int ▁us 1883_ add _ suite ▁( void ) ▁{ ▁# if def ▁HA VE _ C UNIT ▁CU _ pSuite ▁pSuite ▁= ▁NULL ; ▁/* ▁add ▁a ▁suite ▁to ▁the ▁ registry ▁*/ ▁pSuite ▁= ▁CU _ add _ suite (" us 1883_ tok _ auth _ client ", ▁us 1883_ init _ suite , ▁us 1883_ destroy _ suite ); ▁if ▁( NULL ▁ == ▁pSuite ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁/* ▁add ▁the ▁tests ▁to ▁the ▁suite ▁*/ ▁if ▁( ( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" parse ▁response ", ▁us 1883_ test 1)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" simple ▁enroll ▁no ▁cb ", ▁us 1883_ test 2)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" simple ▁enroll ▁reg ▁cb ▁no ▁token ", ▁us 1883_ test 3)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" simple ▁enroll ▁reg ▁cb ▁good ▁token ", ▁us 1883_ test 4)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" simple ▁enroll ▁reg ▁cb ▁bad ▁rc ", ▁us 1883_ test 5)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" simple ▁enroll ▁reg ▁cb ▁basic ▁mode ", ▁us 1883_ test 6)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" simple ▁re - enroll ▁reg ▁cb ▁good ▁token ", ▁us 1883_ test 7)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" simple ▁enroll ▁reg ▁cb ▁token ▁too ▁long ", ▁us 1883_ test 8)) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" simple ▁enroll ▁reg ▁cb ▁digest ▁mode ", ▁us 1883_ test 9 )) ▁|| ▁( NULL ▁ == ▁CU _ add _ test ( pSuite , ▁" simple ▁enroll ▁reg ▁cb ▁mismatche d ▁valid ▁token ", ▁us 1883_ test 10)) ▁ ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁return ▁CU E _ SUCCESS ; ▁# endif ▁}