▁/* ▁* ▁S ince ▁we ▁hi jack ▁the ▁OpenSSL ▁ BUF _ MEM ▁with ▁our ▁* ▁own ▁data , ▁this ▁utili ty ▁function ▁allow s ▁us ▁* ▁to ▁free ▁the ▁ BUF _ MEM ▁without ▁free ing ▁the ▁* ▁under ly ing ▁data . ▁*/ ▁static ▁void ▁est _ proxy _ free _ ossl _ bufmem ▁( BUF _ MEM ▁* b ) ▁{ ▁b -> data ▁= ▁NULL ; ▁ BUF _ MEM _ free ( b ); ▁} ▁/* ▁* ▁bsearch _ compare ▁is ▁used ▁by ▁the ▁bsearch ▁function ▁to ▁perform ▁the ▁* ▁comparison ▁of ▁the ▁no des ▁with in ▁the ▁client ▁context ▁array . ▁*/ ▁static ▁int ▁bsearch _ compare ( const ▁void ▁* pa , ▁const ▁void ▁* pb ) ▁{ ▁int ▁result ; ▁CLIENT _ CTX _ LU _ N ODE _ T ▁* a ▁= ▁( CLIENT _ CTX _ LU _ N ODE _ T ▁*) pa ; ▁CLIENT _ CTX _ LU _ N ODE _ T ▁* b ▁= ▁( CLIENT _ CTX _ LU _ N ODE _ T ▁*) pb ; ▁if ▁( a -> threadid ▁> ▁b -> threadid ) ▁result ▁= ▁1; ▁if ▁( a -> threadid ▁ < ▁b -> threadid ) ▁result ▁= ▁-1; ▁if ▁( a -> threadid ▁ == ▁b -> threadid ) ▁result ▁= ▁0; ▁return ▁( result ); ▁} ▁/* ▁* ▁get _ client _ ctx () ▁perform s ▁a ▁search ▁through ▁a ▁order ed ▁array . ▁* ▁The ▁key ▁for ▁the ▁search ▁is ▁the ▁current ▁thread ▁id ▁and ▁the ▁value ▁returned ▁* ▁is ▁the ▁client ▁context ▁that ' s ▁been ▁created ▁for ▁this ▁thread . ▁If ▁no ▁* ▁entry ▁exist s ▁in ▁the ▁array ▁for ▁this ▁thread ▁id , ▁a ▁new ▁one ▁is ▁created . ▁*/ ▁static ▁EST _ CTX ▁* get _ client _ ctx ▁( EST _ CTX ▁* p _ ctx ) ▁{ ▁EST _ CTX ▁* c _ ctx ▁= ▁NULL ; ▁EST _ ERROR ▁rv ; ▁un signed ▁long ▁cur _ threadid ▁= ▁0; ▁un signed ▁long ▁cur _ pid ▁= ▁GET PID (); ▁CLIENT _ CTX _ LU _ N ODE _ T ▁* found _ node ; ▁un signed ▁long ▁zero _ threadid ▁= ▁0 x 0 ; ▁CLIENT _ CTX _ LU _ N ODE _ T ▁* empty _ node ; ▁int ▁empty _ index ; ▁/* ▁* ▁Windows ▁TODO : ▁This ▁will ▁like ly ▁need ▁to ▁be ▁re placed ▁with ▁* ▁GetCurrent Th read Id () ▁* ▁In ▁addition , ▁this ▁is ▁real ly ▁return ing ▁a ▁pointer ▁to ▁an ▁op a que ▁value , ▁so ▁* ▁what ' s ▁being ▁used ▁here ▁is ▁typically ▁a ▁pointer ▁in ▁pthread ▁based ▁* ▁en vi ron ments ▁and ▁not ▁the ▁actual ▁pthread ▁id . ▁The ▁only ▁ helper ▁API ▁to ▁* ▁access ▁the ▁actual ▁id ▁is ▁pthread _ equal (). ▁If ▁this ▁must ▁be ▁used , ▁then ▁* ▁the ▁array ▁search ▁woul d ▁be st ▁be ▁changed ▁to ▁a ▁line ar ▁search . ▁* ▁We ▁mix ▁in ▁the ▁ PID ▁of ▁the ▁current ▁process ▁with ▁the ▁thread ▁ID ▁in ▁* ▁case ▁the ▁application ▁is ▁for king ▁new ▁process es ▁( e . g . ▁ NGIN X ) . ▁*/ ▁# if n def ▁ DISABLE _ PTH READ S ▁cur _ threadid ▁= ▁( un signed ▁long ) ▁pthread _ self (); ▁# endif ▁cur _ threadid ▁+= ▁cur _ pid ; ▁found _ node ▁= ▁( CLIENT _ CTX _ LU _ N ODE _ T ▁*) ▁bsearch (& cur _ threadid , ▁p _ ctx -> client _ ctx _ array , ▁cur _ max _ ctx _ array , ▁sizeof ( CLIENT _ CTX _ LU _ N ODE _ T ) , ▁bsearch _ compare ); ▁if ▁( found _ node ▁ == ▁NULL ) ▁{ ▁/* ▁* ▁need ▁to ▁allocate ▁a ▁context ▁and ▁get ▁it ▁ready ▁to ▁be ▁used . ▁*/ ▁c _ ctx ▁= ▁est _ client _ init ( p _ ctx -> ca _ chain _ raw , ▁p _ ctx -> ca _ chain _ raw _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁NULL ); ▁if ▁( c _ ctx ▁ == ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁and ▁initialize ▁EST ▁client ▁context ▁for ▁ Proxy ▁use "); ▁return ▁( NULL ); ▁} ▁/* ▁* ▁The ▁name ▁is ▁a ▁bit ▁mis leading . ▁The ▁identity ▁cert ▁and ▁private ▁* ▁key ▁used ▁for ▁proxy ▁mode ▁are ▁the ▁ones ▁stored ▁in ▁the ▁server _ cert ▁and ▁* ▁server _ priv _ key , ▁ h owever ▁they ▁are ▁used ▁in ▁both ▁ directions , ▁so ▁here ▁* ▁when ▁setting ▁up ▁the ▁client ▁side , ▁it ▁look s ▁ mixed ▁up . ▁M ight ▁want ▁to ▁* ▁change ▁the ▁name ▁in ▁context ▁to ▁hold ▁these . ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( c _ ctx , ▁p _ ctx -> userid , ▁p _ ctx -> password , ▁p _ ctx -> server _ cert , ▁p _ ctx -> server _ priv _ key ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁set ▁authentication ▁configuration ▁in ▁the ▁client ▁context ▁for ▁ Proxy ▁use "); ▁est _ destroy ( c _ ctx ); ▁return ▁( NULL ); ▁} ▁rv ▁= ▁est _ client _ set _ auth _ cred _ cb ( c _ ctx , ▁p _ ctx -> auth _ credentials _ cb ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁register ▁authentication ▁credential ▁callback . "); ▁return ▁( NULL ); ▁} ▁/* ▁* ▁wr t ▁path ▁segment , ▁un like ▁true ▁client ▁mode , ▁the ▁path ▁segment ▁will ▁* ▁be ▁chang ing ▁on ▁every ▁request ▁go ing ▁upstream , ▁so ▁no ▁need ▁to ▁* ▁obtain ▁it ▁locally ▁at ▁a ▁proxy ▁and ▁set ▁it ▁one ▁time , ▁so ▁it ▁* ▁should ▁be ▁left ▁NULL . ▁*/ ▁rv ▁= ▁est _ client _ set _ server ( c _ ctx , ▁p _ ctx -> est _ server , ▁p _ ctx -> est _ port _ num , ▁NULL ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁set ▁the ▁upstream ▁server ▁configuration ▁in ▁the ▁client ▁context ▁for ▁ Proxy ▁use "); ▁est _ destroy ( c _ ctx ); ▁return ▁( NULL ); ▁} ▁rv ▁= ▁est _ client _ set _ read _ timeout ( c _ ctx , ▁p _ ctx -> read _ timeout ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁set ▁the ▁SSL ▁read ▁timeout ▁in ▁the ▁client ▁context "); ▁est _ destroy ( c _ ctx ); ▁return ▁( NULL ); ▁} ▁/* ▁* ▁make ▁sure ▁there ' s ▁roo m ▁for ▁another ▁entry ▁*/ ▁empty _ node ▁= ▁( CLIENT _ CTX _ LU _ N ODE _ T ▁*) ▁bsearch (& zero _ threadid , ▁p _ ctx -> client _ ctx _ array , ▁cur _ max _ ctx _ array , ▁sizeof ( CLIENT _ CTX _ LU _ N ODE _ T ) , ▁bsearch _ compare ); ▁if ▁( empty _ node ▁ == ▁NULL ) ▁{ ▁/* ▁* ▁we ' re ▁out ▁of ▁space . ▁allocate ▁a ▁new ▁array ▁and ▁copy ▁over ▁what ' s ▁* ▁al ready ▁there . ▁D ouble ▁the ▁size ▁of ▁the ▁current ▁one . ▁*/ ▁CLIENT _ CTX _ LU _ N ODE _ T ▁* temp _ array ; ▁cur _ max _ ctx _ array ▁* = ▁2 ; ▁temp _ array ▁= ▁( CLIENT _ CTX _ LU _ N ODE _ T ▁*) ▁malloc ( sizeof ( CLIENT _ CTX _ LU _ N ODE _ T )* cur _ max _ ctx _ array ); ▁mem zero _ s ( temp _ array , ▁sizeof ( CLIENT _ CTX _ LU _ N ODE _ T )* cur _ max _ ctx _ array ); ▁memcpy _ s ( temp _ array , ▁sizeof ( CLIENT _ CTX _ LU _ N ODE _ T )* cur _ max _ ctx _ array , ▁p _ ctx -> client _ ctx _ array , sizeof ( CLIENT _ CTX _ LU _ N ODE _ T )* cur _ max _ ctx _ array / 2 ); ▁free ( p _ ctx -> client _ ctx _ array ); ▁p _ ctx -> client _ ctx _ array ▁= ▁temp _ array ; ▁ q sort ( p _ ctx -> client _ ctx _ array , ▁cur _ max _ ctx _ array , ▁sizeof ( CLIENT _ CTX _ LU _ N ODE _ T ) , ▁bsearch _ compare ); ▁empty _ node ▁= ▁( CLIENT _ CTX _ LU _ N ODE _ T ▁*) ▁bsearch (& zero _ threadid , ▁p _ ctx -> client _ ctx _ array , ▁cur _ max _ ctx _ array , ▁sizeof ( CLIENT _ CTX _ LU _ N ODE _ T ) , ▁bsearch _ compare ); ▁} ▁empty _ index ▁= ▁( int ) ▁( empty _ node ▁- ▁p _ ctx -> client _ ctx _ array ); ▁/* ▁* ▁add ▁to ▁the ▁array ▁and ▁sort ▁it ▁into ▁its ▁proper ▁place ▁*/ ▁p _ ctx -> client _ ctx _ array [ empty _ index ]. threadid ▁= ▁cur _ threadid ; ▁p _ ctx -> client _ ctx _ array [ empty _ index ]. client _ ctx ▁= ▁c _ ctx ; ▁ q sort ( p _ ctx -> client _ ctx _ array , ▁cur _ max _ ctx _ array , ▁sizeof ( CLIENT _ CTX _ LU _ N ODE _ T ) , ▁bsearch _ compare ); ▁} ▁else ▁{ ▁/* ▁* ▁the ▁entry ▁was ▁found ▁in ▁the ▁t ree , ▁return ▁the ▁client ▁context ▁for ▁this ▁* ▁pid ▁*/ ▁c _ ctx ▁= ▁found _ node -> client _ ctx ; ▁} ▁return ( c _ ctx ); ▁} ▁/* ▁* ▁proxy _ cleanup () ▁is ▁invoked ▁from ▁est _ destroy ▁when ▁the ▁* ▁current ▁context ▁is ▁for ▁proxy ▁mode . ▁*/ ▁void ▁proxy _ cleanup ▁( EST _ CTX ▁* p _ ctx ) ▁{ ▁int ▁i ; ▁if ▁( p _ ctx -> client _ ctx _ array ▁ == ▁NULL ) ▁{ ▁return ; ▁} ▁for ▁( i =0; ▁i < cur _ max _ ctx _ array ; ▁i ++) ▁{ ▁if ▁( p _ ctx -> client _ ctx _ array [ i ]. client _ ctx ) ▁{ ▁est _ destroy ( p _ ctx -> client _ ctx _ array [ i ]. client _ ctx ); ▁} ▁} ▁free ( p _ ctx -> client _ ctx _ array ); ▁p _ ctx -> client _ ctx _ array ▁= ▁NULL ; ▁} ▁/* ▁* ▁This ▁routine ▁will ▁check ▁the ▁result ▁code ▁from ▁an ▁enroll ▁* ▁attempt ▁and ▁propagate ▁the ▁retry - after ▁message ▁to ▁the ▁* ▁client ▁if ▁needed . ▁*/ ▁static ▁EST _ ERROR ▁est _ proxy _ propagate _ retry ▁( EST _ CTX ▁* ctx , ▁void ▁* http _ ctx ) ▁{ ▁/* ▁* ▁The ▁CA ▁did ▁not ▁sign ▁the ▁request ▁and ▁has ▁asked ▁the ▁* ▁client ▁to ▁retry ▁in ▁the ▁future . ▁This ▁ma y ▁occur ▁if ▁* ▁the ▁CA ▁is ▁not ▁configured ▁for ▁automatic ▁enrollment . ▁* ▁S end ▁the ▁HTTP ▁retry ▁response ▁to ▁the ▁client . ▁* ▁We ▁need ▁to ▁propagate ▁the ▁retry - after ▁response ▁to ▁* ▁the ▁client . ▁*/ ▁EST _ LOG _ INFO (" CA ▁server ▁requests ▁retry , ▁propagate ▁this ▁to ▁the ▁client ▁(% d )", ▁ctx -> retry _ after _ delay ); ▁if ▁( EST _ ERR _ NONE ▁ != ▁est _ server _ send _ http _ retry _ after ( ctx , ▁http _ ctx , ▁ctx -> retry _ after _ delay )) ▁{ ▁return ▁( EST _ ERR _ HTTP _ WRITE ); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁This ▁routine ▁will ▁send ▁a ▁PKCS 7 ▁encoded ▁certificate ▁to ▁* ▁the ▁EST ▁client ▁ via ▁HTTP . ▁*/ ▁static ▁EST _ ERROR ▁est _ proxy _ propagate _ pkcs 7 ▁( void ▁* http _ ctx , ▁un signed ▁char ▁* pkcs 7, ▁int ▁pkcs 7_ len ) ▁{ ▁char ▁http _ hdr [ EST _ HTTP _ HDR _ MAX ]; ▁int ▁hdrlen ; ▁/* ▁* ▁S end ▁HTTP ▁header ▁*/ ▁ snprintf ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX , ▁"% s % s % s % s ", ▁EST _ HTTP _ HDR _200, ▁EST _ HTTP _ HDR _ EOL , ▁EST _ HTTP _ HDR _ STAT _200, ▁EST _ HTTP _ HDR _ EOL ); ▁hdrlen ▁= ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ); ▁ snprintf ( http _ hdr ▁+ ▁hdrlen , ▁EST _ HTTP _ HDR _ MAX , ▁"% s : ▁% s % s ", ▁EST _ HTTP _ HDR _ CT , ▁EST _ HTTP _ CT _ PKCS 7_ CO , ▁EST _ HTTP _ HDR _ EOL ); ▁hdrlen ▁= ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ); ▁ snprintf ( http _ hdr ▁+ ▁hdrlen , ▁EST _ HTTP _ HDR _ MAX , ▁"% s : ▁% s % s ", ▁EST _ HTTP _ HDR _ CE , ▁EST _ HTTP _ CE _ BASE 64, ▁EST _ HTTP _ HDR _ EOL ); ▁hdrlen ▁= ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ); ▁ snprintf ( http _ hdr ▁+ ▁hdrlen , ▁EST _ HTTP _ HDR _ MAX , ▁"% s : ▁% d % s % s ", ▁EST _ HTTP _ HDR _ CL , ▁pkcs 7_ len , ▁EST _ HTTP _ HDR _ EOL , ▁EST _ HTTP _ HDR _ EOL ); ▁if ▁(! mg _ write ( http _ ctx , ▁http _ hdr , ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁( EST _ ERR _ HTTP _ WRITE ); ▁} ▁/* ▁* ▁S end ▁the ▁signed ▁PKCS 7 ▁certificate ▁in ▁the ▁body ▁*/ ▁if ▁(! mg _ write ( http _ ctx , ▁pkcs 7, ▁pkcs 7_ len )) ▁{ ▁EST _ LOG _ ERR (" HTTP ▁write ▁error ▁while ▁propagat ing ▁pkcs 7 "); ▁return ▁( EST _ ERR _ HTTP _ WRITE ); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁est _ proxy _ retrieve _ cacerts () ▁issues ▁a ▁request ▁to ▁the ▁server ▁to ▁obtain ▁the ▁* ▁CA ▁Certs ▁chain ▁to ▁be ▁used ▁for ▁Get ▁CA ▁Certs ▁requests ▁from ▁clients . ▁* ▁The ▁CA ▁Cert ▁chain ▁returned ▁from ▁the ▁server ▁are ▁passed ▁back ▁to ▁the ▁caller . ▁* ▁* ▁It ' s ▁the ▁responsibility ▁of ▁the ▁caller ▁to ▁free ▁up ▁this ▁buffer . ▁*/ ▁EST _ ERROR ▁est _ proxy _ retrieve _ cacerts ▁( EST _ CTX ▁* ctx , ▁un signed ▁char ▁** cacerts _ rtn , ▁int ▁* cacerts _ rtn _ len ) ▁{ ▁EST _ CTX ▁* client _ ctx ; ▁EST _ ERROR ▁rv ; ▁int ▁rc vd _ cacerts _ len ; ▁un signed ▁char ▁* rc vd _ cacerts ; ▁if ▁( ctx ▁ == ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" C tx ▁not ▁passed ▁to ▁% s ", ▁ _ _ FUNCTION _ _ ); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁( cacerts _ rtn ▁ == ▁NULL ▁|| ▁cacerts _ rtn _ len ▁ == ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" C tx ▁not ▁passed ▁to ▁% s ", ▁ _ _ FUNCTION _ _ ); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁* cacerts _ rtn ▁= ▁NULL ; ▁* cacerts _ rtn _ len ▁= ▁0; ▁/* ▁* ▁Get ▁the ▁client ▁context ▁for ▁this ▁thread ▁*/ ▁client _ ctx ▁= ▁get _ client _ ctx ( ctx ); ▁if ▁(! client _ ctx ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁obtain ▁client ▁context ▁for ▁proxy ▁operation "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁rv ▁= ▁est _ client _ get _ cacerts ( client _ ctx , ▁& rc vd _ cacerts _ len ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁retrieve ▁CA ▁Certs ▁from ▁upstream ▁server ▁ RC ▁= ▁% s ", ▁EST _ ERR _ NUM _ TO _ STR ( rv ) ); ▁return ▁( rv ); ▁} ▁/* ▁* ▁A llocate ▁a ▁buffer ▁to ▁retrieve ▁the ▁CA ▁certs ▁* ▁and ▁get ▁them ▁copied ▁in ▁*/ ▁rc vd _ cacerts ▁= ▁malloc ( rc vd _ cacerts _ len ); ▁if ▁( rc vd _ cacerts ▁ == ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁malloc ▁buffer ▁for ▁cacerts ▁received ▁from ▁server "); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁rv ▁= ▁est _ client _ copy _ cacerts ( client _ ctx , ▁rc vd _ cacerts ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁copy ▁CA ▁Certs ▁from ▁upstream ▁server ▁ RC ▁= ▁% s ", ▁EST _ ERR _ NUM _ TO _ STR ( rv ) ); ▁free ( rc vd _ cacerts ); ▁return ▁( rv ); ▁} ▁/* ▁* ▁The ▁retriev ing ▁of ▁the ▁CA ▁certs ▁through ▁the ▁normal ▁client ▁* ▁interface ▁cause s ▁the ▁client ▁to ▁go ▁back ▁into ▁an ▁uninitialize d ▁state . ▁* ▁In ▁this ▁case ▁though , ▁we ' re ▁get ting ▁it ▁just ▁for ▁pass ing ▁it ▁back ▁* ▁to ▁the ▁down stream ▁clients , ▁so ▁we ' re ▁go ing ▁to ▁put ▁this ▁client ▁* ▁context ▁back ▁into ▁the ▁initialized ▁state ▁*/ ▁client _ ctx -> est _ client _ initialized ▁= ▁1; ▁* cacerts _ rtn ▁= ▁rc vd _ cacerts ; ▁* cacerts _ rtn _ len ▁= ▁rc vd _ cacerts _ len ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁This ▁routine ▁will ▁connect ▁to ▁the ▁EST ▁server ▁and ▁attempt ▁* ▁to ▁enroll ▁the ▁CSR ▁in ▁the ▁* pkcs 10 ▁buffer . ▁U pon ▁success ▁* ▁it ▁will ▁return ▁the ▁X 509 ▁cert ▁in ▁the ▁* pkcs 7 ▁buffer . ▁The ▁* ▁length ▁of ▁the ▁returned ▁cert ▁will ▁be ▁in ▁* pkcs 7_ len . ▁* ▁The ▁* pkcs 7 ▁buffer ▁should ▁be ▁allocated ▁by ▁the ▁caller . ▁*/ ▁static ▁EST _ ERROR ▁est _ proxy _ send _ enroll _ request ▁( EST _ CTX ▁* cl nt _ ctx , ▁ BUF _ MEM ▁* pkcs 10 , ▁un signed ▁char ▁* pkcs 7, ▁int ▁* pkcs 7_ len , ▁int ▁reenroll ) ▁{ ▁EST _ ERROR ▁rv ; ▁SSL ▁* ssl _ client ; ▁/* ▁* ▁ Connect ▁to ▁the ▁server ▁*/ ▁rv ▁= ▁est _ client _ connect ( cl nt _ ctx , ▁& ssl _ client ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁return ▁( rv ); ▁} ▁/* ▁* ▁S end ▁the ▁enroll ▁request ▁*/ ▁rv ▁= ▁est _ client _ send _ enroll _ request ( cl nt _ ctx , ▁ssl _ client , ▁pkcs 10 , ▁pkcs 7, ▁pkcs 7_ len , ▁reenroll ); ▁/* ▁* ▁Dis connect ▁from ▁the ▁server ▁*/ ▁est _ client _ disconnect ( cl nt _ ctx , ▁& ssl _ client ); ▁return ▁( rv ); ▁} ▁/* ▁* ▁This ▁routine ▁will ▁connect ▁to ▁the ▁EST ▁server ▁and ▁attempt ▁* ▁to ▁enroll ▁the ▁CSR ▁in ▁the ▁* pkcs 10 ▁buffer . ▁U pon ▁success ▁* ▁it ▁will ▁return ▁the ▁X 509 ▁cert ▁in ▁the ▁* pkcs 7 ▁buffer . ▁The ▁* ▁length ▁of ▁the ▁returned ▁cert ▁will ▁be ▁in ▁* pkcs 7_ len . ▁* ▁The ▁* pkcs 7 ▁buffer ▁should ▁be ▁allocated ▁by ▁the ▁caller . ▁*/ ▁static ▁EST _ ERROR ▁est _ proxy _ set _ path _ segment ▁( EST _ CTX ▁* client _ ctx , ▁char ▁* path _ segment ) ▁{ ▁int ▁path _ segment _ len ; ▁EST _ ERROR ▁rc ; ▁path _ segment _ len ▁= ▁ strnlen _ s ( path _ segment , ▁EST _ MAX _ PA TH _ SEGMENT _ LEN ); ▁rc ▁= ▁est _ store _ path _ segment ( client _ ctx , ▁path _ segment , ▁path _ segment _ len ); ▁if ▁( rc ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁store ▁URI ▁path ▁segment . "); ▁return ▁( rc ); ▁} ▁return ▁EST _ ERR _ NONE ; ▁} ▁/* ▁* ▁This ▁function ▁is ▁used ▁by ▁the ▁server ▁side ▁of ▁the ▁EST ▁proxy ▁to ▁respond ▁to ▁an ▁* ▁incoming ▁Simple ▁Enroll ▁request . ▁This ▁function ▁is ▁similar ▁to ▁the ▁Client ▁API ▁* ▁function , ▁est _ client _ enroll _ req (), ▁ex cept ▁it ▁by passes ▁some ▁th ing s ▁that ▁are ▁* ▁not ▁done ▁when ▁function ing ▁as ▁a ▁proxy , ▁suc h ▁as ▁signing ▁the ▁CSR , ▁not ▁* ▁insert ing ▁the ▁TLS ▁unique ▁id ▁and ▁instead ▁includ ing ▁the ▁id - kp - cmcRA ▁usage ▁* ▁extension . ▁*/ ▁static ▁EST _ ERROR ▁est _ proxy _ handle _ simple _ enroll ▁( EST _ CTX ▁* ctx , ▁void ▁* http _ ctx , ▁SSL ▁* ssl , ▁const ▁char ▁* ct , ▁char ▁* body , ▁int ▁body _ len , ▁char ▁* path _ seg , ▁int ▁reenroll ) ▁{ ▁EST _ ERROR ▁rv ; ▁ BUF _ MEM ▁* pkcs 10 ; ▁un signed ▁char ▁* pkcs 7 ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁int ▁diff ; ▁X 509_ REQ ▁* csr ▁= ▁NULL ; ▁EST _ CTX ▁* client _ ctx ; ▁errno _ t ▁safe c _ rc ; ▁/* ▁* ▁M ake ▁sure ▁the ▁client ▁has ▁sent ▁us ▁a ▁PKCS 10 ▁CSR ▁request ▁*/ ▁safe c _ rc ▁= ▁mem cmp _ s ( ct , ▁sizeof (" application / pkcs 10 "), ▁" application / pkcs 10", ▁sizeof (" application / pkcs 10 "), ▁& diff ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" mem cmp _ s ▁error ▁0 x % xO \ n ", ▁safe c _ rc ); ▁} ▁if ▁( diff ) ▁{ ▁return ▁( EST _ ERR _ BAD _ CONTENT _ TYPE ); ▁} ▁/* ▁* ▁ Authenticate ▁the ▁client ▁*/ ▁switch ▁( est _ enroll _ auth ( ctx , ▁http _ ctx , ▁ssl , ▁path _ seg , ▁reenroll )) ▁{ ▁case ▁EST _ HTTP _ AUTH : ▁case ▁EST _ SRP _ AUTH : ▁case ▁EST _ CERT _ AUTH : ▁break ; ▁case ▁EST _ HTTP _ AUTH _ PENDING : ▁return ▁( EST _ ERR _ AUTH _ PENDING ); ▁break ; ▁case ▁EST _ UNAUTHORIZED : ▁default : ▁return ▁( EST _ ERR _ AUTH _ FAIL ); ▁break ; ▁} ▁/* ▁* ▁ Parse ▁the ▁PKCS 10 ▁CSR ▁from ▁the ▁client ▁*/ ▁csr ▁= ▁est _ server _ parse _ csr ( ( un signed ▁char *) body , ▁body _ len ); ▁if ▁(! csr ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁parse ▁the ▁PKCS 10 ▁CSR ▁sent ▁by ▁the ▁client "); ▁return ▁( EST _ ERR _ BAD _ PKCS 10); ▁} ▁/* ▁* ▁Perform ▁a ▁ sanity ▁check ▁on ▁the ▁CSR ▁*/ ▁if ▁( est _ server _ check _ csr ( csr )) ▁{ ▁EST _ LOG _ ERR (" PKCS 10 ▁CSR ▁sent ▁by ▁the ▁client ▁failed ▁ sanity ▁check "); ▁X 509_ REQ _ free ( csr ); ▁return ▁( EST _ ERR _ BAD _ PKCS 10); ▁} ▁/* ▁* ▁Do ▁the ▁PoP ▁check ▁( Proof ▁of ▁P ossession ) . ▁The ▁challenge ▁password ▁* ▁in ▁the ▁pkcs 10 ▁request ▁should ▁match ▁the ▁TLS ▁unique ▁ID . ▁*/ ▁rv ▁= ▁est _ tls _ uid _ auth ( ctx , ▁ssl , ▁csr ); ▁X 509_ REQ _ free ( csr ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁return ▁( EST _ ERR _ AUTH _ FAIL _ TLSUID ); ▁} ▁/* ▁* ▁body ▁now ▁point s ▁to ▁the ▁pkcs 10 ▁data , ▁pass ▁* ▁this ▁to ▁the ▁enrollment ▁routine . ▁Ne ed ▁to ▁hi - jack ▁* ▁a ▁ BUF _ MEM . ▁Att ach ▁the ▁body ▁to ▁a ▁new ▁ BUF _ MEM ▁*/ ▁pkcs 10 ▁= ▁ BUF _ MEM _ new (); ▁pkcs 10-> data ▁= ▁body ; ▁pkcs 10-> length ▁= ▁body _ len ; ▁pkcs 10-> max ▁= ▁body _ len ; ▁/* ▁* ▁get ▁the ▁client ▁context ▁for ▁this ▁thread ▁*/ ▁client _ ctx ▁= ▁get _ client _ ctx ( ctx ); ▁if ▁(! client _ ctx ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁obtain ▁client ▁context ▁for ▁proxy ▁operation "); ▁est _ proxy _ free _ ossl _ bufmem ( pkcs 10); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁/* ▁* ▁path _ segment . ▁The ▁path ▁ seg ▁value ▁is ▁coming ▁in ▁from ▁the ▁* ▁down stream ▁client ▁on ▁this ▁request . ▁It ' s ▁al ready ▁been ▁validated , ▁* ▁place ▁it ▁in ▁ctx ▁for ▁use ▁by ▁client ▁code . ▁*/ ▁if ▁( path _ seg ) ▁{ ▁est _ proxy _ set _ path _ segment ( client _ ctx , ▁path _ seg ); ▁} ▁/* ▁* ▁A llocate ▁some ▁space ▁to ▁hold ▁the ▁cert ▁that ▁we ▁* ▁expect ▁to ▁receive ▁from ▁the ▁EST ▁server . ▁*/ ▁pkcs 7 ▁= ▁malloc ( EST _ CA _ MAX ); ▁/* ▁* ▁Attempt ▁to ▁enroll ▁the ▁CSR ▁from ▁the ▁client ▁*/ ▁rv ▁= ▁est _ proxy _ send _ enroll _ request ( client _ ctx , ▁pkcs 10 , ▁pkcs 7, ▁& pkcs 7_ len , ▁reenroll ); ▁/* ▁* ▁H andle ▁any ▁errors ▁that ▁like ly ▁occurred ▁*/ ▁switch ▁( rv ) ▁{ ▁case ▁EST _ ERR _ AUTH _ FAIL : ▁/* ▁T ry ▁one ▁more ▁time ▁if ▁we ' re ▁do ing ▁Digest ▁auth ▁*/ ▁if ▁( ( ctx -> auth _ mode ▁ == ▁AUTH _ DIGEST ▁|| ▁ctx -> auth _ mode ▁ == ▁AUTH _ BASIC ▁|| ▁ctx -> auth _ mode ▁ == ▁AUTH _ TOKEN )) ▁{ ▁EST _ LOG _ INFO (" HTTP ▁Auth ▁failed , ▁try ing ▁again ▁with ▁digest / basic ▁parameters "); ▁rv ▁= ▁est _ proxy _ send _ enroll _ request ( client _ ctx , ▁pkcs 10 , ▁pkcs 7, ▁& pkcs 7_ len , ▁reenroll ); ▁if ▁( rv ▁ == ▁EST _ ERR _ CA _ ENROLL _ RETRY ) ▁{ ▁rv ▁= ▁est _ proxy _ propagate _ retry ( client _ ctx , ▁http _ ctx ); ▁} ▁else ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ WARN (" EST ▁enrollment ▁failed , ▁error ▁code ▁is ▁% d ", ▁rv ); ▁} ▁} ▁break ; ▁case ▁EST _ ERR _ CA _ ENROLL _ RETRY : ▁rv ▁= ▁est _ proxy _ propagate _ retry ( client _ ctx , ▁http _ ctx ); ▁break ; ▁default : ▁EST _ LOG _ WARN (" Initial ▁EST ▁enrollment ▁request ▁error ▁code ▁is ▁% d ", ▁rv ); ▁break ; ▁} ▁client _ ctx -> auth _ mode ▁= ▁AUTH _ NONE ; ▁/* ▁* ▁P revent ▁OpenSSL ▁from ▁free ing ▁our ▁data ▁*/ ▁est _ proxy _ free _ ossl _ bufmem ( pkcs 10); ▁/* ▁* ▁If ▁we ▁have ▁a ▁cert ▁response ▁from ▁the ▁EST ▁server , ▁let ' s ▁forward ▁* ▁it ▁back ▁to ▁the ▁EST ▁client ▁*/ ▁if ▁( pkcs 7_ len ▁> ▁0) ▁{ ▁rv ▁= ▁est _ proxy _ propagate _ pkcs 7 ( http _ ctx , ▁pkcs 7, ▁pkcs 7_ len ); ▁} ▁free ( pkcs 7 ); ▁return ▁( rv ); ▁} ▁/* ▁* ▁This ▁function ▁is ▁used ▁by ▁the ▁server ▁side ▁of ▁the ▁EST ▁proxy ▁to ▁respond ▁to ▁an ▁* ▁incoming ▁cacerts ▁request . ▁If ▁the ▁CA ▁certs ▁response ▁has ▁been ▁set ▁locally ▁* ▁then ▁respond ▁with ▁this ▁locally ▁set ▁buffer . ▁If ▁not ▁set , ▁then ▁issue ▁a ▁* ▁request ▁to ▁the ▁upstream ▁server . ▁*/ ▁static ▁int ▁est _ proxy _ handle _ cacerts ▁( EST _ CTX ▁* ctx , ▁void ▁* http _ ctx , ▁char ▁* path _ seg ) ▁{ ▁EST _ ERROR ▁rv ▁= ▁EST _ ERR _ NONE ; ▁EST _ CTX ▁* client _ ctx ; ▁int ▁cacerts _ len ; ▁if ▁( ctx -> ca _ certs ▁ != ▁NULL ) ▁{ ▁EST _ LOG _ INFO (" Proxy : ▁CA ▁certs ▁set ▁locally , ▁respond ing ▁with ▁locally ▁set ▁CA ▁certs ▁response "); ▁return ( est _ handle _ cacerts ( ctx , ▁ctx -> ca _ certs , ▁ctx -> ca _ certs _ len , ▁http _ ctx , ▁path _ seg ) ); ▁} ▁else ▁{ ▁/* ▁* ▁get ▁the ▁client ▁context ▁for ▁this ▁thread ▁*/ ▁client _ ctx ▁= ▁get _ client _ ctx ( ctx ); ▁if ▁(! client _ ctx ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁obtain ▁client ▁context ▁for ▁proxy ▁operation "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁/* ▁* ▁path _ segment . ▁The ▁path ▁ seg ▁value ▁is ▁coming ▁in ▁from ▁the ▁* ▁down stream ▁client ▁on ▁this ▁request . ▁It ' s ▁al ready ▁been ▁validated , ▁* ▁place ▁it ▁in ▁ctx ▁for ▁use ▁by ▁client ▁code . ▁*/ ▁if ▁( path _ seg ) ▁{ ▁rv ▁= ▁est _ proxy _ set _ path _ segment ( client _ ctx , ▁path _ seg ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁save ▁the ▁path ▁segment ▁from ▁the ▁URI ▁into ▁the ▁client ▁context "); ▁return ▁( rv ); ▁} ▁} ▁/* ▁* ▁I nvoke ▁client ▁code ▁to ▁retrieve ▁the ▁cacerts . ▁* ▁Note : ▁there ▁is ▁no ▁need ▁to ▁authenticate ▁the ▁client ▁( see ▁sec ▁4.5) ▁*/ ▁EST _ LOG _ INFO (" Proxy : ▁Attempt ing ▁to ▁retrieve ▁CA ▁certs ▁from ▁upstream ▁server "); ▁rv ▁= ▁est _ client _ get _ cacerts ( client _ ctx , ▁& cacerts _ len ); ▁/* ▁* ▁If ▁the ▁upstream ▁request ▁was ▁successful , ▁the ▁retrieved ▁CA ▁certs ▁will ▁be ▁* ▁in ▁the ▁context ▁*/ ▁if ▁( rv ▁ == ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ INFO (" Proxy : ▁CA ▁certs ▁retrieved ▁successful ly ▁from ▁server . ▁F orward ing ▁to ▁EST ▁client . "); ▁return ( est _ handle _ cacerts ( client _ ctx , ▁client _ ctx -> retrieved _ ca _ certs , ▁client _ ctx -> retrieved _ ca _ certs _ len , ▁http _ ctx , ▁path _ seg ) ); ▁} ▁else ▁{ ▁/* ▁* ▁S omething ▁we nt ▁wro ng ▁with ▁the ▁upstream ▁request ▁to ▁the ▁* ▁server . ▁T reat ▁this ▁as ▁a ▁not ▁found ▁condition . ▁*/ ▁EST _ LOG _ ERR (" Proxy : ▁Server ▁not ▁reach able ▁or ▁sent ▁corrupt ▁CA ▁Certs "); ▁rv ▁= ▁EST _ ERR _ HTTP _ NOT _ FOUND ; ▁} ▁} ▁return ▁( rv ); ▁} ▁/* ▁* ▁This ▁function ▁is ▁used ▁by ▁the ▁server ▁side ▁of ▁the ▁EST ▁proxy ▁to ▁respond ▁to ▁an ▁* ▁incoming ▁CSR ▁Attributes ▁request . ▁This ▁function ▁is ▁similar ▁to ▁the ▁Client ▁API ▁* ▁function , ▁est _ client _ get _ csrattrs (). ▁*/ ▁static ▁int ▁est _ proxy _ handle _ csr _ attrs ▁( EST _ CTX ▁* ctx , ▁void ▁* http _ ctx , ▁char ▁* path _ seg ) ▁{ ▁int ▁rv ▁= ▁EST _ ERR _ NONE ; ▁int ▁pop _ present ; ▁char ▁* csr _ data , ▁* csr _ data _ pop ; ▁int ▁csr _ len , ▁csr _ pop _ len ; ▁EST _ CTX ▁* client _ ctx ; ▁/* ▁* ▁get ▁the ▁client ▁context ▁for ▁this ▁thread ▁*/ ▁client _ ctx ▁= ▁get _ client _ ctx ( ctx ); ▁if ▁(! client _ ctx ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁obtain ▁client ▁context ▁for ▁proxy ▁operation "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁/* ▁* ▁path _ segment . ▁The ▁path ▁ seg ▁value ▁is ▁coming ▁in ▁from ▁the ▁* ▁down stream ▁client ▁on ▁this ▁request . ▁It ' s ▁al ready ▁been ▁validated , ▁* ▁place ▁it ▁in ▁ctx ▁for ▁use ▁by ▁client ▁code . ▁*/ ▁if ▁( path _ seg ) ▁{ ▁rv ▁= ▁est _ proxy _ set _ path _ segment ( client _ ctx , ▁path _ seg ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁save ▁the ▁path ▁segment ▁from ▁the ▁URI ▁into ▁the ▁client ▁context "); ▁return ▁( rv ); ▁} ▁} ▁/* ▁* ▁I nvoke ▁client ▁code ▁to ▁retrieve ▁the ▁CSR ▁attributes . ▁* ▁Note : ▁there ▁is ▁no ▁need ▁to ▁authenticate ▁the ▁client ▁( see ▁sec ▁4.5) ▁*/ ▁EST _ LOG _ INFO (" Proxy : ▁Attempt ing ▁to ▁retrieve ▁CSR ▁attrs ▁from ▁upstream ▁server "); ▁rv ▁= ▁est _ client _ get _ csrattrs ( client _ ctx , ▁( un signed ▁char ▁**)& csr _ data , ▁& csr _ len ); ▁/* ▁* ▁csr _ data ▁point s ▁to ▁the ▁memory ▁allocated ▁to ▁hold ▁the ▁csr ▁attributes , ▁* ▁which ▁will ▁be ▁free d ▁in ▁this ▁call ▁stack . ▁To ▁p revent ▁a ▁ double - free ▁* ▁we ▁null ▁the ▁to ▁pointer ▁on ▁the ▁client ▁context . ▁*/ ▁client _ ctx -> retrieved _ csrattrs ▁= ▁NULL ; ▁client _ ctx -> retrieved _ csrattrs _ len ▁= ▁0; ▁if ▁( rv ▁ == ▁EST _ ERR _ NONE ) ▁{ ▁ctx -> csr _ pop _ present ▁= ▁0; ▁if ▁( ctx -> server _ enable _ pop ) ▁{ ▁rv ▁= ▁est _ is _ c hallengePassword _ present ( csr _ data , ▁csr _ len , ▁& pop _ present ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Error ▁dur ing ▁PoP / sanity ▁check "); ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ HTTP _ NO _ CONTENT ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁ctx -> csr _ pop _ present ▁= ▁pop _ present ; ▁if ▁(! ctx -> csr _ pop _ present ) ▁{ ▁if ▁( csr _ len ▁ == ▁0) ▁{ ▁csr _ data ▁= ▁malloc ( EST _ CSRATTRS _ POP _ LEN ▁+ ▁1); ▁if ▁(! csr _ data ) ▁{ ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁strncpy _ s ( csr _ data , ▁EST _ CSRATTRS _ POP _ LEN ▁+ ▁1, ▁EST _ CSRATTRS _ POP , ▁EST _ CSRATTRS _ POP _ LEN ); ▁csr _ data [ EST _ CSRATTRS _ POP _ LEN ] ▁= ▁0; ▁csr _ len ▁= ▁EST _ CSRATTRS _ POP _ LEN ; ▁return ▁( est _ send _ csrattr _ data ( ctx , ▁csr _ data , ▁csr _ len , ▁http _ ctx ) ); ▁} ▁rv ▁= ▁est _ add _ c hallengePassword ( csr _ data , ▁csr _ len , ▁& csr _ data _ pop , ▁& csr _ pop _ len ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁if ▁( csr _ data ) ▁{ ▁free ( csr _ data ); ▁} ▁EST _ LOG _ ERR (" Error ▁dur ing ▁add ▁PoP "); ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ HTTP _ NO _ CONTENT ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁if ▁( csr _ data ) ▁{ ▁free ( csr _ data ); ▁} ▁csr _ data ▁= ▁csr _ data _ pop ; ▁csr _ len ▁= ▁csr _ pop _ len ; ▁} ▁} ▁} ▁else ▁{ ▁EST _ LOG _ ERR (" Server ▁not ▁reach able ▁or ▁sent ▁corrupt ▁attributes "); ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ HTTP _ NO _ CONTENT ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁return ▁( est _ send _ csrattr _ data ( ctx , ▁csr _ data , ▁csr _ len , ▁http _ ctx ) ); ▁} ▁/* ▁* ▁This ▁function ▁should ▁be ▁called ▁by ▁the ▁we b ▁server ▁layer ▁when ▁* ▁a ▁HTTP ▁request ▁arrive s ▁on ▁the ▁listen ing ▁port ▁of ▁the ▁EST ▁proxy . ▁* ▁It ▁will ▁determine ▁the ▁EST ▁request ▁type ▁and ▁disp atch ▁the ▁request ▁* ▁to ▁the ▁appro pri ate ▁handler . ▁* ▁* ▁Param ters : ▁* ▁ctx : ▁Point er ▁to ▁EST _ CTX ▁* ▁http _ ctx : ▁Context ▁pointer ▁from ▁we b ▁server ▁* ▁method : ▁The ▁HT ML ▁method ▁in ▁the ▁request , ▁should ▁be ▁ ei ther ▁" GET " ▁or ▁" POST " ▁* ▁uri : ▁pointer ▁to ▁HTTP ▁URI ▁* ▁body : ▁pointer ▁to ▁full ▁HT ML ▁body ▁contents ▁* ▁body _ len : ▁length ▁of ▁HT ML ▁body ▁* ▁ct : ▁HT ML ▁content ▁type ▁header ▁*/ ▁EST _ ERROR ▁est _ proxy _ http _ request ▁( EST _ CTX ▁* ctx , ▁void ▁* http _ ctx , ▁char ▁* method , ▁char ▁* uri , ▁char ▁* body , ▁int ▁body _ len , ▁const ▁char ▁* ct ) ▁{ ▁SSL ▁* ssl ; ▁EST _ ERROR ▁rc ; ▁int ▁diff ; ▁errno _ t ▁safe c _ rc ; ▁EST _ OPERATION ▁operation ; ▁char ▁* path _ seg ▁= ▁NULL ; ▁EST _ ERROR ▁rv ▁= ▁EST _ ERR _ NONE ; ▁if ▁(! ctx ) ▁{ ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁/* ▁* ▁Verify ▁the ▁context ▁is ▁for ▁a ▁proxy , ▁not ▁a ▁client ▁or ▁server ▁*/ ▁if ▁( ctx -> est _ mode ▁ != ▁EST _ PROXY ) ▁{ ▁return ▁( EST _ ERR _ BAD _ MODE ); ▁} ▁rv ▁= ▁est _ parse _ uri ( uri , ▁& operation , ▁& path _ seg ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁rv ); ▁return ▁( rv ); ▁} ▁/* ▁* ▁Se e ▁if ▁this ▁is ▁a ▁cacerts ▁request ▁*/ ▁if ▁( operation ▁ == ▁EST _ OP _ CACERTS ) ▁{ ▁/* ▁On ly ▁GET ▁is ▁allowed ▁*/ ▁safe c _ rc ▁= ▁strcmp _ s ( method , ▁ MAX _ HTTP _ METHOD _ LEN , ▁" GET ", ▁& diff ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" strcmp _ s ▁error ▁0 x % xO \ n ", ▁safe c _ rc ); ▁} ▁if ▁( diff ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ WRONG _ METHOD ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ WRONG _ METHOD ); ▁} ▁rc ▁= ▁est _ proxy _ handle _ cacerts ( ctx , ▁http _ ctx , ▁path _ seg ); ▁if ▁( rc ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁rc ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( rc ); ▁} ▁} ▁/* ▁* ▁Se e ▁if ▁this ▁is ▁a ▁simple ▁enrollment ▁request ▁*/ ▁else ▁if ▁( operation ▁ == ▁EST _ OP _ SIMPLE _ ENROLL ) ▁{ ▁/* ▁On ly ▁POST ▁is ▁allowed ▁*/ ▁safe c _ rc ▁= ▁strcmp _ s ( method , ▁ MAX _ HTTP _ METHOD _ LEN , ▁" POST ", ▁& diff ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" strcmp _ s ▁error ▁0 x % xO \ n ", ▁safe c _ rc ); ▁} ▁if ▁( diff ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ WRONG _ METHOD ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ WRONG _ METHOD ); ▁} ▁if ▁(! ct ) ▁{ ▁EST _ LOG _ WARN (" I ncoming ▁HTTP ▁header ▁has ▁no ▁Content - Type ▁header \ n "); ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ BAD _ PKCS 10); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ BAD _ CONTENT _ TYPE ); ▁} ▁/* ▁* ▁In ▁this ▁case ▁body ▁is ▁indicat ing ▁that ▁no ▁content ▁was ▁passed ▁in , ▁and ▁* ▁this ▁is ▁a ▁enroll ▁request . ▁This ▁cannot ▁be ▁correct ▁because ▁a ▁CSR ▁is ▁* ▁required . ▁If ▁this ▁continues , ▁and ▁we ' re ▁in ▁proxy ▁mode , ▁we ' ll ▁try ▁to ▁* ▁forward ▁this ▁non - exist ent ▁CSR ▁*/ ▁if ▁( body ▁ == ▁NULL ) ▁{ ▁EST _ LOG _ WARN (" I ncoming ▁HTTP ▁header ▁has ▁no ▁CSR ▁content . \ n "); ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ BAD _ PKCS 10); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ BAD _ CONTENT _ LEN ); ▁} ▁/* ▁* ▁Get ▁the ▁SSL ▁context , ▁which ▁is ▁required ▁for ▁authenticating ▁* ▁the ▁client . ▁*/ ▁ssl ▁= ▁( SSL *) mg _ get _ conn _ ssl ( http _ ctx ); ▁if ▁(! ssl ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ NO _ SSL _ CTX ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ NO _ SSL _ CTX ); ▁} ▁rc ▁= ▁est _ proxy _ handle _ simple _ enroll ( ctx , ▁http _ ctx , ▁ssl , ▁ct , ▁body , ▁body _ len , ▁path _ seg , ▁0); ▁if ▁( rc ▁ != ▁EST _ ERR _ NONE ▁&& ▁rc ▁ != ▁EST _ ERR _ AUTH _ PENDING ) ▁{ ▁EST _ LOG _ WARN (" E nrollment ▁failed ▁with ▁rc =% d ▁(% s ) \ n ", ▁rc , ▁EST _ ERR _ NUM _ TO _ STR ( rc ) ); ▁if ▁( rc ▁ == ▁EST _ ERR _ AUTH _ FAIL ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ AUTH _ FAIL ); ▁} ▁else ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ BAD _ PKCS 10); ▁} ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ BAD _ PKCS 10); ▁} ▁} ▁/* ▁* ▁Se e ▁if ▁this ▁is ▁a ▁re - enrollment ▁request ▁*/ ▁else ▁if ▁( operation ▁ == ▁EST _ OP _ SIMPLE _ REENROLL ) ▁{ ▁/* ▁On ly ▁POST ▁is ▁allowed ▁*/ ▁safe c _ rc ▁= ▁strcmp _ s ( method , ▁ MAX _ HTTP _ METHOD _ LEN , ▁" POST ", ▁& diff ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" strcmp _ s ▁error ▁0 x % xO \ n ", ▁safe c _ rc ); ▁} ▁if ▁( diff ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ WRONG _ METHOD ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ WRONG _ METHOD ); ▁} ▁if ▁(! ct ) ▁{ ▁EST _ LOG _ WARN (" I ncoming ▁HTTP ▁header ▁has ▁no ▁Content - Type ▁header \ n "); ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ BAD _ PKCS 10); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ BAD _ CONTENT _ TYPE ); ▁} ▁/* ▁* ▁In ▁this ▁case ▁body ▁is ▁indicat ing ▁that ▁no ▁content ▁was ▁passed ▁in , ▁and ▁* ▁this ▁is ▁a ▁enroll ▁request . ▁This ▁cannot ▁be ▁correct ▁because ▁a ▁CSR ▁is ▁* ▁required . ▁If ▁this ▁continues , ▁and ▁we ' re ▁in ▁proxy ▁mode , ▁we ' ll ▁try ▁to ▁* ▁forward ▁this ▁non - exist ent ▁CSR ▁*/ ▁if ▁( body ▁ == ▁NULL ) ▁{ ▁EST _ LOG _ WARN (" I ncoming ▁HTTP ▁header ▁has ▁no ▁CSR ▁content . \ n "); ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ BAD _ PKCS 10); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ BAD _ CONTENT _ LEN ); ▁} ▁/* ▁* ▁Get ▁the ▁SSL ▁context , ▁which ▁is ▁required ▁for ▁authenticating ▁* ▁the ▁client . ▁*/ ▁ssl ▁= ▁( SSL *) mg _ get _ conn _ ssl ( http _ ctx ); ▁if ▁(! ssl ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ NO _ SSL _ CTX ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ NO _ SSL _ CTX ); ▁} ▁rc ▁= ▁est _ proxy _ handle _ simple _ enroll ( ctx , ▁http _ ctx , ▁ssl , ▁ct , ▁body , ▁body _ len , ▁path _ seg , ▁1); ▁if ▁( rc ▁ != ▁EST _ ERR _ NONE ▁&& ▁rc ▁ != ▁EST _ ERR _ AUTH _ PENDING ) ▁{ ▁EST _ LOG _ WARN (" Re enroll ▁failed ▁with ▁rc =% d ▁(% s ) \ n ", ▁rc , ▁EST _ ERR _ NUM _ TO _ STR ( rc ) ); ▁if ▁( rc ▁ == ▁EST _ ERR _ AUTH _ FAIL ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ AUTH _ FAIL ); ▁} ▁else ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ BAD _ PKCS 10); ▁} ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ BAD _ PKCS 10); ▁} ▁} ▁# if ▁0 ▁/* ▁* ▁Se e ▁if ▁this ▁is ▁a ▁ keygen ▁request ▁* ▁ FIX ME : ▁this ▁is ▁currently ▁not ▁implemented ▁*/ ▁else ▁if ▁( strnc mp ( uri , ▁EST _ KEY GEN _ URI , ▁EST _ URI _ MAX _ LEN ) ▁ == ▁0) ▁{ ▁/* ▁On ly ▁POST ▁is ▁allowed ▁*/ ▁safe c _ rc ▁= ▁strcmp _ s ( method , ▁ MAX _ HTTP _ METHOD _ LEN , ▁" POST ", ▁& diff ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" strcmp _ s ▁error ▁0 x % xO \ n ", ▁safe c _ rc ); ▁} ▁if ▁( diff ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ WRONG _ METHOD ); ▁return ▁( EST _ ERR _ WRONG _ METHOD ); ▁} ▁if ▁(! ct ) ▁{ ▁EST _ LOG _ WARN (" I ncoming ▁HTTP ▁header ▁has ▁no ▁Content - Type ▁header \ n "); ▁return ▁( EST _ ERR _ BAD _ CONTENT _ TYPE ); ▁} ▁if ▁( est _ proxy _ handle _ keygen ( ctx )) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁0); ▁// FIX ME : ▁last ▁ param ▁should ▁not ▁be ▁zero ▁return ▁( EST _ ERR _ HTTP _ WRITE ); ▁// FIX ME : ▁need ▁the ▁appro pri ate ▁return ▁code ▁} ▁} ▁# endif ▁/* ▁* ▁Se e ▁if ▁this ▁is ▁a ▁CSR ▁attributes ▁request ▁*/ ▁else ▁if ▁( operation ▁ == ▁EST _ OP _ CSRATTRS ) ▁{ ▁/* ▁On ly ▁GET ▁is ▁allowed ▁*/ ▁safe c _ rc ▁= ▁strcmp _ s ( method , ▁ MAX _ HTTP _ METHOD _ LEN , ▁" GET ", ▁& diff ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" strcmp _ s ▁error ▁0 x % xO \ n ", ▁safe c _ rc ); ▁} ▁if ▁( diff ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ WRONG _ METHOD ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ WRONG _ METHOD ); ▁} ▁rc ▁= ▁est _ proxy _ handle _ csr _ attrs ( ctx , ▁http _ ctx , ▁path _ seg ); ▁if ▁( rc ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁rc ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( rc ); ▁} ▁} ▁/* ▁* ▁S end ▁a ▁404 ▁error ▁if ▁the ▁URI ▁did n ' t ▁match ▁*/ ▁else ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ HTTP _ NOT _ FOUND ); ▁} ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ b rie f ▁est _ proxy _ start () ▁is ▁used ▁by ▁an ▁application ▁to ▁start ▁the ▁EST ▁proxy ▁after ▁est _ proxy _ init () ▁and ▁est _ proxy _ set _ server () ▁have ▁been ▁called ▁and ▁all ▁the ▁required ▁callback ▁functions ▁have ▁been ▁provided ▁by ▁the ▁application . ▁@ param ▁ctx ▁Point er ▁to ▁the ▁EST ▁context ▁libEST ▁uses ▁HTTP ▁code ▁from ▁the ▁Mon g oose ▁HTTP ▁server . ▁This ▁function ▁allow s ▁the ▁application ▁to ▁start ▁the ▁HTTP ▁services ▁layer , ▁which ▁is ▁required ▁by ▁EST . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ proxy _ start ▁( EST _ CTX ▁* ctx ) ▁{ ▁EST _ MG _ CONTEXT ▁* mgctx ; ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁mgctx ▁= ▁mg _ start ( ctx ); ▁if ▁( mgctx ) ▁{ ▁ctx -> mg _ ctx ▁= ▁mgctx ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁else ▁{ ▁return ▁( EST _ ERR _ NO _ SSL _ CTX ); ▁} ▁} ▁/* ! ▁@ b rie f ▁est _ proxy _ stop () ▁is ▁used ▁by ▁an ▁application ▁to ▁stop ▁the ▁EST ▁proxy . ▁This ▁should ▁be ▁called ▁prior ▁to ▁est _ destroy (). ▁@ param ▁ctx ▁Point er ▁to ▁the ▁EST ▁context ▁libEST ▁uses ▁HTTP ▁code ▁from ▁the ▁Mon g oose ▁HTTP ▁server . ▁This ▁function ▁allow s ▁the ▁application ▁to ▁stop ▁the ▁HTTP ▁services ▁layer . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ proxy _ stop ▁( EST _ CTX ▁* ctx ) ▁{ ▁EST _ MG _ CONTEXT ▁* mgctx ; ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁mgctx ▁= ▁( EST _ MG _ CONTEXT *) ctx -> mg _ ctx ; ▁if ▁( mgctx ) ▁{ ▁mg _ stop ( mgctx ); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ b rie f ▁est _ proxy _ init () ▁is ▁used ▁by ▁an ▁application ▁to ▁create ▁a ▁context ▁in ▁the ▁EST ▁library . ▁This ▁context ▁is ▁used ▁when ▁invoking ▁other ▁functions ▁in ▁the ▁API ▁while ▁in ▁ Proxy ▁mode . ▁@ param ▁ca _ chain ▁ Char ▁array ▁containing ▁PEM ▁encoded ▁CA ▁certs ▁& ▁CRL ▁entries . ▁This ▁chain ▁of ▁certificates ▁is ▁used ▁as ▁the ▁trust ▁anchor ▁when ▁establish ing ▁a ▁TLS ▁connection . ▁@ param ▁ca _ chain _ len ▁Length ▁of ▁ca _ chain ▁char ▁array . ▁@ param ▁cacerts _ resp _ chain ▁ Char ▁array ▁containing ▁PEM ▁encoded ▁CA ▁certs ▁to ▁include ▁in ▁the ▁/ cacerts ▁response . ▁This ▁is ▁an ▁optional ▁parameter . ▁If ▁it ▁set , ▁it ▁contains ▁the ▁chain ▁of ▁certificates ▁used ▁by ▁the ▁proxy ▁to ▁respond ▁to ▁GET ▁CA ▁Certs ▁requests ▁from ▁EST ▁Clients . ▁If ▁this ▁parameter ▁is ▁not ▁included , ▁then ▁the ▁proxy ▁will ▁obtain ▁the ▁CA ▁certificate ▁chain ▁from ▁the ▁configured ▁upstream ▁EST ▁server . ▁If ▁this ▁parameter ▁is ▁not ▁NULL , ▁then ▁the ▁correct ▁length ▁of ▁this ▁buffer ▁must ▁be ▁specified ▁in ▁cacerts _ resp _ chain _ len . ▁@ param ▁cacerts _ resp _ chain _ len ▁Length ▁of ▁cacerts _ resp _ chain ▁char ▁array ▁@ param ▁cert _ format ▁Specifi es ▁the ▁encoding ▁of ▁the ▁local ▁and ▁external ▁certificate ▁chains ▁( PEM / DER ) . ▁@ param ▁http _ realm ▁ Char ▁array ▁containing ▁HTTP ▁realm ▁name ▁for ▁HTTP ▁auth ▁@ param ▁tls _ id _ cert ▁Point er ▁to ▁X 509 ▁that ▁contains ▁the ▁proxy ' s ▁certificate ▁for ▁the ▁TLS ▁layer . ▁@ param ▁tls _ id _ key ▁Point er ▁to ▁E VP _ PKEY ▁that ▁contains ▁the ▁private ▁key ▁a ssociat ed ▁with ▁the ▁proxy ' s ▁certificate . ▁@ param ▁uid ▁User ▁ID ▁to ▁use ▁for ▁authenticating ▁with ▁server ▁@ param ▁pwd ▁Password ▁to ▁use ▁for ▁authenticating ▁with ▁server ▁This ▁function ▁allow s ▁an ▁application ▁to ▁initialize ▁an ▁EST ▁server ▁context ▁for ▁proxy ▁mode ▁operation , ▁which ▁is ▁used ▁when ▁operat ing ▁as ▁an ▁RA . ▁The ▁application ▁must ▁provide ▁the ▁trusted ▁CA ▁certificates ▁to ▁use ▁for ▁server ▁operation ▁using ▁the ▁ca _ chain ▁parameter . ▁This ▁certificate ▁set ▁should ▁include ▁the ▁explicit ▁trust ▁anchor ▁certificate , ▁any ▁number ▁of ▁implicit ▁trust ▁anchor ▁certificates , ▁and ▁any ▁inter mediate ▁sub - CA ▁certificates ▁required ▁to ▁complete ▁the ▁chain ▁of ▁trust ▁between ▁the ▁identity ▁certificate ▁passed ▁into ▁the ▁tls _ id _ cert ▁parameter ▁and ▁the ▁roo t ▁certificate ▁for ▁that ▁identity ▁certificate . ▁The ▁CA ▁certificates ▁should ▁be ▁encoded ▁using ▁the ▁format ▁specified ▁in ▁the ▁cert _ format ▁parameter ▁( e . g . ▁PEM ) ▁and ▁ma y ▁contain ▁CRL ▁entries ▁that ▁will ▁be ▁used ▁when ▁authenticating ▁EST ▁clients ▁connecting ▁to ▁the ▁server . ▁The ▁application s ▁must ▁also ▁provide ▁the ▁HTTP ▁realm ▁to ▁use ▁for ▁HTTP ▁authentication ▁and ▁the ▁server ▁cer ificate / private ▁key ▁to ▁use ▁for ▁TLS . ▁W arning : ▁I nclud ing ▁a dditional ▁inter mediate ▁sub - CA ▁certificates ▁that ▁are ▁not ▁needed ▁to ▁complete ▁the ▁chain ▁of ▁trust ▁ma y ▁result ▁in ▁a ▁potential ▁ MIT M ▁attack . ▁@ return ▁EST _ CTX . ▁*/ ▁EST _ CTX ▁* ▁est _ proxy _ init ▁( un signed ▁char ▁* ca _ chain , ▁int ▁ca _ chain _ len , ▁un signed ▁char ▁* cacerts _ resp _ chain , ▁int ▁cacerts _ resp _ chain _ len , ▁EST _ CERT _ FORMAT ▁cert _ format , ▁char ▁* http _ realm , ▁X 509 ▁* tls _ id _ cert , ▁E VP _ PKEY ▁* tls _ id _ key , ▁char ▁* uid , ▁char ▁* pwd ) ▁{ ▁EST _ CTX ▁* ctx ; ▁int ▁len ; ▁est _ log _ version (); ▁/* ▁* ▁ Sanity ▁check ▁the ▁input ▁*/ ▁if ▁( ca _ chain ▁ == ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Trust ed ▁CA ▁certificate ▁set ▁is ▁empty "); ▁return ▁NULL ; ▁} ▁if ▁( tls _ id _ cert ▁ == ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" TLS ▁cert ▁is ▁empty "); ▁return ▁NULL ; ▁} ▁if ▁( tls _ id _ key ▁ == ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" TLS ▁private ▁key ▁is ▁empty "); ▁return ▁NULL ; ▁} ▁if ▁( http _ realm ▁ == ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" EST ▁HTTP ▁realm ▁is ▁NULL "); ▁return ▁NULL ; ▁} ▁if ▁( cert _ format ▁ != ▁EST _ CERT _ FORMAT _ PEM ) ▁{ ▁EST _ LOG _ ERR (" O nly ▁PEM ▁encoding ▁of ▁certificates ▁is ▁supported . "); ▁return ▁NULL ; ▁} ▁/* ▁* ▁Verify ▁the ▁length s ▁of ▁the ▁cert ▁chains ▁*/ ▁len ▁= ▁( int ) ▁ strnlen _ s ( ( char ▁*) ca _ chain , ▁EST _ CA _ MAX ); ▁if ▁( len ▁ != ▁ca _ chain _ len ) ▁{ ▁EST _ LOG _ ERR (" Length ▁of ▁ca _ chain ▁does n ' t ▁match ▁ca _ chain _ len "); ▁return ▁NULL ; ▁} ▁if ▁( cacerts _ resp _ chain ) ▁{ ▁len ▁= ▁( int ) ▁ strnlen _ s ( ( char ▁*) cacerts _ resp _ chain , ▁EST _ CA _ MAX ); ▁if ▁( len ▁ != ▁cacerts _ resp _ chain _ len ) ▁{ ▁EST _ LOG _ ERR (" Length ▁of ▁cacerts _ resp _ chain ▁does n ' t ▁match ▁cacerts _ resp _ chain _ len "); ▁return ▁NULL ; ▁} ▁} ▁/* ▁* ▁A llocate ▁and ▁set ▁up ▁the ▁ Proxy ▁based ▁EST ▁Context . ▁This ▁context ▁will ▁be ▁* ▁use ▁when ▁operat ing ▁as ▁the ▁Server ▁to ▁the ▁down stream ▁clients . ▁EST ▁ Proxy ▁mode ▁* ▁is ▁basic ally ▁a ▁server ▁function ▁that ▁requires ▁client ▁capabilities ▁to ▁* ▁communicate ▁to ▁the ▁upstream ▁server ▁when ▁needed . ▁*/ ▁ctx ▁= ▁malloc ( sizeof ( EST _ CTX ) ); ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" malloc ▁failed "); ▁return ▁NULL ; ▁} ▁mem zero _ s ( ctx , ▁sizeof ( EST _ CTX ) ); ▁ctx -> est _ mode ▁= ▁EST _ PROXY ; ▁ctx -> retry _ period ▁= ▁EST _ RETRY _ PER I OD _ DEF ; ▁ctx -> server _ enable _ pop ▁= ▁1; ▁ctx -> require _ http _ auth ▁= ▁HTTP _ AUTH _ REQUIRED ; ▁ctx -> server _ read _ timeout ▁= ▁EST _ SSL _ READ _ TIME O UT _ DEF ; ▁if ▁( est _ client _ set _ uid _ pw ( ctx , ▁uid , ▁pwd ) ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁store ▁the ▁userid ▁and ▁password ▁dur ing ▁proxy ▁initialization "); ▁free ( ctx ); ▁return ▁NULL ; ▁} ▁/* ▁* ▁Load ▁the ▁CA ▁certificates ▁into ▁local ▁memory ▁and ▁retain ▁* ▁for ▁future ▁use . ▁This ▁will ▁be ▁used ▁for ▁/ cacerts ▁requests . ▁*/ ▁if ▁( cacerts _ resp _ chain ) ▁{ ▁if ▁( est _ load _ ca _ certs ( ctx , ▁cacerts _ resp _ chain , ▁cacerts _ resp _ chain _ len )) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁load ▁CA ▁certificates ▁response ▁buffer "); ▁free ( ctx ); ▁return ▁NULL ; ▁} ▁} ▁/* ▁* ▁Load ▁the ▁CA ▁certificate ▁chain ▁into ▁an ▁X 509 ▁store ▁structure ▁* ▁This ▁will ▁be ▁used ▁in ▁verifying ▁incoming ▁certs ▁dur ing ▁TLS ▁* ▁establishe ment . ▁* ▁A lso ▁save ▁a ▁ way ▁a ▁raw ▁copy ▁of ▁the ▁ca _ chain ▁buffer ▁so ▁that ▁* ▁it ▁can ▁be ▁used ▁when ▁creat ing ▁client ▁context s ▁used ▁to ▁communi nc ate ▁* ▁to ▁the ▁upstream ▁server . ▁*/ ▁if ▁( est _ load _ trusted _ certs ( ctx , ▁ca _ chain , ▁ca _ chain _ len )) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁load ▁trusted ▁certificate ▁store "); ▁est _ destroy ( ctx ); ▁return ▁NULL ; ▁} ▁ctx -> ca _ chain _ raw ▁= ▁malloc ( ca _ chain _ len +1 ); ▁if ▁(! ctx -> ca _ chain _ raw ) ▁{ ▁EST _ LOG _ ERR (" malloc ▁failed "); ▁est _ destroy ( ctx ); ▁return ▁NULL ; ▁} ▁memcpy _ s ( ( char ▁*) ctx -> ca _ chain _ raw , ▁ca _ chain _ len +1, ▁( char ▁*) ca _ chain , ▁ca _ chain _ len ); ▁ctx -> ca _ chain _ raw [ ca _ chain _ len ] ▁= ▁'\0'; ▁ctx -> ca _ chain _ raw _ len ▁= ▁ca _ chain _ len ; ▁strncpy _ s ( ctx -> realm , ▁ MAX _ REALM , ▁http _ realm , ▁ MAX _ REALM ); ▁ctx -> server _ cert ▁= ▁tls _ id _ cert ; ▁ctx -> server _ priv _ key ▁= ▁tls _ id _ key ; ▁ctx -> auth _ mode ▁= ▁AUTH _ BASIC ; ▁ctx -> read _ timeout ▁= ▁EST _ SSL _ READ _ TIME O UT _ DEF ; ▁ctx -> retry _ after _ delay ▁= ▁0; ▁ctx -> retry _ after _ date ▁= ▁0; ▁ctx -> client _ ctx _ array ▁= ▁( CLIENT _ CTX _ LU _ N ODE _ T ▁*) ▁malloc ( ▁sizeof ( CLIENT _ CTX _ LU _ N ODE _ T )* cur _ max _ ctx _ array ); ▁mem zero _ s ( ctx -> client _ ctx _ array , ▁sizeof ( CLIENT _ CTX _ LU _ N ODE _ T )* cur _ max _ ctx _ array ); ▁return ▁( ctx ); ▁} ▁/* ! ▁@ b rie f ▁est _ proxy _ set _ auth _ mode () ▁is ▁used ▁by ▁an ▁application ▁layer ▁to ▁configure ▁the ▁HTTP ▁authentication ▁method ▁to ▁use ▁for ▁validat ing ▁the ▁identity ▁of ▁an ▁EST ▁client . ▁@ param ▁ctx ▁Point er ▁to ▁the ▁EST ▁proxy ▁context . ▁This ▁was ▁returned ▁from ▁est _ proxy _ init (). ▁@ param ▁amode ▁Should ▁be ▁ ei ther ▁AUTH _ BASIC ▁or ▁AUTH _ DIGEST ▁This ▁function ▁can ▁optional ly ▁be ▁invoked ▁by ▁the ▁application ▁layer ▁to ▁change ▁the ▁default ▁HTTP ▁authentication ▁mode . ▁The ▁default ▁mode ▁is ▁HTTP ▁Basic ▁authentication . ▁An ▁application ▁ma y ▁desire ▁to ▁use ▁Digest ▁authentication ▁instead , ▁in ▁which ▁case ▁this ▁function ▁can ▁be ▁used ▁to ▁set ▁that ▁mode . ▁This ▁function ▁should ▁be ▁invoked ▁prior ▁to ▁start ing ▁the ▁EST ▁proxy . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ proxy _ set _ auth _ mode ▁( EST _ CTX ▁* ctx , ▁EST _ HTTP _ AUTH _ MODE ▁amode ) ▁{ ▁return ( est _ server _ set _ auth _ mode ( ctx , ▁amode ) ); ▁} ▁/* ! ▁@ b rie f ▁est _ proxy _ set _ auth _ cred _ cb () ▁is ▁used ▁by ▁an ▁application ▁to ▁register ▁its ▁callback ▁function . ▁@ param ▁ctx ▁EST ▁context ▁obtained ▁from ▁the ▁est _ proxy _ init () ▁call . ▁@ param ▁auth _ credentials _ cb ▁Function ▁pointer ▁to ▁the ▁application ▁layer ▁callback ▁The ▁registered ▁callback ▁function ▁is ▁used ▁by ▁the ▁EST ▁client ▁library ▁to ▁obtain ▁authentication ▁credentials . ▁The ▁application ▁can ▁provide ▁authentication ▁credentials ▁dur ing ▁initialization ▁if ▁they ▁are ▁available , ▁suc h ▁as ▁the ▁userid ▁and ▁password ▁used ▁with ▁HTTP ▁basic ▁authentication . ▁D ur ing ▁the ▁processing ▁of ▁a ▁request , ▁the ▁EST ▁client ▁library ▁will ▁call ▁this ▁application ▁callback ▁in ▁the ▁event ▁that ▁it ▁does ▁not ▁have ▁the ▁authentication ▁credentials ▁that ▁are ▁being ▁requested ▁by ▁the ▁EST ▁server . ▁The ▁callback ▁function ▁definition ▁must ▁match ▁the ▁following ▁function ▁prototype , ▁int ▁(* auth _ credentials _ cb ) ( EST _ HTTP _ AUTH _ HDR ▁* auth _ credentials ); ▁auth _ credentials ▁- ▁A ▁pointer ▁to ▁a ▁EST _ HTTP _ AUTH _ HDR ▁structure . ▁The ▁structure ▁is ▁provided ▁by ▁the ▁EST ▁library ▁and ▁the ▁callback ▁function ▁fill s ▁in ▁the ▁specific ▁credentials ▁being ▁requested . ▁These ▁credential ▁values ▁must ▁be ▁passed ▁in ▁the ▁format ▁in ▁which ▁they ▁will ▁be ▁sent ▁to ▁the ▁server , ▁that ▁is , ▁the ▁EST ▁client ▁library ▁will ▁perform ▁no ▁re format ting ▁of ▁these ▁credentials . ▁O w ners h ip ▁of ▁the ▁memory ▁hold ing ▁these ▁credential ▁values ▁is ▁transferred ▁from ▁the ▁application ▁layer ▁to ▁the ▁EST ▁library ▁when ▁the ▁application ▁layer ▁returns ▁these ▁values ▁to ▁the ▁EST ▁library . ▁This ▁allow s ▁the ▁EST ▁library ▁to ▁free ▁up ▁this ▁memory ▁as ▁so on ▁as ▁it ▁is ▁done ▁using ▁these ▁values . ▁The ▁return ▁value ▁from ▁the ▁callback ▁must ▁be ▁one ▁of ▁the ▁following ▁values : ▁EST _ HTTP _ AUTH _ C RED _ SUCCESS ▁- ▁If ▁the ▁callback ▁was ▁ able ▁to ▁provide ▁the ▁requested ▁credentials . ▁EST _ HTTP _ AUTH _ C RED _ NOT _ AVAILABLE ▁- ▁If ▁the ▁callback ▁c ould ▁not ▁provide ▁the ▁requested ▁credentials . ▁The ▁auth _ credentials _ cb ▁parameter ▁can ▁be ▁set ▁to ▁NULL ▁to ▁reset ▁the ▁callback ▁function . ▁All ▁string ▁parameters ▁are ▁NULL ▁terminated ▁strings . ▁@ return ▁EST _ ERROR . ▁EST _ ERR _ NONE ▁- ▁Success . ▁EST _ ERR _ NO _ CTX ▁*/ ▁EST _ ERROR ▁est _ proxy _ set _ auth _ cred _ cb ▁( EST _ CTX ▁* ctx , ▁auth _ credentials _ cb ▁callback ) ▁{ ▁return ( est _ client _ set _ auth _ cred _ cb ( ctx , ▁callback ) ); ▁} ▁/* ! ▁@ b rie f ▁est _ proxy _ set _ read _ timeout () ▁is ▁used ▁by ▁an ▁application ▁to ▁set ▁timeout ▁value ▁of ▁read ▁operations . ▁ After ▁the ▁EST ▁proxy ▁send s ▁a ▁request ▁to ▁the ▁EST ▁server ▁it ▁will ▁attempt ▁to ▁read ▁the ▁response ▁from ▁the ▁server . ▁This ▁timeout ▁value ▁limit s ▁the ▁amount ▁of ▁time ▁the ▁proxy ▁will ▁wait ▁for ▁the ▁response . ▁@ param ▁ctx ▁Point er ▁to ▁the ▁EST ▁context ▁@ param ▁timeout ▁I nteger ▁value ▁represent ing ▁the ▁read ▁timeout ▁in ▁seconds . ▁The ▁minimum ▁value ▁is ▁EST _ SSL _ READ _ TIME O UT _ MIN ▁and ▁the ▁maximum ▁value ▁is ▁EST _ SSL _ READ _ TIME O UT _ MAX . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ proxy _ set _ read _ timeout ▁( EST _ CTX ▁* ctx , ▁int ▁timeout ) ▁{ ▁return ( est _ client _ set _ read _ timeout ( ctx , ▁timeout ) ); ▁} ▁/* ! ▁@ b rie f ▁est _ proxy _ set _ server () ▁is ▁called ▁by ▁the ▁application ▁layer ▁to ▁specif y ▁the ▁address / port ▁of ▁the ▁EST ▁server . ▁It ▁must ▁be ▁called ▁after ▁est _ proxy _ init () ▁and ▁prior ▁to ▁issu ing ▁any ▁EST ▁commands . ▁@ param ▁ctx ▁Point er ▁to ▁EST ▁context ▁for ▁a ▁client ▁session ▁@ param ▁server ▁Name ▁of ▁the ▁EST ▁server ▁to ▁connect ▁to . ▁The ▁ASCII ▁string ▁represent ing ▁the ▁name ▁of ▁the ▁server ▁is ▁ limited ▁to ▁25 4 ▁characters ▁@ param ▁port ▁TCP ▁port ▁on ▁the ▁EST ▁server ▁to ▁connect ▁@ return ▁EST _ ERROR ▁EST _ ERR _ NONE ▁- ▁Success . ▁EST _ ERR _ NO _ CTX ▁- ▁NULL ▁value ▁passed ▁for ▁EST ▁context ▁EST _ ERR _ INVALID _ SERVER _ NAME ▁- ▁NULL ▁value ▁passed ▁for ▁EST ▁server ▁name , ▁or ▁server ▁name ▁string ▁too ▁long ▁EST _ ERR _ INVALID _ PORT _ NUM ▁- ▁I nvalid ▁port ▁number ▁input , ▁ less ▁than ▁zero ▁or ▁greate r ▁than ▁65535 ▁est _ proxy _ set _ server ▁error ▁checks ▁its ▁input ▁parameters ▁and ▁then ▁store s ▁both ▁the ▁hostname ▁and ▁port ▁number ▁into ▁the ▁EST ▁context . ▁*/ ▁EST _ ERROR ▁est _ proxy _ set _ server ▁( EST _ CTX ▁* ctx , ▁const ▁char ▁* server , ▁int ▁port ) ▁{ ▁if ▁(! ctx ) ▁{ ▁return ▁EST _ ERR _ NO _ CTX ; ▁} ▁if ▁( server ▁ == ▁NULL ) ▁{ ▁return ▁EST _ ERR _ INVALID _ SERVER _ NAME ; ▁} ▁if ▁( EST _ MAX _ SERVER NAME _ LEN - 1 ▁ < ▁ strnlen _ s ( server , ▁EST _ MAX _ SERVER NAME _ LEN )) ▁{ ▁return ▁EST _ ERR _ INVALID _ SERVER _ NAME ; ▁} ▁if ▁( port ▁ < = ▁0 ▁|| ▁port ▁> ▁65535 ) ▁{ ▁return ▁EST _ ERR _ INVALID _ PORT _ NUM ; ▁} ▁strncpy _ s ( ctx -> est _ server , ▁EST _ MAX _ SERVER NAME _ LEN , ▁server , ▁EST _ MAX _ SERVER NAME _ LEN ); ▁ctx -> est _ port _ num ▁= ▁port ; ▁return ▁EST _ ERR _ NONE ; ▁}