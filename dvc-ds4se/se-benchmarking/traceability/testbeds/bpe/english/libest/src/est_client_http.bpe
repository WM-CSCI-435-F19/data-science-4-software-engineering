▁/* ▁** ▁signed ▁long ▁to ▁signed ▁int ▁*/ ▁int ▁curl x _ sl to si ( long ▁slnum ) ▁{ ▁# if def ▁ _ _ INTE L _ COMP ILE R ▁# ▁p ragm a ▁warning ( push ) ▁# ▁p ragm a ▁warning ( disable : 8 10) ▁/* ▁conversion ▁ma y ▁ lose ▁signifi ca nt ▁bits ▁*/ ▁# endif ▁ass ert ( slnum ▁>= ▁0); ▁# if ▁( SIZE OF _ INT ▁ < ▁CURL _ SIZE OF _ LONG ) ▁ass ert ( ( un signed ▁long ) ▁slnum ▁ < = ▁( un signed ▁long ) ▁CURL _ MA SK _ S INT ); ▁# endif ▁return ▁( int ) ( slnum ▁& ▁( long ) ▁CURL _ MA SK _ S INT ); ▁# if def ▁ _ _ INTE L _ COMP ILE R ▁# ▁p ragm a ▁warning ( pop ) ▁# endif ▁} ▁/* ▁* ▁parse date () ▁* ▁* ▁Returns : ▁* ▁* ▁ PARSE DAT E _ OK ▁- ▁a ▁fine ▁conversion ▁* ▁ PARSE DAT E _ FAIL ▁- ▁failed ▁to ▁convert ▁* ▁ PARSE DAT E _ LATER ▁- ▁time ▁overflow ▁at ▁the ▁far ▁end ▁of ▁time _ t ▁* ▁ PARSE DAT E _ SOONER ▁- ▁time ▁under flow ▁at ▁the ▁low ▁end ▁of ▁time _ t ▁*/ ▁static ▁int ▁parse date ( const ▁char ▁* date , ▁time _ t ▁* output ); ▁/* ▁returns : ▁-1 ▁no ▁day ▁0 ▁mo nday ▁- ▁ 6 ▁su nday ▁*/ ▁static ▁int ▁check day ( const ▁char ▁* check , ▁size _ t ▁len ) ▁{ ▁int ▁i ; ▁const ▁char ▁* ▁const ▁* what ; ▁int ▁found = ▁0; ▁if ( len ▁> ▁3) ▁what ▁= ▁& week day [0] ; ▁else ▁what ▁= ▁& Curl _ w kday [0] ; ▁for ( i =0; ▁i < 7 ; ▁i ++) ▁{ ▁if ( est _ client _ Curl _ raw _ equal ( check , ▁what [0] )) ▁{ ▁found = 1 ; ▁break ; ▁} ▁what ++; ▁} ▁return ▁found ? i :-1; ▁} ▁/* ▁returns : ▁-1 ▁no ▁day ▁0 ▁mo nday ▁- ▁ 6 ▁su nday ▁*/ ▁static ▁int ▁check month ( const ▁char ▁* check ) ▁{ ▁int ▁i ; ▁const ▁char ▁* ▁const ▁* what ; ▁int ▁found = ▁0; ▁what ▁= ▁& Curl _ month [0] ; ▁for ( i =0; ▁i < 12; ▁i ++) ▁{ ▁if ( est _ client _ Curl _ raw _ equal ( check , ▁what [0] )) ▁{ ▁found = 1 ; ▁break ; ▁} ▁what ++; ▁} ▁return ▁found ? i :-1; ▁/* ▁return ▁the ▁offset ▁or ▁-1, ▁no ▁real ▁offset ▁is ▁-1 ▁*/ ▁} ▁/* ▁return ▁the ▁time ▁zone ▁offset ▁between ▁GMT ▁and ▁the ▁input ▁one , ▁in ▁number ▁of ▁seconds ▁or ▁-1 ▁if ▁the ▁ timezone ▁was n ' t ▁found / legal ▁*/ ▁static ▁int ▁check tz ( const ▁char ▁* check ) ▁{ ▁un signed ▁int ▁i ; ▁const ▁struct ▁tz info ▁* what ; ▁int ▁found = ▁0; ▁what ▁= ▁tz ; ▁for ( i =0; ▁i < ▁sizeof ( tz ) / sizeof ( tz [0]); ▁i ++) ▁{ ▁if ( est _ client _ Curl _ raw _ equal ( check , ▁what -> name )) ▁{ ▁found = 1 ; ▁break ; ▁} ▁what ++; ▁} ▁return ▁found ? what -> offset *60 :-1; ▁} ▁/* ▁return ▁the ▁time ▁zone ▁offset ▁between ▁GMT ▁and ▁the ▁input ▁one , ▁in ▁number ▁of ▁seconds ▁or ▁-1 ▁if ▁the ▁ timezone ▁was n ' t ▁found / legal ▁*/ ▁static ▁void ▁skip _ over _ white ( const ▁char ▁** date ) ▁{ ▁/* ▁skip ▁everything ▁that ▁are n ' t ▁let ters ▁or ▁digits ▁*/ ▁while ( ** date ▁&& ▁! ISAL NUM ( ** date )) ▁(* date ) ++; ▁} ▁/* ▁struct ▁tm ▁to ▁time ▁since ▁ep oc h ▁in ▁GMT ▁time ▁zone . ▁* ▁This ▁is ▁similar ▁to ▁the ▁ standard ▁mktime ▁function ▁but ▁for ▁GMT ▁only , ▁and ▁* ▁does n ' t ▁s uffer ▁from ▁the ▁vari ous ▁bug s ▁and ▁port ability ▁problem s ▁that ▁* ▁some ▁systems ' ▁implementation s ▁have . ▁*/ ▁static ▁time _ t ▁my _ time gm ( struct ▁my _ tm ▁* tm ) ▁{ ▁static ▁const ▁int ▁month _ days _ cu mulati ve ▁ [12 ] ▁= ▁{ ▁0, ▁31 , ▁59 , ▁ 90 , ▁12 0 , ▁ 151 , ▁1 81, ▁2 12, ▁24 3 , ▁ 273 , ▁304 , ▁33 4 ▁} ; ▁int ▁month , ▁year , ▁lea p _ days ; ▁if ( tm -> tm _ year ▁ < ▁ 70) ▁/* ▁we ▁don ' t ▁support ▁year s ▁before ▁1970 ▁as ▁they ▁will ▁cause ▁this ▁function ▁to ▁return ▁a ▁negative ▁value ▁*/ ▁return ▁-1; ▁year ▁= ▁tm -> tm _ year ▁+ ▁1900 ; ▁month ▁= ▁tm -> tm _ mon ; ▁if ( month ▁ < ▁0) ▁{ ▁year ▁+= ▁( 11 ▁- ▁month ) ▁/ ▁ 12; ▁month ▁= ▁11 ▁- ▁( 11 ▁- ▁month ) ▁% ▁ 12; ▁} ▁else ▁if ( month ▁>= ▁12 ) ▁{ ▁year ▁- = ▁month ▁/ ▁ 12; ▁month ▁= ▁month ▁% ▁ 12; ▁} ▁lea p _ days ▁= ▁year ▁- ▁( tm -> tm _ mon ▁ < = ▁1); ▁lea p _ days ▁= ▁( ( le ap _ days ▁/ ▁4) ▁- ▁( le ap _ days ▁/ ▁ 100) ▁+ ▁( le ap _ days ▁/ ▁400) ▁- ▁( 19 69 ▁/ ▁4) ▁+ ▁( 19 69 ▁/ ▁ 100) ▁- ▁( 19 69 ▁/ ▁400) ); ▁return ▁( ((( time _ t ) ▁( year ▁- ▁1970 ) ▁* ▁36 5 ▁+ ▁lea p _ days ▁+ ▁month _ days _ cu mulati ve ▁[ month ] ▁+ ▁tm -> tm _ mday ▁- ▁1) ▁* ▁24 ▁+ ▁tm -> tm _ hour ) ▁* ▁60 ▁+ ▁tm -> tm _ min ) ▁* ▁60 ▁+ ▁tm -> tm _ sec ; ▁} ▁/* ▁* ▁parse date () ▁* ▁* ▁Returns : ▁* ▁* ▁ PARSE DAT E _ OK ▁- ▁a ▁fine ▁conversion ▁* ▁ PARSE DAT E _ FAIL ▁- ▁failed ▁to ▁convert ▁* ▁ PARSE DAT E _ LATER ▁- ▁time ▁overflow ▁at ▁the ▁far ▁end ▁of ▁time _ t ▁* ▁ PARSE DAT E _ SOONER ▁- ▁time ▁under flow ▁at ▁the ▁low ▁end ▁of ▁time _ t ▁*/ ▁static ▁int ▁parse date ( const ▁char ▁* date , ▁time _ t ▁* output ) ▁{ ▁time _ t ▁t ▁= ▁0; ▁int ▁wdaynum =-1; ▁/* ▁day ▁of ▁the ▁ week ▁number , ▁ 0-6 ▁( mon - s un ) ▁*/ ▁int ▁monnum =-1; ▁/* ▁month ▁of ▁the ▁year ▁number , ▁0 -11 ▁*/ ▁int ▁mdaynum =-1; ▁/* ▁day ▁of ▁month , ▁1 ▁- ▁31 ▁*/ ▁int ▁hournum =-1; ▁int ▁minnum =-1; ▁int ▁secnum =-1; ▁int ▁yearnum =-1; ▁int ▁tzoff =-1; ▁struct ▁my _ tm ▁tm ; ▁enum ▁assume ▁dig next ▁= ▁DAT E _ MDAY ; ▁const ▁char ▁* indate ▁= ▁date ; ▁/* ▁save ▁the ▁original ▁pointer ▁*/ ▁int ▁part ▁= ▁0; ▁/* ▁max ▁ 6 ▁parts ▁*/ ▁while (* date ▁&& ▁( part ▁ < ▁ 6)) ▁{ ▁int ▁found =0; ▁skip _ over _ white (& date ); ▁if ( ISAL P HA (* date )) ▁{ ▁/* ▁a ▁name ▁coming ▁up ▁*/ ▁char ▁buf [ EST _ CURL _ MAX _ NAME _ STR ] =" "; ▁size _ t ▁len ; ▁s scan f ( date , ▁"% 31 [ AB C DEF G HI JK LM N OPQ RS TUV WX YZ abcdef g hij klmnopqrstuvwxyz ]", ▁buf ); ▁len ▁= ▁ strnlen _ s ( buf , ▁EST _ CURL _ MAX _ NAME _ STR ); ▁if ( wdaynum ▁ == ▁-1) ▁{ ▁wdaynum ▁= ▁check day ( buf , ▁len ); ▁if ( wdaynum ▁ != ▁-1) ▁found ▁= ▁1; ▁} ▁if (! found ▁&& ▁( monnum ▁ == ▁-1) ) ▁{ ▁monnum ▁= ▁check month ( buf ); ▁if ( monnum ▁ != ▁-1) ▁found ▁= ▁1; ▁} ▁if (! found ▁&& ▁( tzoff ▁ == ▁-1) ) ▁{ ▁/* ▁this ▁just ▁must ▁be ▁a ▁time ▁zone ▁string ▁*/ ▁tzoff ▁= ▁check tz ( buf ); ▁if ( tzoff ▁ != ▁-1) ▁found ▁= ▁1; ▁} ▁if (! found ) ▁return ▁ PARSE DAT E _ FAIL ; ▁/* ▁bad ▁string ▁*/ ▁date ▁+= ▁len ; ▁} ▁else ▁if ( IS DIG IT (* date )) ▁{ ▁/* ▁a ▁digit ▁*/ ▁int ▁val ; ▁char ▁* end ; ▁if ( ( secnum ▁ == ▁-1) ▁&& ▁( 3 ▁ == ▁s scan f ( date , ▁"% 02 d :% 02 d :% 02 d ", ▁& hournum , ▁& minnum , ▁& secnum ))) ▁{ ▁/* ▁time ▁stamp ! ▁*/ ▁date ▁+= ▁ 8 ; ▁} ▁else ▁if ( ( secnum ▁ == ▁-1) ▁&& ▁( 2 ▁ == ▁s scan f ( date , ▁"% 02 d :% 02 d ", ▁& hournum , ▁& minnum ))) ▁{ ▁/* ▁time ▁stamp ▁without ▁seconds ▁*/ ▁date ▁+= ▁5; ▁secnum ▁= ▁0; ▁} ▁else ▁{ ▁long ▁lval ; ▁int ▁error ; ▁int ▁old _ errno ; ▁old _ errno ▁= ▁ERRNO ; ▁SET _ ERR NO ( 0 ); ▁lval ▁= ▁strtol ( date , ▁& end , ▁10); ▁error ▁= ▁ERRNO ; ▁if ( error ▁ != ▁old _ errno ) ▁SET _ ERR NO ( old _ errno ); ▁if ( error ) ▁return ▁ PARSE DAT E _ FAIL ; ▁if ( ( lval ▁> ▁( long ) INT _ MAX ) ▁|| ▁( lval ▁ < ▁( long ) INT _ MIN )) ▁return ▁ PARSE DAT E _ FAIL ; ▁val ▁= ▁curl x _ sl to si ( lval ); ▁if ( ( tzoff ▁ == ▁-1) ▁&& ▁( ( end ▁- ▁date ) ▁ == ▁4) ▁&& ▁( val ▁ < = ▁1400 ) ▁&& ▁( indate < ▁date ) ▁&& ▁( ( date [-1] ▁ == ▁'+' ▁|| ▁date [-1] ▁ == ▁' - ' ))) ▁{ ▁/* ▁fou r ▁digits ▁and ▁a ▁value ▁ less ▁than ▁or ▁equal ▁to ▁1400 ▁( to ▁take ▁into ▁a c count ▁all ▁sort s ▁of ▁fun ny ▁time ▁zone ▁diff s ) ▁and ▁it ▁is ▁prece ded ▁with ▁a ▁ plus ▁or ▁min us . ▁This ▁is ▁a ▁time ▁zone ▁indication . ▁1400 ▁is ▁p i cked ▁since ▁+ 130 0 ▁is ▁fr equent ly ▁used ▁and ▁+ 1400 ▁is ▁ ment ion ed ▁as ▁an ▁ ed ge ▁number ▁in ▁the ▁document ▁" ISO ▁C ▁200 X ▁Pro pos al : ▁T imezone ▁Functions " ▁at ▁http :// da vid . tri bble . com / text / c 0 x timezone . html ▁If ▁any one ▁has ▁a ▁more ▁authorit ative ▁source ▁for ▁the ▁exact ▁maximum ▁time ▁zone ▁offset s , ▁p lease ▁spe ak ▁up ! ▁*/ ▁found ▁= ▁1; ▁tzoff ▁= ▁( val /100 ▁* ▁60 ▁+ ▁val %100 ) *60 ; ▁/* ▁the ▁+ ▁and ▁- ▁prefix ▁indicate s ▁the ▁local ▁time ▁compare d ▁to ▁GMT , ▁this ▁we ▁need ▁the r ▁re v ersed ▁ma th ▁to ▁get ▁what ▁we ▁want ▁*/ ▁tzoff ▁= ▁date [-1] == '+' ? - tzoff : tzoff ; ▁} ▁if ((( end ▁- ▁date ) ▁ == ▁8) ▁&& ▁( yearnum ▁ == ▁-1) ▁&& ▁( monnum ▁ == ▁-1) ▁&& ▁( mdaynum ▁ == ▁-1) ) ▁{ ▁/* ▁ 8 ▁digits , ▁no ▁year , ▁month ▁or ▁day ▁yet . ▁This ▁is ▁ YYY YMM DD ▁*/ ▁found ▁= ▁1; ▁yearnum ▁= ▁val / 10000 ; ▁monnum ▁= ▁( val %100 00) /100 -1; ▁/* ▁month ▁is ▁0 ▁- ▁11 ▁*/ ▁mdaynum ▁= ▁val %100 ; ▁} ▁if (! found ▁&& ▁( dig next ▁ == ▁DAT E _ MDAY ) ▁&& ▁( mdaynum ▁ == ▁-1) ) ▁{ ▁if ( ( val ▁> ▁0) ▁&& ▁( val < 3 2)) ▁{ ▁mdaynum ▁= ▁val ; ▁found ▁= ▁1; ▁} ▁dig next ▁= ▁DAT E _ YEAR ; ▁} ▁if (! found ▁&& ▁( dig next ▁ == ▁DAT E _ YEAR ) ▁&& ▁( yearnum ▁ == ▁-1) ) ▁{ ▁yearnum ▁= ▁val ; ▁found ▁= ▁1; ▁if ( yearnum ▁ < ▁1900 ) ▁{ ▁if ( yearnum ▁> ▁ 70) ▁yearnum ▁+= ▁1900 ; ▁else ▁yearnum ▁+= ▁2000 ; ▁} ▁if ( mdaynum ▁ == ▁-1) ▁dig next ▁= ▁DAT E _ MDAY ; ▁} ▁if (! found ) ▁return ▁ PARSE DAT E _ FAIL ; ▁date ▁= ▁end ; ▁} ▁} ▁part ++; ▁} ▁if (-1 ▁ == ▁secnum ) ▁secnum ▁= ▁minnum ▁= ▁hournum ▁= ▁0; ▁/* ▁no ▁time , ▁make ▁it ▁zero ▁*/ ▁if ( (-1 ▁ == ▁mdaynum ) ▁|| ▁(-1 ▁ == ▁monnum ) ▁|| ▁(-1 ▁ == ▁yearnum )) ▁/* ▁lack s ▁vi t al ▁info , ▁fail ▁*/ ▁return ▁ PARSE DAT E _ FAIL ; ▁# if ▁SIZE OF _ TIME _ T ▁ < ▁ 5 ▁/* ▁32 ▁bit ▁time _ t ▁can ▁only ▁hold ▁date s ▁to ▁the ▁begin n ing ▁of ▁2038 ▁*/ ▁if ( yearnum ▁> ▁203 7) ▁{ ▁* output ▁= ▁0 x 7 fffffff ; ▁return ▁ PARSE DAT E _ LATER ; ▁} ▁# endif ▁if ( yearnum ▁ < ▁1970 ) ▁{ ▁* output ▁= ▁0; ▁return ▁ PARSE DAT E _ SOONER ; ▁} ▁if ( ( mdaynum ▁> ▁31 ) ▁|| ▁( monnum ▁> ▁11) ▁|| ▁( hournum ▁> ▁ 23) ▁|| ▁( minnum ▁> ▁59 ) ▁|| ▁( secnum ▁> ▁60 )) ▁return ▁ PARSE DAT E _ FAIL ; ▁/* ▁clear ly ▁an ▁illegal ▁date ▁*/ ▁tm . tm _ sec ▁= ▁secnum ; ▁tm . tm _ min ▁= ▁minnum ; ▁tm . tm _ hour ▁= ▁hournum ; ▁tm . tm _ mday ▁= ▁mdaynum ; ▁tm . tm _ mon ▁= ▁monnum ; ▁tm . tm _ year ▁= ▁yearnum ▁- ▁1900 ; ▁/* ▁my _ time gm () ▁returns ▁a ▁time _ t . ▁time _ t ▁is ▁of ten ▁32 ▁bits , ▁even ▁on ▁many ▁a rchitectur es ▁that ▁f e ature ▁64 ▁bit ▁' long ' . ▁Some ▁systems ▁have ▁64 ▁bit ▁time _ t ▁and ▁deal ▁with ▁year s ▁be y ond ▁2038 . ▁H owever , ▁even ▁on ▁some ▁of ▁the ▁systems ▁with ▁64 ▁bit ▁time _ t ▁mktime () ▁returns ▁-1 ▁for ▁date s ▁be y ond ▁0 3: 14: 07 ▁U TC , ▁J anua ry ▁19 , ▁2038 . ▁( Su ch ▁as ▁A IX ▁ 5 100- 06 ) ▁*/ ▁t ▁= ▁my _ time gm (& tm ); ▁/* ▁time ▁zone ▁ad just ▁( ca st ▁t ▁to ▁int ▁to ▁compare ▁to ▁negative ▁one ) ▁*/ ▁if (-1 ▁ != ▁( int ) t ) ▁{ ▁/* ▁Add ▁the ▁time ▁zone ▁diff ▁between ▁local ▁time ▁zone ▁and ▁GMT . ▁*/ ▁long ▁delta ▁= ▁( long ) ( tzoff != - 1 ? tzoff : 0 ); ▁if ( ( delta > 0 ) ▁&& ▁( t ▁+ ▁delta ▁ < ▁t )) ▁return ▁-1; ▁/* ▁time _ t ▁overflow ▁*/ ▁t ▁+= ▁delta ; ▁} ▁* output ▁= ▁t ; ▁return ▁ PARSE DAT E _ OK ; ▁} ▁/* ▁Find ▁next ▁Field ▁** ▁ --------------- ▁** ▁Find s ▁the ▁next ▁RFC 82 2 ▁token ▁in ▁a ▁string ▁** ▁On ▁entry , ▁** ▁* pstr ▁point s ▁to ▁a ▁string ▁containing ▁a ▁word ▁separated ▁** ▁by ▁white ▁white ▁space ▁" , " ▁" ; " ▁or ▁"=" . ▁The ▁word ▁** ▁can ▁optional ly ▁be ▁ quoted ▁using ▁ < " > ▁or ▁" < " ▁" > " ▁** ▁Comment s ▁sur r round ed ▁by ▁'(' ▁')' ▁are ▁filter ed ▁out ▁** ▁** ▁On ▁exit , ▁** ▁* pstr ▁has ▁been ▁ moved ▁to ▁the ▁first ▁delimiter ▁past ▁the ▁** ▁field ▁** ▁ THE ▁ STRING ▁ HAS ▁B EEN ▁MUT ILA TED ▁by ▁a ▁0 ▁terminat or ▁** ▁** ▁Returns ▁a ▁pointer ▁to ▁the ▁first ▁word ▁or ▁NULL ▁on ▁error ▁*/ ▁static ▁char ▁* ▁HTNextField ▁( char ▁** ▁ pstr ) ▁{ ▁char ▁* ▁p ; ▁char ▁* ▁start ▁= ▁NULL ; ▁if ▁(! pstr ▁|| ▁!* pstr ) ▁{ ▁return ▁NULL ; ▁} ▁p ▁= ▁* pstr ; ▁while ▁(1) ▁{ ▁/* ▁S trip ▁white ▁space ▁and ▁other ▁delimiters ▁*/ ▁while ▁(* p ▁&& ▁( is space ( ( int )* p ) ▁|| ▁* p ▁ == ▁',' ▁|| ▁* p ▁ == ▁'; ' ▁|| ▁* p ▁ == ▁'=') ) ▁{ ▁p ++; ▁} ▁if ▁(!* p ) ▁{ ▁* pstr ▁= ▁p ; ▁return ▁NULL ; ▁/* ▁No ▁field ▁*/ ▁} ▁if ▁(* p ▁ == ▁'"' ) ▁{ ▁/* ▁ quoted ▁field ▁*/ ▁start ▁= ▁++ p ; ▁for ▁( ; ▁* p ▁&& ▁* p ▁ != ▁'"' ; ▁p ++) ▁{ ▁if ▁(* p ▁ == ▁'\\' ▁&& ▁* ( p ▁+ ▁1)) ▁{ ▁p ++; ▁/* ▁S kip ▁es ca ped ▁char s ▁*/ ▁} ▁} ▁break ; ▁/* ▁ kr 9 5-10 - 9 : ▁needs ▁to ▁stop ▁here ▁*/ ▁} ▁else ▁if ▁(* p ▁ == ▁' < ') ▁{ ▁/* ▁ quoted ▁field ▁*/ ▁start ▁= ▁++ p ; ▁for ▁( ; ▁* p ▁&& ▁* p ▁ != ▁' > '; ▁p ++) ▁{ ▁if ▁(* p ▁ == ▁'\\' ▁&& ▁* ( p ▁+ ▁1)) ▁{ ▁p ++; ▁/* ▁S kip ▁es ca ped ▁char s ▁*/ ▁} ▁} ▁break ; ▁/* ▁ kr 9 5-10 - 9 : ▁needs ▁to ▁stop ▁here ▁*/ ▁} ▁else ▁if ▁(* p ▁ == ▁'(' ) ▁{ ▁/* ▁Comment ▁*/ ▁for ▁( ; ▁* p ▁&& ▁* p ▁ != ▁')' ; ▁p ++) ▁{ ▁if ▁(* p ▁ == ▁'\\' ▁&& ▁* ( p ▁+ ▁1)) ▁{ ▁p ++; ▁/* ▁S kip ▁es ca ped ▁char s ▁*/ ▁} ▁} ▁p ++; ▁} ▁else ▁{ ▁/* ▁S po ol ▁field ▁*/ ▁start ▁= ▁p ; ▁while ▁(* p ▁&& ▁! is space ( ( int )* p ) ▁&& ▁* p ▁ != ▁',' ▁&& ▁* p ▁ != ▁'; ' ▁&& ▁* p ▁ != ▁'=') ▁{ ▁p ++; ▁} ▁break ; ▁/* ▁Go t ▁it ▁*/ ▁} ▁} ▁if ▁(* p ) ▁{ ▁* p ++ ▁= ▁'\0'; ▁} ▁* pstr ▁= ▁p ; ▁return ▁start ; ▁} ▁/* ▁* ▁This ▁function ▁parse s ▁the ▁authentication ▁token s ▁from ▁* ▁the ▁server ▁when ▁the ▁server ▁is ▁requesting ▁HTTP ▁digest ▁* ▁authentication . ▁The ▁token s ▁are ▁required ▁to ▁generate ▁* ▁a ▁valid ▁authentication ▁response ▁in ▁future ▁HTTP ▁* ▁requests . ▁*/ ▁static ▁EST _ ERROR ▁est _ io _ parse _ auth _ tokens ▁( EST _ CTX ▁* ctx , ▁char ▁* hdr ) ▁{ ▁int ▁rv ▁= ▁EST _ ERR _ NONE ; ▁char ▁* p ▁= ▁hdr ; ▁char ▁* token ▁= ▁NULL ; ▁char ▁* value ▁= ▁NULL ; ▁int ▁diff ; ▁errno _ t ▁safe c _ rc ; ▁/* ▁* ▁header ▁will ▁come ▁in ▁with ▁the ▁basic ▁or ▁digest ▁field ▁st ill ▁on ▁the ▁front . ▁* ▁skip ▁over ▁it . ▁*/ ▁token ▁= ▁HTNextField (& p ); ▁while ▁( ( token ▁= ▁HTNextField (& p ))) ▁{ ▁if ▁(! est _ strcasecmp _ s ( token , ▁" realm ")) ▁{ ▁if ▁( ( value ▁= ▁HTNextField (& p ))) ▁{ ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> realm , ▁ MAX _ REALM , ▁value , ▁ MAX _ REALM )) ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁if ▁(! est _ strcasecmp _ s ( token , ▁" nonce ")) ▁{ ▁if ▁( ( value ▁= ▁HTNextField (& p ))) ▁{ ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> s _ nonce , ▁ MAX _ NONCE , ▁value , ▁ MAX _ NONCE )) ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁if ▁(! est _ strcasecmp _ s ( token , ▁" qop ")) ▁{ ▁if ▁( ( value ▁= ▁HTNextField (& p ))) ▁{ ▁if ▁( value [0] ▁ == ▁'\0') ▁{ ▁EST _ LOG _ WARN (" Un supported ▁qop ▁value : ▁% s ", ▁value ); ▁} ▁else ▁{ ▁safe c _ rc ▁= ▁mem cmp _ s ( value , ▁sizeof (" auth "), ▁" auth ", ▁sizeof (" auth "), ▁& diff ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" mem cmp _ s ▁error ▁0 x % xO \ n ", ▁safe c _ rc ); ▁} ▁if ▁( diff ▁&& ▁( safe c _ rc ▁ == ▁EOK )) ▁{ ▁EST _ LOG _ WARN (" Un supported ▁qop ▁value : ▁% s ", ▁value ); ▁} ▁} ▁} ▁else ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁if ▁(! est _ strcasecmp _ s ( token , ▁" algorithm ")) ▁{ ▁if ▁( ( value ▁= ▁HTNextField (& p )) ▁&& ▁est _ strcasecmp _ s ( value , ▁" md 5 ")) ▁{ ▁EST _ LOG _ ERR (" Un supported ▁digest ▁algorithm : ▁% s ", ▁value ); ▁/* ▁** ▁We ▁only ▁support ▁ MD 5 ▁for ▁the ▁moment ▁*/ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁if ▁(! est _ strcasecmp _ s ( token , ▁" error ")) ▁{ ▁if ▁( ( value ▁= ▁HTNextField (& p ))) ▁{ ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> token _ error , ▁ MAX _ TOKEN _ ERROR , ▁value , ▁ MAX _ TOKEN _ ERROR )) ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁if ▁(! est _ strcasecmp _ s ( token , ▁" error _ description ")) ▁{ ▁if ▁( ( value ▁= ▁HTNextField (& p ))) ▁{ ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> token _ error _ desc , ▁ MAX _ TOKEN _ ERROR _ DESC , ▁value , ▁ MAX _ TOKEN _ ERROR _ DESC )) ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁{ ▁EST _ LOG _ WARN (" Un supported ▁auth ▁token ▁ignored : ▁% s ", ▁token ); ▁} ▁if ▁( rv ▁ == ▁EST _ ERR _ INVALID _ TOKEN ) ▁{ ▁mem zero _ s ( ctx -> s _ nonce , ▁ MAX _ NONCE +1 ); ▁break ; ▁} ▁} ▁return ▁( rv ); ▁} ▁/* ▁* ▁This ▁function ▁parse s ▁the ▁authentication ▁token s ▁from ▁* ▁the ▁server ▁when ▁the ▁server ▁is ▁requesting ▁HTTP ▁digest ▁* ▁authentication . ▁The ▁token s ▁are ▁required ▁to ▁generate ▁* ▁a ▁valid ▁authentication ▁response ▁in ▁future ▁HTTP ▁* ▁requests . ▁*/ ▁static ▁HTTP _ HEADER ▁* ▁parse _ http _ headers ▁( un signed ▁char ▁** buf , ▁int ▁* num _ headers ) ▁{ ▁int ▁i ; ▁HTTP _ HEADER ▁* hdrs ; ▁char ▁* hdr _ end ; ▁errno _ t ▁safe c _ rc ; ▁* num _ headers ▁= ▁0; ▁hdrs ▁= ▁malloc ( sizeof ( HTTP _ HEADER ) ▁* ▁ MAX _ HEADERS ); ▁if ▁(! hdrs ) ▁{ ▁EST _ LOG _ ERR (" malloc ▁failure "); ▁return ▁( NULL ); ▁} ▁/* ▁* ▁Find ▁offset ▁of ▁header ▁delimi nter ▁*/ ▁safe c _ rc ▁= ▁strstr _ s ( ( char ▁*) ▁* buf , ▁ strnlen _ s ( ( char ▁*) ▁* buf , ▁R SIZE _ MAX _ STR ) , ▁"\ r \ n \ r \ n ", ▁ MAX _ HEADER _ DEL I MIT ER _ LEN , ▁& hdr _ end ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" strstr _ s ▁error ▁0 x % xO \ n ", ▁safe c _ rc ); ▁} ▁/* ▁* ▁S kip ▁the ▁first ▁line ▁*/ ▁skip ( ( char ▁* *) buf , ▁"\ r \ n "); ▁for ▁( i ▁= ▁0; ▁i ▁ < ▁ MAX _ HEADERS ; ▁i ++) ▁{ ▁hdrs [ i ]. name ▁= ▁skip _ quoted ( ( char ▁* *) buf , ▁":" , ▁" ▁" , ▁0); ▁hdrs [ i ]. value ▁= ▁skip ( ( char ▁* *) buf , ▁"\ r \ n "); ▁f flu sh ( stdout ); ▁EST _ LOG _ INFO (" F ound ▁HTTP ▁header ▁ -> ▁% s :% s ", ▁hdrs [ i ]. name , ▁hdrs [ i ]. value ); ▁f flu sh ( stdout ); ▁if ▁( hdrs [ i ]. name [0] ▁ == ▁'\0') ▁{ ▁break ; ▁} ▁* num _ headers ▁= ▁i ▁+ ▁1; ▁if ▁((* buf ) ▁> ▁( un signed ▁char ▁*) hdr _ end ) ▁{ ▁break ; ▁} ▁} ▁EST _ LOG _ INFO (" F ound ▁% d ▁HTTP ▁headers \ n ", ▁* num _ headers ); ▁return ▁( hdrs ); ▁} ▁/* ▁* ▁This ▁function ▁parse s ▁the ▁HTTP ▁status ▁code ▁* ▁in ▁the ▁first ▁header . ▁On ly ▁a ▁hand ful ▁of ▁codes ▁are ▁* ▁handled ▁by ▁EST . ▁We ▁are ▁not ▁a ▁full ▁HTTP ▁stack . ▁Any ▁* ▁un recognize d ▁codes ▁will ▁result ▁in ▁an ▁error . ▁* ▁Note ▁that ▁HTTP ▁1.1 ▁is ▁expected . ▁*/ ▁static ▁int ▁est _ io _ parse _ response _ status _ code ▁( un signed ▁char ▁* buf ) ▁{ ▁if ▁(! strnc mp ( ( const ▁char ▁*) buf , ▁EST _ HTTP _ HDR _200, ▁ strnlen _ s ( EST _ HTTP _ HDR _200, ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁200 ; ▁} ▁else ▁if ▁(! strnc mp ( ( const ▁char ▁*) buf , ▁EST _ HTTP _ HDR _202, ▁ strnlen _ s ( EST _ HTTP _ HDR _202, ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁202 ; ▁} ▁else ▁if ▁(! strnc mp ( ( const ▁char ▁*) buf , ▁EST _ HTTP _ HDR _204, ▁ strnlen _ s ( EST _ HTTP _ HDR _204, ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁204 ; ▁} ▁else ▁if ▁(! strnc mp ( ( const ▁char ▁*) buf , ▁EST _ HTTP _ HDR _400, ▁ strnlen _ s ( EST _ HTTP _ HDR _400, ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁400 ; ▁} ▁else ▁if ▁(! strnc mp ( ( const ▁char ▁*) buf , ▁EST _ HTTP _ HDR _401, ▁ strnlen _ s ( EST _ HTTP _ HDR _401, ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁401 ; ▁} ▁else ▁if ▁(! strnc mp ( ( const ▁char ▁*) buf , ▁EST _ HTTP _ HDR _404, ▁ strnlen _ s ( EST _ HTTP _ HDR _404, ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁404 ; ▁} ▁else ▁if ▁(! strnc mp ( ( const ▁char ▁*) buf , ▁EST _ HTTP _ HDR _423, ▁ strnlen _ s ( EST _ HTTP _ HDR _423, ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁423 ; ▁} ▁else ▁{ ▁EST _ LOG _ ERR (" Un handled ▁HTTP ▁response ▁% s ", ▁buf ); ▁return ▁-1; ▁} ▁} ▁/* ▁* ▁This ▁function ▁search es ▁for ▁and ▁process es ▁the ▁W WW - Authenticate ▁header ▁from ▁* ▁the ▁server . ▁The ▁result ▁is ▁the ▁setting ▁of ▁the ▁auth _ mode ▁value ▁in ▁the ▁* ▁context . ▁If ▁there ▁is ▁no ▁W WW - Authenticate ▁header , ▁or ▁the ▁values ▁in ▁the ▁* ▁header ▁are ▁invalid , ▁it ▁will ▁set ▁the ▁auth _ mode ▁to ▁a ▁failure ▁setting . ▁If ▁* ▁there ▁are ▁multip le ▁ Authenticate ▁headers , ▁only ▁the ▁first ▁one ▁will ▁be ▁* ▁processed . ▁*/ ▁static ▁void ▁est _ io _ parse _ http _ auth _ request ▁( EST _ CTX ▁* ctx , ▁HTTP _ HEADER ▁* hdrs , ▁int ▁hdr _ cnt ) ▁{ ▁int ▁i ; ▁EST _ ERROR ▁rv ; ▁int ▁auth _ found ▁= ▁0; ▁/* ▁* ▁W alk ▁the ▁headers ▁look ing ▁for ▁the ▁W WW - Authenticate . ▁We ' ll ▁* ▁only ▁process ▁the ▁first ▁one . ▁If ▁an ▁err one ous ▁second ▁one ▁* ▁is ▁included , ▁it ▁will ▁be ▁ignored . ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁ < ▁hdr _ cnt ; ▁i ++) ▁{ ▁if ▁(! strnc mp ( hdrs [ i ]. name , ▁EST _ HTTP _ HDR _ AUTH , ▁ 16)) ▁{ ▁auth _ found ▁= ▁1; ▁if ▁(! strnc mp ( hdrs [ i ]. value , ▁" Basic ", ▁ 5)) ▁{ ▁ctx -> auth _ mode ▁= ▁AUTH _ BASIC ; ▁/* ▁ Parse ▁the ▁realm ▁*/ ▁rv ▁= ▁est _ io _ parse _ auth _ tokens ( ctx , ▁hdrs [ i ]. value ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁ctx -> auth _ mode ▁= ▁AUTH _ FAIL ; ▁} ▁} ▁else ▁if ▁(! strnc mp ( hdrs [ i ]. value , ▁" Digest ", ▁ 6)) ▁{ ▁ctx -> auth _ mode ▁= ▁AUTH _ DIGEST ; ▁/* ▁ Parse ▁the ▁realm ▁and ▁nonce ▁*/ ▁rv ▁= ▁est _ io _ parse _ auth _ tokens ( ctx , ▁hdrs [ i ]. value ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁ctx -> auth _ mode ▁= ▁AUTH _ FAIL ; ▁} ▁} ▁else ▁if ▁(! strnc mp ( hdrs [ i ]. value , ▁" Bearer ", ▁ 6)) ▁{ ▁ctx -> auth _ mode ▁= ▁AUTH _ TOKEN ; ▁/* ▁ Parse ▁the ▁realm ▁and ▁possible ▁token ▁error ▁field s ▁*/ ▁rv ▁= ▁est _ io _ parse _ auth _ tokens ( ctx , ▁hdrs [ i ]. value ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁ctx -> auth _ mode ▁= ▁AUTH _ FAIL ; ▁} ▁} ▁else ▁{ ▁EST _ LOG _ ERR (" Un supported ▁W WW - Authenticate ▁method "); ▁ctx -> auth _ mode ▁= ▁AUTH _ FAIL ; ▁} ▁break ; ▁} ▁} ▁if ▁(! auth _ found ) ▁{ ▁EST _ LOG _ ERR (" No ▁W WW - Authenticate ▁header ▁found "); ▁ctx -> auth _ mode ▁= ▁AUTH _ FAIL ; ▁} ▁return ; ▁} ▁/* ▁* ▁This ▁function ▁takes ▁in ▁the ▁list ▁of ▁headers ▁that ▁we re ▁in ▁the ▁server ' s ▁* ▁response , ▁it ▁walk s ▁through ▁the ▁headers ▁look ing ▁for ▁a ▁Retr y - After ▁response ▁* ▁header . ▁If ▁one ▁is ▁found , ▁the ▁value ▁is ▁parsed ▁and ▁saved ▁away ▁in ▁the ▁EST ▁* ▁context . ▁This ▁value ▁can ▁be ▁in ▁one ▁of ▁two ▁formats , ▁both ▁are ▁represent ed ▁as ▁* ▁an ▁ASCII ▁string . ▁The ▁first ▁format ▁can ▁be ▁a ▁count ▁of ▁the ▁number ▁of ▁seconds ▁* ▁the ▁client ▁should ▁wait ▁before ▁retry ing ▁the ▁request . ▁The ▁second ▁format ▁is ▁a ▁* ▁time / date ▁stamp ▁of ▁the ▁point ▁in ▁time ▁at ▁which ▁the ▁client ▁should ▁retry ▁the ▁* ▁request . ▁The ▁result ▁of ▁this ▁function ▁is ▁the ▁setting ▁of ▁the ▁retry _ after ▁* ▁values ▁in ▁the ▁context . ▁If ▁no ▁retry - after ▁header ▁was ▁received , ▁or ▁was ▁* ▁received ▁and ▁c ould ▁not ▁be ▁parsed , ▁the ▁values ▁will ▁be ▁zero , ▁otherwise , ▁they ▁* ▁are ▁set ▁to ▁the ▁value ▁received . ▁* ▁* ▁NOTE : ▁The ▁EST ▁client ▁currently ▁does ▁not ▁support ▁the ▁time / date ▁format ▁* ▁response ▁and ▁will ▁not ▁process ▁a ▁response ▁in ▁this ▁format . ▁*/ ▁static ▁EST _ ERROR ▁est _ io _ parse _ http _ retry _ after _ resp ▁( EST _ CTX ▁* ctx , ▁HTTP _ HEADER ▁* hdrs , ▁int ▁hdr _ cnt ) ▁{ ▁EST _ ERROR ▁rv ▁= ▁EST _ ERR _ INVALID _ RETRY _ VALUE ; ▁int ▁i ; ▁int ▁ cmp _ result , ▁diff ; ▁int ▁rc ; ▁long ▁long ▁int ▁temp _ ll ; ▁int ▁found ▁= ▁0; ▁/* ▁* ▁Initialize ▁assum ing ▁there ▁was ▁no ▁retry - after ▁header . ▁*/ ▁ctx -> retry _ after _ delay ▁= ▁0; ▁ctx -> retry _ after _ date ▁= ▁0; ▁for ▁( i ▁= ▁0; ▁i ▁ < ▁hdr _ cnt ; ▁i ++) ▁{ ▁ cmp _ result ▁= ▁ strcasecmp _ s ( hdrs [ i ]. name , ▁sizeof ( EST _ HTTP _ HDR _ RETRY _ AFTER ) , ▁EST _ HTTP _ HDR _ RETRY _ AFTER , ▁& diff ); ▁if ▁( cmp _ result ▁ == ▁EOK ▁&& ▁! diff ) ▁{ ▁EST _ LOG _ INFO (" R etry - After ▁value ▁= ▁% s ", ▁hdrs [ i ]. value ); ▁found ▁= ▁1; ▁/* ▁* ▁Determine ▁whether ▁or ▁not ▁the ▁value ▁is ▁a ▁date / time ▁string ▁* ▁or ▁is ▁an ▁integer ▁represent ing ▁the ▁number ▁of ▁seconds ▁* ▁that ▁the ▁client ▁must ▁wait . ▁*/ ▁if ▁( isal p ha (*( char ▁*) hdrs [ i ]. value )) ▁{ ▁# if def ▁RETRY _ AFTER _ DEL AY _ TIME _ SUPPORT ▁int ▁rc ; ▁/* ▁* ▁Convert ▁the ▁date / time ▁string ▁into ▁a ▁time _ t ▁*/ ▁rc ▁= ▁parse date ( hdrs [ i ]. value , ▁& ctx -> retry _ after _ date ); ▁if ▁( rc ▁ != ▁ PARSE DAT E _ OK ) ▁{ ▁EST _ LOG _ ERR (" R etry - After ▁value ▁c ould ▁not ▁be ▁parsed "); ▁} ▁# else ▁/* ▁* ▁This ▁format ▁is ▁not ▁currently ▁supported . ▁*/ ▁EST _ LOG _ ERR (" R etry - After ▁value ▁not ▁in ▁the ▁correct ▁format "); ▁# endif ▁} ▁else ▁{ ▁/* ▁* ▁make ▁sure ▁it ' s ▁all ▁digits , ▁make ▁sure ▁it ' s ▁no ▁large r ▁than ▁a ▁* ▁fou r ▁byte ▁integer , ▁and ▁cache ▁away ▁the ▁value ▁returned ▁for ▁* ▁the ▁retry ▁delay . ▁*/ ▁rc ▁= ▁str isdigit _ s ( hdrs [ i ]. value , ▁10); ▁// ▁max ▁of ▁ 10 ▁deci mal ▁places ▁if ▁( rc ) ▁{ ▁temp _ ll ▁= ▁at oll ( hdrs [ i ]. value ); ▁if ▁( temp _ ll ▁ < = ▁INT _ MAX ) ▁{ ▁ctx -> retry _ after _ delay ▁= ▁( int ) ▁temp _ ll ; ▁rv ▁= ▁EST _ ERR _ CA _ ENROLL _ RETRY ; ▁} ▁else ▁{ ▁EST _ LOG _ ERR (" R etry - After ▁value ▁too ▁large "); ▁} ▁} ▁else ▁{ ▁EST _ LOG _ ERR (" R etry - After ▁value ▁c ould ▁not ▁be ▁parsed "); ▁} ▁} ▁} ▁} ▁if ▁( found ▁ == ▁0) ▁{ ▁EST _ LOG _ ERR (" R etry - After ▁header ▁missing "); ▁} ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁function ▁verifie s ▁the ▁content ▁type ▁header ▁and ▁also ▁* ▁returns ▁the ▁length ▁of ▁the ▁content ▁header . ▁The ▁* ▁content ▁type ▁is ▁important . ▁For ▁example , ▁the ▁content ▁* ▁type ▁is ▁expected ▁to ▁be ▁pkcs 7 ▁on ▁a ▁simple ▁enrollment . ▁*/ ▁static ▁int ▁est _ io _ check _ http _ hdrs ▁( HTTP _ HEADER ▁* hdrs , ▁int ▁hdr _ cnt , ▁EST _ OPERATION ▁op ) ▁{ ▁int ▁i ; ▁int ▁cl ▁= ▁0; ▁int ▁content _ type _ present ▁= ▁0, ▁content _ length _ present ▁= ▁0; ▁int ▁ cmp _ result ; ▁/* ▁* ▁Tra ver se ▁all ▁the ▁http ▁headers ▁and ▁process ▁the ▁ones ▁that ▁need ▁to ▁be ▁* ▁checked ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁ < ▁hdr _ cnt ; ▁i ++) ▁{ ▁/* ▁* ▁Content ▁type ▁*/ ▁mem cmp _ s ( hdrs [ i ]. name , ▁sizeof ( EST _ HTTP _ HDR _ CT ) , ▁EST _ HTTP _ HDR _ CT , ▁sizeof ( EST _ HTTP _ HDR _ CT ) , ▁& cmp _ result ); ▁if ▁(! cmp _ result ) ▁{ ▁content _ type _ present ▁= ▁1; ▁/* ▁* ▁Verify ▁content ▁is ▁pkcs 7 ▁data ▁*/ ▁mem cmp _ s ( hdrs [ i ]. value , ▁ strnlen _ s ( est _ op _ m ap [ op ]. content _ type , ▁est _ op _ m ap [ op ]. length ) , ▁est _ op _ m ap [ op ]. content _ type , ▁ strnlen _ s ( est _ op _ m ap [ op ]. content _ type , ▁est _ op _ m ap [ op ]. length ) , ▁& cmp _ result ); ▁if ▁( cmp _ result ) ▁{ ▁EST _ LOG _ ERR (" HTTP ▁content ▁type ▁is ▁% s ", ▁hdrs [ i ]. value ); ▁return ▁0; ▁} ▁} ▁else ▁{ ▁/* ▁* ▁Content ▁Length ▁*/ ▁mem cmp _ s ( hdrs [ i ]. name , ▁sizeof ( EST _ HTTP _ HDR _ CL ) , ▁EST _ HTTP _ HDR _ CL , ▁sizeof ( EST _ HTTP _ HDR _ CL ) , ▁& cmp _ result ); ▁if ▁(! cmp _ result ) ▁{ ▁content _ length _ present ▁= ▁1; ▁cl ▁= ▁at oi ( hdrs [ i ]. value ); ▁} ▁} ▁} ▁/* ▁* ▁M ake ▁sure ▁all ▁the ▁necessary ▁headers ▁we re ▁present . ▁*/ ▁if ▁( content _ type _ present ▁ == ▁0 ▁ ) ▁{ ▁EST _ LOG _ ERR (" M issing ▁HTTP ▁content ▁type ▁header "); ▁return ▁0; ▁} ▁else ▁if ▁( content _ length _ present ▁ == ▁0 ▁ ) ▁{ ▁EST _ LOG _ ERR (" M issing ▁HTTP ▁content ▁length ▁header "); ▁return ▁0; ▁} ▁return ▁cl ; ▁} ▁/* ▁* ▁This ▁function ▁verifie s ▁the ▁content ▁type ▁header ▁and ▁also ▁* ▁returns ▁the ▁length ▁of ▁the ▁content ▁header . ▁The ▁* ▁content ▁type ▁is ▁important . ▁For ▁example , ▁the ▁content ▁* ▁type ▁is ▁expected ▁to ▁be ▁pkcs 7 ▁on ▁a ▁simple ▁enrollment . ▁*/ ▁static ▁int ▁est _ ssl _ read ▁( SSL ▁* ssl , ▁un signed ▁char ▁* buf , ▁int ▁buf _ max , ▁int ▁sock _ read _ timeout ) ▁{ ▁int ▁timeout ; ▁int ▁read _ fd ; ▁int ▁rv ; ▁struct ▁poll fd ▁pfd ; ▁/* ▁* ▁load ▁up ▁the ▁time val ▁struct ▁to ▁be ▁passed ▁to ▁the ▁select ▁*/ ▁timeout ▁= ▁sock _ read _ timeout ▁* ▁ 1000 ; ▁read _ fd ▁= ▁SSL _ get _ fd ( ssl ); ▁pfd . fd ▁= ▁read _ fd ; ▁pfd . event s ▁= ▁POLL IN ; ▁pfd . revent s ▁= ▁0; ▁errno ▁= ▁0; ▁rv ▁= ▁POLL (& pfd , ▁1, ▁timeout ); ▁if ▁( rv ▁ == ▁0) ▁{ ▁EST _ LOG _ ERR (" Socket ▁poll ▁timeout . ▁No ▁data ▁received ▁from ▁server . "); ▁return ▁-1; ▁} ▁else ▁if ▁( ▁rv ▁ == ▁-1) ▁{ ▁EST _ LOG _ ERR (" Socket ▁read ▁failure . ▁errno ▁= ▁% d ", ▁errno ); ▁return ▁-1; ▁} ▁else ▁{ ▁return ▁( SSL _ read ( ssl , ▁buf , ▁buf _ max ) ); ▁} ▁} ▁/* ▁* ▁This ▁function ▁extract s ▁data ▁from ▁the ▁SSL ▁context ▁and ▁put s ▁* ▁it ▁into ▁a ▁buffer . ▁*/ ▁static ▁int ▁est _ io _ read _ raw ▁( SSL ▁* ssl , ▁un signed ▁char ▁* buf , ▁int ▁buf _ max , ▁int ▁* read _ cnt , ▁int ▁sock _ read _ timeout ) ▁{ ▁int ▁cur _ cnt ; ▁char ▁ peek _ read _ buf ; ▁* read _ cnt ▁= ▁0; ▁cur _ cnt ▁= ▁est _ ssl _ read ( ssl , ▁buf , ▁buf _ max , ▁sock _ read _ timeout ); ▁if ▁( cur _ cnt ▁ < ▁0) ▁{ ▁EST _ LOG _ ERR (" TLS ▁read ▁error ▁1 "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ SSL _ READ ); ▁} ▁* read _ cnt ▁+= ▁cur _ cnt ; ▁/* ▁* ▁Multi ple ▁calls ▁to ▁SSL _ read ▁ma y ▁be ▁required ▁to ▁get ▁the ▁full ▁* ▁HTTP ▁payload . ▁*/ ▁while ▁( cur _ cnt ▁> ▁0 ▁&& ▁* read _ cnt ▁ < ▁buf _ max ) ▁{ ▁cur _ cnt ▁= ▁est _ ssl _ read ( ssl , ▁( buf ▁+ ▁* read _ cnt ) , ▁( buf _ max ▁- ▁* read _ cnt ) , ▁sock _ read _ timeout ); ▁if ▁( cur _ cnt ▁ < ▁0) ▁{ ▁EST _ LOG _ ERR (" TLS ▁read ▁error "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ SSL _ READ ); ▁} ▁* read _ cnt ▁+= ▁cur _ cnt ; ▁} ▁if ▁((* read _ cnt ▁ == ▁buf _ max ) ▁&& ▁SSL _ peek ( ssl , ▁& peek _ read _ buf , ▁1)) ▁{ ▁EST _ LOG _ ERR (" B uffer ▁too ▁small ▁for ▁received ▁message "); ▁return ( EST _ ERR _ READ _ BU FFER _ TOO _ SMALL ); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁This ▁function ▁provide s ▁the ▁primar y ▁entry ▁point ▁into ▁* ▁this ▁ module . ▁It ' s ▁used ▁by ▁the ▁EST ▁client ▁to ▁read ▁the ▁* ▁HTTP ▁response ▁from ▁the ▁server . ▁The ▁data ▁is ▁read ▁from ▁* ▁the ▁SSL ▁context ▁and ▁HTTP ▁parsing ▁is ▁invoked . ▁* ▁* ▁If ▁EST _ ERR _ NONE ▁is ▁returned ▁then ▁the ▁raw _ buf ▁buffer ▁must ▁* ▁be ▁free d ▁by ▁the ▁caller , ▁otherwise , ▁it ▁is ▁free d ▁here . ▁*/ ▁EST _ ERROR ▁est _ io _ get _ response ▁( EST _ CTX ▁* ctx , ▁SSL ▁* ssl , ▁EST _ OPERATION ▁op , ▁un signed ▁char ▁** buf , ▁int ▁* payload _ len ) ▁{ ▁int ▁rv ▁= ▁EST _ ERR _ NONE ; ▁HTTP _ HEADER ▁* hdrs ; ▁int ▁hdr _ cnt ; ▁int ▁http _ status ; ▁un signed ▁char ▁* raw _ buf , ▁* payload _ buf , ▁* payload ; ▁int ▁raw _ len ▁= ▁0; ▁raw _ buf ▁= ▁malloc ( EST _ CA _ MAX ); ▁if ▁( raw _ buf ▁ == ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁memory "); ▁return ▁EST _ ERR _ MALLOC ; ▁} ▁mem zero _ s ( raw _ buf , ▁EST _ CA _ MAX ); ▁payload ▁= ▁raw _ buf ; ▁/* ▁* ▁Rea d ▁the ▁raw ▁data ▁from ▁the ▁SSL ▁connection ▁*/ ▁rv ▁= ▁est _ io _ read _ raw ( ssl , ▁raw _ buf , ▁EST _ CA _ MAX , ▁& raw _ len , ▁ctx -> read _ timeout ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ INFO (" No ▁valid ▁response ▁to ▁process "); ▁free ( raw _ buf ); ▁return ▁( rv ); ▁} ▁if ▁( raw _ len ▁ < = ▁0) ▁{ ▁EST _ LOG _ WARN (" Receive d ▁empty ▁HTTP ▁response ▁from ▁server "); ▁free ( raw _ buf ); ▁return ▁( EST _ ERR _ HTTP _ NOT _ FOUND ); ▁} ▁EST _ LOG _ INFO (" R ead ▁% d ▁bytes ▁of ▁HTTP ▁data ", ▁raw _ len ); ▁/* ▁* ▁ Parse ▁the ▁HTTP ▁header ▁to ▁get ▁the ▁status ▁* ▁Look ▁for ▁status ▁200 ▁for ▁success ▁*/ ▁http _ status ▁= ▁est _ io _ parse _ response _ status _ code ( raw _ buf ); ▁ctx -> last _ http _ status ▁= ▁http _ status ; ▁hdrs ▁= ▁parse _ http _ headers (& payload , ▁& hdr _ cnt ); ▁EST _ LOG _ INFO (" HTTP ▁status ▁% d ▁received ", ▁http _ status ); ▁/* ▁* ▁ Check ▁the ▁Status ▁header ▁first ▁to ▁see ▁* ▁if ▁the ▁server ▁accepted ▁our ▁request . ▁*/ ▁switch ▁( http _ status ) ▁{ ▁case ▁200 : ▁/* ▁Server ▁report ed ▁OK , ▁nothing ▁to ▁do ▁*/ ▁break ; ▁case ▁204 : ▁case ▁404 : ▁EST _ LOG _ ERR (" Server ▁respond ed ▁with ▁204 / 404, ▁no ▁content ▁or ▁not ▁found "); ▁if ▁( op ▁ == ▁EST _ OP _ CSRATTRS ) ▁{ ▁rv ▁= ▁EST _ ERR _ NONE ; ▁} ▁else ▁if ▁( http _ status ▁ == ▁404) ▁{ ▁rv ▁= ▁EST _ ERR _ HTTP _ NOT _ FOUND ; ▁} ▁else ▁{ ▁rv ▁= ▁EST _ ERR _ UNKNOWN ; ▁} ▁break ; ▁case ▁202 : ▁/* ▁Server ▁is ▁ask ing ▁for ▁a ▁retry ▁*/ ▁EST _ LOG _ INFO (" EST ▁server ▁respond ed ▁with ▁retry - after "); ▁rv ▁= ▁est _ io _ parse _ http _ retry _ after _ resp ( ctx , ▁hdrs , ▁hdr _ cnt ); ▁break ; ▁case ▁400 : ▁EST _ LOG _ ERR (" HTTP ▁response ▁from ▁EST ▁server ▁was ▁ BAD ▁REQUEST "); ▁rv ▁= ▁EST _ ERR _ HTTP _ BAD _ REQ ; ▁break ; ▁case ▁401 : ▁/* ▁Server ▁is ▁requesting ▁user ▁auth ▁credentials ▁*/ ▁EST _ LOG _ INFO (" EST ▁server ▁requesting ▁user ▁authentication "); ▁/* ▁ Check ▁if ▁we ' ve ▁al ready ▁tri ed ▁authenticating , ▁if ▁so , ▁then ▁bail ▁* ▁First ▁time ▁through , ▁auth _ mode ▁will ▁be ▁set ▁to ▁ NONE ▁*/ ▁if ▁( ctx -> auth _ mode ▁ == ▁AUTH _ DIGEST ▁|| ▁ctx -> auth _ mode ▁ == ▁AUTH _ BASIC ▁|| ▁ctx -> auth _ mode ▁ == ▁AUTH _ TOKEN ) ▁{ ▁ctx -> auth _ mode ▁= ▁AUTH _ FAIL ; ▁rv ▁= ▁EST _ ERR _ AUTH _ FAIL ; ▁break ; ▁} ▁est _ io _ parse _ http _ auth _ request ( ctx , ▁hdrs , ▁hdr _ cnt ); ▁rv ▁= ▁EST _ ERR _ AUTH _ FAIL ; ▁break ; ▁case ▁423 : ▁EST _ LOG _ ERR (" Server ▁respond ed ▁with ▁423 , ▁the ▁content ▁we ▁are ▁attempt ing ▁to ▁access ▁is ▁locked "); ▁rv ▁= ▁EST _ ERR _ HTTP _ LOCKED ; ▁break ; ▁case ▁-1 : ▁/* ▁Un supported ▁HTTP ▁response ▁*/ ▁EST _ LOG _ ERR (" Un supported ▁HTTP ▁response ▁from ▁EST ▁server ▁(% d )", ▁http _ status ); ▁rv ▁= ▁EST _ ERR _ UNKNOWN ; ▁break ; ▁default : ▁/* ▁Some ▁other ▁HTTP ▁response ▁was ▁given , ▁do ▁we ▁want ▁to ▁handle ▁these ? ▁*/ ▁EST _ LOG _ ERR (" HTTP ▁response ▁from ▁EST ▁server ▁was ▁% d ", ▁http _ status ); ▁rv ▁= ▁EST _ ERR _ HTTP _ UNSUPPORTED ; ▁break ; ▁} ▁if ▁( rv ▁ == ▁EST _ ERR _ NONE ) ▁{ ▁/* ▁* ▁Get ▁the ▁Content - Type ▁and ▁Content - Length ▁headers ▁* ▁and ▁verify ▁the ▁HTTP ▁response ▁contains ▁the ▁correct ▁amount ▁* ▁of ▁data . ▁*/ ▁* payload _ len ▁= ▁est _ io _ check _ http _ hdrs ( hdrs , ▁hdr _ cnt , ▁op ); ▁EST _ LOG _ INFO (" HTTP ▁Content ▁len =% d ", ▁* payload _ len ); ▁if ▁(* payload _ len ▁> ▁EST _ CA _ MAX ) ▁{ ▁EST _ LOG _ ERR (" Content ▁Length ▁large r ▁than ▁maximum ▁value ▁of ▁% d . ", ▁EST _ CA _ MAX ); ▁rv ▁= ▁EST _ ERR _ UNKNOWN ; ▁* payload _ len ▁= ▁0; ▁* buf ▁= ▁NULL ; ▁} ▁else ▁if ▁(* payload _ len ▁ == ▁0) ▁{ ▁* payload _ len ▁= ▁0; ▁* buf ▁= ▁NULL ; ▁} ▁else ▁{ ▁/* ▁* ▁A llocate ▁the ▁buffer ▁to ▁hold ▁the ▁payload ▁to ▁be ▁passed ▁back ▁*/ ▁payload _ buf ▁= ▁malloc (* payload _ len ); ▁if ▁(! payload _ buf ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁memory "); ▁free ( raw _ buf ); ▁free ( hdrs ); ▁return ▁EST _ ERR _ MALLOC ; ▁} ▁memcpy _ s ( payload _ buf , ▁* payload _ len , ▁payload , ▁* payload _ len ); ▁* buf ▁= ▁payload _ buf ; ▁} ▁} ▁if ▁( raw _ buf ) ▁{ ▁free ( raw _ buf ); ▁} ▁if ▁( hdrs ) ▁{ ▁free ( hdrs ); ▁} ▁return ▁( rv ); ▁}