▁p ackage ▁smos . utility ; ▁import ▁smos . exception . Entity N otFoundException ; ▁import ▁smos . storage . connect ionManagement . DBConnection ; ▁import ▁smos . storage . connect ionManagement . exception . Connection Exception ; ▁import ▁java . util . Calendar ; ▁import ▁java . util . Date ; ▁import ▁java . util . Gr egorianCalendar ; ▁import ▁java . util . TimeZone ; ▁import ▁java . sql .* ; ▁import ▁java . text . DateFormat ; ▁/** ▁* ▁Quest a ▁classe ▁contiene ▁un ▁ insi eme ▁di ▁ utility ▁per ▁la ▁gestione ▁del ▁sistema . ▁*/ ▁p ublic ▁class ▁Utility ▁{ ▁/** ▁* ▁Costanti ▁*/ ▁p ublic ▁static ▁final ▁char ▁S LAS H ▁= ▁( char ) ▁4 7; // ▁carattere ▁' / ' ▁in ▁ asci i ▁/** ▁* ▁*/ ▁p ublic ▁static ▁final ▁char ▁ BACK S LAS H ▁= ▁( char ) ▁92 ; // ▁carattere ▁' \ ' ▁in ▁ asci i ▁/** ▁* ▁*/ ▁p ublic ▁static ▁final ▁String [] ▁day ▁= ▁{ ▁" lu ne di ", ▁" mar ted i ", ▁" mer col edi ", ▁" gio vedi ", ▁" ven er di ", ▁" s ab ato " } ; ▁/** ▁* ▁*/ ▁p ublic ▁static ▁final ▁String [] ▁valid Ho ur ▁= ▁{ ▁"08 :00", ▁"08 :30", ▁"0 9:00", ▁"0 9:30", ▁ "10:00 ", ▁" 10 :30", ▁"11 :00", ▁"11 :30", ▁"12 :00", ▁"12 :30", ▁"13 :00", ▁"13 :30", ▁"14 :00", ▁"14 :30", ▁"15 :00", ▁"15 :30", ▁"16: 00", ▁"16: 30", ▁"17: 00", ▁"17: 30", ▁"18 :00", ▁"18 :30", ▁" 1 9:00", ▁" 1 9:30", ▁" 20 :00" ▁} ; ▁p ublic ▁static ▁final ▁String [] ▁month ▁= ▁{ " g en "," fe b "," mar "," apr "," mag "," giu "," lu g "," ag o "," set "," ott "," no v "," d ic " } ; ▁/** ▁* ▁*/ ▁p ublic ▁static ▁final ▁String [] ▁request State ▁= ▁{ ▁" effettuata ", ▁" rifiutat a ", ▁" accettata ", ▁" eliminata " ▁} ; ▁// Variabil i ▁da ▁impostare ▁all ' a v vi o ▁di ▁To m ca t ▁// Variabil i ▁per ▁l ' aspett o ▁g ra f ico ▁del ▁progr am ma ▁priv ate ▁static ▁String ▁imageHeaderPath ▁= ▁" "; ▁priv ate ▁static ▁String ▁image HeaderLogoPath ▁= ▁" "; ▁priv ate ▁static ▁String ▁imageLeftColumn ▁= ▁" "; ▁priv ate ▁static ▁String ▁textFooter ▁= ▁" "; ▁// server ▁ smtp ▁per ▁ invio ▁e - mail ▁priv ate ▁static ▁String ▁ serverSmtp ▁= ▁" smtp . tel e 2. it "; ▁// Giorni ▁minimi ▁di ▁di stanza ▁dall ' es ame ▁per ▁sotto scriv ere ▁o ▁eliminare ▁una ▁prenotazione ▁priv ate ▁static ▁int ▁n eedDayBeforeExam ▁= ▁0; ▁// Giorni ▁massim i ▁di ▁di stanza ▁dall ' es ame ▁per ▁sotto scriv ere ▁una ▁prenotazione ▁priv ate ▁static ▁int ▁ maxDayBeforeExam ▁= ▁0; ▁// pdf ▁path ▁per ▁il ▁p ercorso ▁di ▁memor izzazione ▁dei ▁file ▁pdf ▁priv ate ▁static ▁String ▁ pdfPath ▁= ▁" "; ▁// ▁up load ▁path ▁per ▁il ▁p ercorso ▁di ▁memor izzazione ▁dei ▁file ▁per ▁l ' import azione ▁dei ▁dati ▁priv ate ▁static ▁String ▁ uploadPath ▁= ▁" "; ▁// Variabil i ▁per ▁la ▁connessione ▁al ▁database ▁priv ate ▁static ▁String ▁driverMySql ▁= ▁" com . mysql . jdbc . Driver "; ▁priv ate ▁static ▁String ▁ fullPathDatabase ▁= ▁" jdbc : mysql :// localhost : 3 306 / smos "; ▁priv ate ▁static ▁String ▁userName ▁= ▁" root "; ▁priv ate ▁static ▁String ▁password ▁= ▁" "; ▁priv ate ▁static ▁int ▁maxPoolSize ▁= ▁200 ; ▁priv ate ▁static ▁int ▁waitTimeout ▁= ▁12 0000 ; ▁priv ate ▁static ▁int ▁activeTimeout ▁= ▁6 00000 ; ▁priv ate ▁static ▁int ▁poolTimeout ▁= ▁27 000000 ; ▁/** ▁* ▁Ritorna , ▁dati ▁un ▁campo ▁e ▁una ▁tabella , ▁il ▁valore ▁massimo ▁del ▁campo ▁nella ▁* ▁tabella . ▁* ▁* ▁@ param ▁pField ▁* ▁Il ▁campo ▁di ▁cui ▁vogli amo ▁recuperare ▁il ▁valore ▁massimo . ▁* ▁@ param ▁pTable ▁* ▁La ▁tabella ▁in ▁cui ▁ricerca re ▁le ▁informazioni ▁richieste . ▁* ▁@ return ▁Ritorna ▁il ▁valore ▁massimo , ▁del ▁campo ▁pField , ▁passato ▁come ▁* ▁parametro , ▁presente ▁nella ▁tabella ▁pTable , ▁passata ▁come ▁parametro . ▁* ▁* ▁@ throws ▁Entity N otFoundException ▁* ▁@ throws ▁Connection Exception ▁* ▁@ throws ▁SQLException ▁*/ ▁sy nch ron ized ▁static ▁p ublic ▁int ▁ getMax Value ( String ▁pField , ▁String ▁pTable ) ▁throws ▁Entity N otFoundException , ▁Connection Exception , ▁SQLException ▁{ ▁int ▁value ▁= ▁0; ▁Connection ▁connect ▁= ▁null ; ▁try ▁{ ▁/* ▁* ▁Se ▁non ▁sono ▁stati ▁forniti ▁il ▁campo ▁e ▁la ▁tabella ▁restitui amo ▁un ▁* ▁codice ▁di ▁errore ▁*/ ▁if ▁( pField . equals ("")) ▁throw ▁new ▁Entity N otFoundException (); ▁if ▁( pTable . equals ("")) ▁throw ▁new ▁Entity N otFoundException (); ▁/* ▁* ▁Prepar iamo ▁la ▁stringa ▁SQL ▁per ▁recuperare ▁le ▁informazioni ▁* ▁richieste ▁*/ ▁String ▁tSql ▁= ▁" SELECT ▁max (" ▁+ ▁pField ▁+ ▁" ) ▁as ▁new _ field ▁FR OM ▁" ▁+ ▁pTable ; ▁// ▁Otten iamo ▁una ▁ Connessione ▁al ▁DataBase ▁connect ▁= ▁DBConnection . getConnection (); ▁if ▁( connect ▁== ▁null ) ▁throw ▁new ▁Connection Exception (); ▁// ▁Inv iamo ▁la ▁Query ▁al ▁DataBase ▁ResultSet ▁tRs ▁= ▁Utility . query Operation ( connect , ▁tSql ); ▁if ▁( tRs . next ()) ▁value ▁= ▁tRs . getInt (" new _ field "); ▁else ▁throw ▁new ▁Entity N otFoundException (); ▁return ▁value ; ▁} ▁finally ▁{ ▁DBConnection . release Connection ( connect ); ▁} ▁} ▁/** ▁* ▁Convert e ▁una ▁data ▁in ▁una ▁stringa ▁formatta ta ▁per ▁il ▁database . ▁* ▁* ▁@ param ▁pDate ▁* ▁La ▁data ▁da ▁convertire . ▁* ▁@ return ▁Ritorna ▁la ▁data ▁formatta ta ▁per ▁il ▁database . ▁*/ ▁static ▁p ublic ▁String ▁date 2 SQL String ( java . util . Date ▁pDate , ▁boolean ▁pHour ) ▁{ ▁TimeZone ▁t z ▁= ▁TimeZone . getDefault (); ▁Calendar ▁calendar ▁= ▁Calendar . get Instance ( t z ); ▁calendar . set Time ( pDate ); ▁int ▁year ▁= ▁calendar . get ( Calendar . Y EAR ); ▁int ▁month ▁= ▁calendar . get ( Calendar . MO N TH ) ▁+ ▁1; ▁int ▁day ▁= ▁calendar . get ( Calendar . DATE ); ▁String ▁result ▁= ▁year ▁+ ▁ "-" ▁+ ▁month ▁+ ▁ "-" ▁+ ▁day ▁ ; ▁int ▁hour ▁= ▁calendar . get ( Calendar . HO UR _ O F _ DAY ); ▁int ▁min ▁= ▁calendar . get ( Calendar . MIN UT E ); ▁int ▁sec ▁= ▁calendar . get ( Calendar . SECOND ); ▁if ▁( pHour ){ ▁result ▁= ▁result ▁+ ▁" ▁" ▁+ ▁hour ▁+ ▁" :" ▁+ ▁min ▁+ ▁" :" ▁+ ▁sec ; ▁} ▁return ▁result ; ▁} ▁/** ▁* ▁Controlla ▁se ▁la ▁stringa ▁passata ▁come ▁parametro ▁e ' ▁null . ▁* ▁* ▁@ param ▁pStr ▁* ▁La ▁stringa ▁da ▁controllare . ▁* ▁* ▁@ return ▁< code > null </ code > ▁se ▁la ▁stringa ▁e ' ▁null ▁Altr i menti ▁la ▁stringa ▁e ' ▁* ▁passata ▁al ▁metodo ▁< code > Replace </ code > ▁* ▁* ▁@ see ▁# Replace ▁*/ ▁static ▁p ublic ▁String ▁is Null ( String ▁pStr ) ▁{ ▁String ▁tTmp ; ▁if ▁( pStr ▁== ▁null ) ▁tTmp ▁= ▁" null "; ▁else ▁{ ▁pStr ▁= ▁ReplaceAll String s ( pStr , ▁"'" , ▁" \\ ' "); ▁pStr ▁= ▁ReplaceAll String s ( pStr , ▁" \ " ", ▁" \\ " ▁+ ▁" \ " "); ▁tTmp ▁= ▁"'" ▁+ ▁pStr ▁+ ▁"'" ; ▁} ▁return ▁tTmp ; ▁} ▁/** ▁* ▁Controlla ▁se ▁un ▁dato ▁intero ▁ ï¿ 1 ⁄ 2 ▁null . ▁* ▁* ▁@ param ▁pInt ▁* ▁Il ▁dato ▁intero ▁da ▁controllare . ▁* ▁@ return ▁Ritorna ▁il ▁dato ▁in ▁format o ▁stringa ▁se ▁il ▁dato ▁ ï¿ 1 ⁄ 2 ▁divers o ▁da ▁zero , ▁* ▁altrimenti ▁la ▁stringa ▁null . ▁*/ ▁static ▁p ublic ▁String ▁is Null ( Integer ▁pInt ) ▁{ ▁String ▁tIntString ; ▁if ▁( pInt ▁== ▁null ) ▁tIntString ▁= ▁" null "; ▁else ▁tIntString ▁= ▁pInt . toString (); ▁return ▁tIntString ; ▁} ▁/** ▁* ▁Controlla ▁se ▁una ▁data ▁e ' ▁null . ▁* ▁* ▁@ param ▁pDate ▁* ▁la ▁data ▁da ▁controllare . ▁* ▁* ▁@ return ▁Ritorna ▁la ▁stringa ▁che ▁rappresenta ▁la ▁data ▁passata ▁in ▁input , ▁* ▁formatta ta ▁per ▁il ▁database . ▁*/ ▁static ▁p ublic ▁String ▁is Null ( java . util . Date ▁pDate ) ▁{ ▁return ▁"'" ▁+ ▁date 2 SQL String ( pDate , false ) ▁+ ▁"'" ; ▁} ▁static ▁p ublic ▁String ▁clear ( String ▁pString ){ ▁int ▁start ▁= ▁0; ▁int ▁start 2 ▁= ▁0; ▁int ▁end ▁= ▁0; ▁int ▁end 2 ▁= ▁0; ▁String ▁result ▁= ▁" "; ▁String ▁result 2 ▁= ▁" "; ▁while ▁( end ▁>= ▁0) { ▁end ▁= ▁pString . index Of (" ' ", ▁start ); ▁if ▁( end ▁>= ▁0) { ▁result = ▁result ▁+ p String . substring ( start , ▁end ); ▁result ▁= ▁result ▁+ ▁" \\ ' "; ▁start ▁= ▁end +1; ▁} ▁else ▁result ▁= ▁result ▁+ ▁pString . substring ( start ); ▁} ▁while ▁( end 2 ▁>= ▁0) { ▁end 2 ▁= ▁result . index Of (" \ n ", ▁start 2 ); ▁if ▁( end 2 ▁>= ▁0) { ▁result 2= ▁result 2 ▁+ result . substring ( start 2, ▁end 2 - 1); ▁result 2 ▁= ▁result 2 ▁+ ▁" ▁" ; ▁start 2 ▁= ▁end 2 +1; ▁} ▁else ▁result 2 ▁= ▁result 2 ▁+ ▁result . substring ( start 2 ); ▁} ▁return ( result 2 ); ▁} ▁/** ▁* ▁Convert e ▁una ▁String ▁in ▁Integer . ▁* ▁* ▁@ param ▁pStr ▁* ▁La ▁String ▁da ▁convertire . ▁* ▁* ▁@ return ▁L ' Integer ▁contenut o ▁nella ▁String ▁< code >0 </ code > ▁se ▁non ▁ ï¿ 1 ⁄ 2 ▁* ▁possibile ▁la ▁conversion e . ▁* ▁*/ ▁static ▁p ublic ▁Integer ▁String 2 Integer ( String ▁pStr ) ▁{ ▁Integer ▁tInteger ; ▁if ▁( ( pStr ▁== ▁null ) ▁|| ▁( pStr . compar eTo ("") ▁== ▁0)) ▁tInteger ▁= ▁new ▁Integer (0) ; ▁else ▁try ▁{ ▁tInteger ▁= ▁Integer . d e code ( pStr ); ▁} ▁ catch ▁( Exception ▁e ) ▁{ ▁tInteger ▁= ▁new ▁Integer (0) ; ▁} ▁return ▁tInteger ; ▁} ▁/** ▁* ▁ Sostituisc e ▁i ▁caratteri ▁' ▁e ▁ \ ▁con ▁' ' ▁nella ▁stringa ▁passata ▁come ▁* ▁parametro . ▁* ▁* ▁@ param ▁pStr ▁* ▁La ▁stringa ▁da ▁trasforma re . ▁* ▁* ▁@ return ▁La ▁ tringa ▁trasforma ta . ▁*/ ▁static ▁p ublic ▁String ▁Replace ( String ▁pStr ) ▁{ ▁String ▁tRis ; ▁tRis ▁= ▁pStr . replaceAll (" \ " ", ▁"'" ); ▁tRis ▁= ▁tRis . replaceAll (" ' ", ▁" \\ ' "); ▁return ▁tRis ; ▁} ▁/** ▁* ▁ Sostituisc e ▁il ▁carattere ▁' ▁con ▁la ▁stringa ▁" ▁" ▁nella ▁stringa ▁passata ▁come ▁* ▁parametro . ▁* ▁* ▁@ param ▁pStr ▁* ▁La ▁stringa ▁da ▁trasforma re . ▁* ▁* ▁@ return ▁La ▁ tringa ▁trasforma ta . ▁*/ ▁static ▁p ublic ▁String ▁Replace Qu ote ( String ▁pStr ) ▁{ ▁String ▁tRis ; ▁tRis ▁= ▁pStr . replaceAll (" ' ", ▁" ▁"); ▁return ▁tRis ; ▁} ▁/** ▁* ▁E segue ▁un ' operazione ▁sul ▁database ▁ tramite ▁una ▁stringa ▁SQL . ▁* ▁* ▁@ param ▁pConnect ▁* ▁La ▁connessione ▁al ▁database . ▁* ▁@ param ▁pSql ▁* ▁La ▁stringa ▁SQL . ▁* ▁* ▁@ return ▁Il ▁numero ▁di ▁record ▁coinvolt i ▁nell ' operazione . ▁* ▁* ▁@ throws ▁SQLException ▁*/ ▁static ▁p ublic ▁int ▁execute Operation ( Connection ▁pConnect , ▁String ▁pSql ) ▁throws ▁SQLException ▁{ ▁Statement ▁stmt ▁= ▁pConnect . createStatement (); ▁int ▁tResult ▁= ▁stmt . executeUpdate ( pSql ); ▁stmt . close (); ▁return ▁tResult ; ▁} ▁/** ▁* ▁E segue ▁una ▁Query ▁SQL ▁sul ▁database . ▁* ▁* ▁@ param ▁pConnect ▁* ▁La ▁connessione ▁al ▁database . ▁* ▁@ param ▁pSql ▁* ▁La ▁stringa ▁SQL . ▁* ▁* ▁@ return ▁Il ▁numero ▁di ▁record ▁coinvolt i ▁nell ' operazione . ▁* ▁* ▁@ throws ▁SQLException ▁*/ ▁static ▁p ublic ▁ResultSet ▁query Operation ( Connection ▁pConnect , ▁String ▁pSql ) ▁throws ▁SQLException ▁{ ▁Statement ▁stmt ▁= ▁pConnect . createStatement (); ▁return ▁stmt . executeQuery ( pSql ); ▁} ▁/** ▁* ▁Convert e ▁un ▁dato ▁booleano ▁in ▁intero . ▁* ▁* ▁@ param ▁pBol ▁* ▁Il ▁valore ▁booleano ▁da ▁convertire ▁in ▁intero . ▁* ▁* ▁@ return ▁Il ▁valore ▁intero ▁corrispondente ▁al ▁valore ▁booleano ▁passato ▁come ▁* ▁parametro . ▁*/ ▁static ▁p ublic ▁int ▁Boolean To Int ( boolean ▁pBol ) ▁{ ▁if ▁( pBol ▁== ▁true ) ▁return ▁1; ▁else ▁return ▁0; ▁} ▁/** ▁* ▁Convert e ▁un ▁dato ▁intero ▁in ▁booleano . ▁* ▁* ▁@ param ▁pInt ▁* ▁Il ▁valore ▁intero ▁da ▁convertire ▁in ▁booleano . ▁* ▁* ▁@ return ▁Il ▁valore ▁booleano ▁corrispondente ▁al ▁valore ▁intero ▁passato ▁come ▁* ▁parametro . ▁*/ ▁static ▁p ublic ▁boolean ▁Int To Boolean ( int ▁pInt ) ▁{ ▁if ▁( pInt ▁== ▁1) ▁return ▁true ; ▁else ▁return ▁false ; ▁} ▁/** ▁* ▁Re stituisc e ▁la ▁data ▁corrente . ▁* ▁* ▁@ return ▁La ▁data ▁corrente . ▁*/ ▁static ▁p ublic ▁java . util . Date ▁today () ▁{ ▁Calendar ▁calendar ▁= ▁Calendar . get Instance (); ▁java . util . Date ▁creationDate ▁= ▁calendar . getTime (); ▁return ▁creationDate ; ▁// ▁java . util . Date ▁creationDate ▁= ▁new ▁java . util . Date (); ▁// ▁Timestamp ▁timeStamp ▁= ▁new ▁Timestamp ( creationDate . getTime ()); ▁// ▁return ▁( java . util . Date ) ▁timeStamp ; ▁} ▁/** ▁* ▁Re stituisc e ▁la ▁data ▁contenut a ▁nella ▁stringa ▁in ▁input . ▁* ▁* ▁@ param ▁pDate ▁* ▁La ▁stringa ▁di ▁cui ▁effettuare ▁il ▁ parse ▁in ▁un ▁data . ▁* ▁* ▁@ return ▁La ▁data ▁convertit a . ▁*/ ▁static ▁p ublic ▁java . util . Date ▁String 2 Date ( String ▁pDate ) ▁{ ▁try ▁{ ▁DateFormat ▁dfDate ▁= ▁DateFormat . getDate Instance (); ▁java . util . Date ▁ tDate ▁= ▁dfDate . parse ( pDate , ▁new ▁java . text . Par se Position (0) ); ▁java . sql . Timestamp ▁timeStamp ▁= ▁new ▁java . sql . Timestamp ( tDate ▁ . getTime ()); ▁return ▁( java . util . Date ) ▁timeStamp ; ▁} ▁ catch ▁( Exception ▁e ) ▁{ ▁try ▁{ ▁DateFormat ▁dfDate ▁= ▁DateFormat . getDate Instance ( ▁DateFormat . SHORT , ▁java . util . Locale . ITA L Y ); ▁java . util . Date ▁ tDate ▁= ▁dfDate . parse ( pDate , ▁new ▁java . text . Par se Position (0) ); ▁java . sql . Timestamp ▁timeStamp ▁= ▁new ▁java . sql . Timestamp ( tDate ▁ . getTime ()); ▁return ▁( java . util . Date ) ▁timeStamp ; ▁} ▁ catch ▁( Exception ▁e 2) ▁{ ▁return ▁null ; ▁} ▁} ▁} ▁/** ▁* ▁Re stituisc e ▁la ▁data ▁in ▁input ▁in ▁format o ▁String . ▁* ▁* ▁@ param ▁pDate ▁* ▁La ▁Data ▁da ▁convertire . ▁* ▁@ param ▁pHour ▁* ▁* ▁@ return ▁La ▁data ▁convertit a . ▁*/ ▁static ▁p ublic ▁String ▁Date 2 String ( java . util . Date ▁pDate , ▁boolean ▁pHour ) ▁{ ▁try ▁{ ▁DateFormat ▁dfDate ▁= ▁DateFormat . getDate Instance ( DateFormat . SHORT ); ▁DateFormat ▁dfTime ▁= ▁DateFormat . getTime Instance ( DateFormat . SHORT ); ▁if ▁( pHour ) ▁return ▁dfDate . format ( pDate ) ▁+ ▁" ▁" ▁+ ▁dfTime . format ( pDate ); ▁else ▁return ▁dfDate . format ( pDate ); ▁} ▁ catch ▁( Exception ▁e ) ▁{ ▁return ▁" "; ▁} ▁} ▁/** ▁* ▁@ param ▁sourceStr ▁* ▁@ param ▁searchFor ▁* ▁@ param ▁replaceWith ▁* ▁@ return ▁la ▁stringa ▁corrispondente ▁a ▁searchBuffer ▁*/ ▁p ublic ▁static ▁String ▁ReplaceAll ( String ▁sourceStr , ▁String ▁searchFor , ▁String ▁replaceWith ) ▁{ ▁StringBuffer ▁searchBuffer ▁= ▁new ▁StringBuffer ( sourceStr ); ▁int ▁hits ▁= ▁0; ▁while ▁( searchBuffer . toString () . to Upper Case () . index Of ( ▁searchFor . to Upper Case (), ▁hits ) ▁>= ▁0) ▁{ ▁int ▁newIndex ▁= ▁searchBuffer . toString () . to Upper Case () . index Of ( ▁searchFor . to Upper Case (), ▁hits ); ▁searchBuffer . replace ( newIndex , ▁newIndex ▁+ ▁searchFor . length (), ▁replaceWith ); ▁hits ++ ; ▁} ▁return ▁searchBuffer . toString (); ▁} ▁// ▁La ▁funzion e ▁precedente ▁va ▁in ▁loop ▁se ▁so stituisc o ▁" \ " ▁con ▁" \\ " ▁// ▁us iamo ▁all ora ▁due ▁variabil e ▁la ▁prima ▁viene ▁" cons um ata " ▁ad ▁ogni ▁occorre nza ▁// ▁del ▁p atter n ▁/** ▁* ▁@ param ▁sourceStr ▁* ▁@ param ▁searchFor ▁* ▁@ param ▁replaceWith ▁* ▁@ return ▁newStringBuffer ▁*/ ▁p ublic ▁static ▁String ▁ReplaceAll String s ( String ▁sourceStr , ▁String ▁searchFor , ▁String ▁replaceWith ) ▁{ ▁StringBuffer ▁searchBuffer ▁= ▁new ▁StringBuffer ( sourceStr ); ▁StringBuffer ▁newStringBuffer ▁= ▁new ▁StringBuffer (" "); ▁while ▁( searchBuffer . toString () . to Upper Case () . index Of ( ▁searchFor . to Upper Case ()) ▁>= ▁0) ▁{ ▁int ▁newIndex ▁= ▁searchBuffer . toString () . to Upper Case () . index Of ( ▁searchFor . to Upper Case ()); ▁newStringBuffer . appen d ( searchBuffer . substring ( 0, ▁newIndex )); ▁newStringBuffer . appen d ( replaceWith ); ▁searchBuffer ▁= ▁new ▁StringBuffer ( searchBuffer . substring ( newIndex ▁+ ▁searchFor . length (), ▁searchBuffer . length ())); ▁} ▁newStringBuffer . appen d ( searchBuffer ); ▁return ▁newStringBuffer . toString (); ▁} ▁/** ▁* ▁@ param ▁sourceStr ▁* ▁@ param ▁removeStr ▁*/ ▁p ublic ▁static ▁void ▁Remove All ( String ▁sourceStr , ▁String ▁removeStr ) ▁{ ▁int ▁nextOccurence ; ▁while ▁( sourceStr . toString () . to Upper Case () . index Of ( ▁removeStr . to Upper Case ()) ▁>= ▁0) ▁{ ▁nextOccurence ▁= ▁sourceStr . toString () . to Upper Case () . index Of ( ▁removeStr . to Upper Case ()); ▁sourceStr ▁= ▁sourceStr . substring ( 0, ▁nextOccurence ) ▁+ ▁sourceStr . substring ( nextOccurence ▁+ ▁removeStr . length (), ▁sourceStr . length ()); ▁} ▁} ▁/** ▁* ▁ Calcola ▁la ▁di stanza ▁in ▁giorni ▁tra ▁2 ▁date ▁pass ate . ▁*/ ▁@ Supp ress Warning s (" d eprecat ion ") ▁p ublic ▁static ▁int ▁daysBetween ( Date ▁today , ▁Date ▁reservationDate ){ ▁int ▁daysBetween ▁= ▁0; ▁long ▁ millisecBetween ▁= ▁0; ▁final ▁int ▁ millisecInADay ▁= ▁8 64 00000 ; ▁Gr egorianCalendar ▁firstDate ▁= ▁new ▁Gr egorianCalendar (); ▁Gr egorianCalendar ▁secondDate ▁= ▁new ▁Gr egorianCalendar (); ▁firstDate . set ( to day . getYear ( )+1900 , ▁today . getMonth (), ▁today . getDate ()); ▁secondDate . set ( reservationDate . getYear ( )+1900 , ▁reservationDate . getMonth (), ▁reservationDate . getDate ()); ▁ millisecBetween ▁= ▁secondDate . getTimeIn Millis () ▁- ▁firstDate . getTimeIn Millis (); ▁daysBetween ▁= ▁( int ) ▁( millisecBetween / millisecInADay ); ▁return ▁( daysBetween ); ▁} ▁/** ▁* ▁@ return ▁Il ▁p ercorso ▁impostat o ▁per ▁i ▁pdf . ▁*/ ▁@ Supp ress Warning s (" static - access ") ▁p ublic ▁static ▁String ▁get PdfPath () ▁{ ▁return ▁Utility . pdfPath ; ▁} ▁/** ▁* ▁@ param ▁pPdfPath ▁Il ▁path ▁da ▁settare ▁per ▁i ▁pdf . ▁*/ ▁p ublic ▁static ▁void ▁set PdfPath ( String ▁pPdfPath ) ▁{ ▁Utility . pdfPath ▁= ▁pPdfPath ; ▁} ▁/** ▁* ▁@ return ▁Il ▁p ercorso ▁impostat o ▁per ▁i ▁file ▁utilizzat i ▁* ▁dura nte ▁l ' import azione ▁dei ▁dati . ▁*/ ▁@ Supp ress Warning s (" static - access ") ▁p ublic ▁static ▁String ▁get UploadPath () ▁{ ▁return ▁Utility . uploadPath ; ▁} ▁/** ▁* ▁@ param ▁pUploadPath ▁Il ▁path ▁da ▁settare ▁per ▁i ▁file ▁utilizzat i ▁* ▁dura nte ▁l ' import azione ▁dei ▁dati . ▁*/ ▁p ublic ▁static ▁void ▁set UploadPath ( String ▁pUploadPath ) ▁{ ▁Utility . uploadPath ▁= ▁pUploadPath ; ▁} ▁/** ▁* ▁@ return ▁Il ▁server ▁ smtp ▁da ▁utilizza re ▁per ▁l ' invio ▁* ▁automati zza to ▁delle ▁e - mail . ▁*/ ▁@ Supp ress Warning s (" static - access ") ▁p ublic ▁static ▁String ▁get ServerSmtp () ▁{ ▁return ▁Utility . serverSmtp ; ▁} ▁/** ▁* ▁@ param ▁pServerSmtp ▁il ▁server ▁ smtp ▁da ▁settare . ▁*/ ▁p ublic ▁static ▁void ▁set ServerSmtp ( String ▁pServerSmtp ) ▁{ ▁Utility . serverSmtp ▁= ▁pServerSmtp ; ▁} ▁/** ▁* ▁@ return ▁the ▁activeTimeout ▁*/ ▁p ublic ▁static ▁int ▁get ActiveTimeout () ▁{ ▁return ▁Utility . activeTimeout ; ▁} ▁/** ▁* ▁@ param ▁activeTimeout ▁the ▁activeTimeout ▁to ▁set ▁*/ ▁p ublic ▁static ▁void ▁set ActiveTimeout ( int ▁pActiveTimeout ) ▁{ ▁Utility . activeTimeout ▁= ▁pActiveTimeout ; ▁} ▁/** ▁* ▁@ return ▁the ▁driverMySql ▁*/ ▁p ublic ▁static ▁String ▁get DriverMySql () ▁{ ▁return ▁Utility . driverMySql ; ▁} ▁/** ▁* ▁@ param ▁driverMySql ▁the ▁driverMySql ▁to ▁set ▁*/ ▁p ublic ▁static ▁void ▁set DriverMySql ( String ▁pDriverMySql ) ▁{ ▁Utility . driverMySql ▁= ▁pDriverMySql ; ▁} ▁/** ▁* ▁@ return ▁the ▁ fullPathDatabase ▁*/ ▁p ublic ▁static ▁String ▁get FullPathDatabase () ▁{ ▁return ▁Utility . fullPathDatabase ; ▁} ▁/** ▁* ▁@ param ▁ fullPathDatabase ▁the ▁ fullPathDatabase ▁to ▁set ▁*/ ▁p ublic ▁static ▁void ▁set FullPathDatabase ( String ▁p FullPathDatabase ) ▁{ ▁Utility . fullPathDatabase ▁= ▁p FullPathDatabase ; ▁} ▁/** ▁* ▁@ return ▁the ▁maxPoolSize ▁*/ ▁p ublic ▁static ▁int ▁get MaxPoolSize () ▁{ ▁return ▁Utility . maxPoolSize ; ▁} ▁/** ▁* ▁@ param ▁maxPoolSize ▁the ▁maxPoolSize ▁to ▁set ▁*/ ▁p ublic ▁static ▁void ▁set MaxPoolSize ( int ▁pMaxPoolSize ) ▁{ ▁Utility . maxPoolSize ▁= ▁pMaxPoolSize ; ▁} ▁/** ▁* ▁@ return ▁the ▁password ▁*/ ▁p ublic ▁static ▁String ▁getPassword () ▁{ ▁return ▁Utility . password ; ▁} ▁/** ▁* ▁@ param ▁password ▁the ▁password ▁to ▁set ▁*/ ▁p ublic ▁static ▁void ▁setPassword ( String ▁pPassword ) ▁{ ▁Utility . password ▁= ▁pPassword ; ▁} ▁/** ▁* ▁@ return ▁the ▁poolTimeout ▁*/ ▁p ublic ▁static ▁int ▁get PoolTimeout () ▁{ ▁return ▁Utility . poolTimeout ; ▁} ▁/** ▁* ▁@ param ▁poolTimeout ▁the ▁poolTimeout ▁to ▁set ▁*/ ▁p ublic ▁static ▁void ▁set PoolTimeout ( int ▁pPoolTimeout ) ▁{ ▁Utility . poolTimeout ▁= ▁pPoolTimeout ; ▁} ▁/** ▁* ▁@ return ▁the ▁userName ▁*/ ▁p ublic ▁static ▁String ▁get UserName () ▁{ ▁return ▁Utility . userName ; ▁} ▁/** ▁* ▁@ param ▁userName ▁the ▁userName ▁to ▁set ▁*/ ▁p ublic ▁static ▁void ▁set UserName ( String ▁pUserName ) ▁{ ▁Utility . userName ▁= ▁pUserName ; ▁} ▁/** ▁* ▁@ return ▁the ▁waitTimeout ▁*/ ▁p ublic ▁static ▁int ▁get WaitTimeout () ▁{ ▁return ▁Utility . waitTimeout ; ▁} ▁/** ▁* ▁@ param ▁waitTimeout ▁the ▁waitTimeout ▁to ▁set ▁*/ ▁p ublic ▁static ▁void ▁set WaitTimeout ( int ▁pWaitTimeout ) ▁{ ▁Utility . waitTimeout ▁= ▁pWaitTimeout ; ▁} ▁/** ▁* ▁@ return ▁the ▁imageHeaderPath ▁*/ ▁p ublic ▁static ▁String ▁get ImageHeaderPath () ▁{ ▁return ▁Utility . imageHeaderPath ; ▁} ▁/** ▁* ▁@ param ▁imageHeaderPath ▁the ▁imageHeaderPath ▁to ▁set ▁*/ ▁p ublic ▁static ▁void ▁set ImageHeaderPath ( String ▁ pImageHeaderPath ) ▁{ ▁Utility . imageHeaderPath ▁= ▁ pImageHeaderPath ; ▁} ▁/** ▁* ▁@ return ▁the ▁textFooter ▁*/ ▁p ublic ▁static ▁String ▁get TextFooter () ▁{ ▁return ▁Utility . textFooter ; ▁} ▁/** ▁* ▁@ param ▁textFooter ▁the ▁textFooter ▁to ▁set ▁*/ ▁p ublic ▁static ▁void ▁set TextFooter ( String ▁pTextFooter ) ▁{ ▁Utility . textFooter ▁= ▁pTextFooter ; ▁} ▁/** ▁* ▁@ return ▁the ▁imageLeftColumn ▁*/ ▁p ublic ▁static ▁String ▁get ImageLeftColumn () ▁{ ▁return ▁Utility . imageLeftColumn ; ▁} ▁/** ▁* ▁@ param ▁imageLeftColumn ▁the ▁imageLeftColumn ▁to ▁set ▁*/ ▁p ublic ▁static ▁void ▁set ImageLeftColumn ( String ▁ pImageLeftColumn ) ▁{ ▁Utility . imageLeftColumn ▁= ▁ pImageLeftColumn ; ▁} ▁p ublic ▁static ▁String ▁ getImage L ogo HeaderPath () ▁{ ▁return ▁Utility . image HeaderLogoPath ; ▁} ▁p ublic ▁static ▁void ▁set Image L ogo HeaderPath ( String ▁pImage HeaderLogoPath ) ▁{ ▁Utility . image HeaderLogoPath ▁= ▁pImage HeaderLogoPath ; ▁} ▁/** ▁* ▁@ return ▁the ▁n eedDayBeforeExam ▁*/ ▁p ublic ▁static ▁int ▁get N eedDayBeforeExam () ▁{ ▁return ▁Utility . n eedDayBeforeExam ; ▁} ▁/** ▁* ▁@ param ▁n eedDayBeforeExam ▁the ▁n eedDayBeforeExam ▁to ▁set ▁*/ ▁p ublic ▁static ▁void ▁set N eedDayBeforeExam ( int ▁p N eedDayBeforeExam ) ▁{ ▁Utility . n eedDayBeforeExam ▁= ▁p N eedDayBeforeExam ; ▁} ▁/** ▁* ▁@ return ▁the ▁ maxDayBeforeExam ▁*/ ▁p ublic ▁static ▁int ▁get MaxDayBeforeExam () ▁{ ▁return ▁Utility . maxDayBeforeExam ; ▁} ▁/** ▁* ▁@ param ▁ maxDayBeforeExam ▁the ▁ maxDayBeforeExam ▁to ▁set ▁*/ ▁p ublic ▁static ▁void ▁set MaxDayBeforeExam ( int ▁p MaxDayBeforeExam ) ▁{ ▁Utility . maxDayBeforeExam ▁= ▁p MaxDayBeforeExam ; ▁} ▁p ublic ▁static ▁String ▁get A ct ual Date () ▁{ ▁Gr egorianCalendar ▁ gc ▁= ▁new ▁Gr egorianCalendar (); ▁String ▁date =" "; ▁int ▁year = gc . get ( Gr egorianCalendar . Y EAR ); ▁int ▁month = gc . get ( Gr egorianCalendar . MO N TH ) +1; ▁String ▁months =" "; ▁if ( month <10) { ▁months ="0"+ month ; ▁} else { ▁months = ▁months + month ; ▁} ▁int ▁day = gc . get ( Gr egorianCalendar . DAY _ O F _ MO N TH ); ▁String ▁days =" "; ▁if ( day <10) { ▁days ="0"+ day ; ▁} else { ▁days = ▁days + day ; ▁} ▁date = ▁date ▁+ ▁days +"/"+ months +"/"+ year ; ▁return ▁date ; ▁} ▁}