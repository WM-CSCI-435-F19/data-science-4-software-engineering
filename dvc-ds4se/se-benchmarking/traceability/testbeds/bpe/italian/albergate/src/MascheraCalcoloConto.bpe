▁p ackage ▁interfacce ; ▁import ▁java . awt .* ; ▁import ▁java . awt . event .* ; ▁import ▁java . util . Date ; ▁import ▁common . utility .* ; ▁import ▁common . def .* ; ▁import ▁modul i .* ; ▁p ublic ▁class ▁Maschera CalcoloConto ▁ext ends ▁Frame ▁{ ▁Button ▁Annulla , ▁Visualizza ; ▁TextField ▁testo []; ▁Label ▁etichetta 1, ▁etichetta 2, ▁etichetta 3, ▁etichetta 4, ▁etichetta 5, ▁stanza , ▁stanza 1, ▁nome , ▁cognome , ▁stanza 2; ▁Panel ▁panel []; ▁CheckboxGroup ▁checkbox _ group ; ▁Checkbox [] ▁checkboxes ; ▁GridBagLayout ▁gridbag ▁= new ▁GridBagLayout (); ▁// ▁per ▁la ▁gerarchia ▁Frame ▁padre ; ▁Maschera Visualizzazione Conto ▁visual ; ▁// ▁variabili ▁locali ▁Soggiornante ▁sogg _ x _ conto _ sing ; ▁String ▁L _ st []; ▁Date ▁date _ fine []; ▁// ▁questo ▁array ▁e ' ▁necessari o ▁per ▁la ▁chiusura ▁della ▁comitiva ▁// ▁inf atti ▁per ▁poter ▁ripristin are ▁le ▁disponibilita ▁della ▁// ▁stanza ▁corretta mente ▁h o ▁bisogn o ▁delle ▁date ▁di ▁fine ▁corrette ▁Date ▁date _ inizio []; ▁Date ▁data _ fine _ magg ; ▁Date ▁fine _ sogg _ anticipato ; ▁int ▁tipo _ conto ; ▁boolean ▁qualcun o _ tramite _ agenzia ; ▁boolean ▁qualcun o _ senza _ agenzia ; ▁p ublic ▁Maschera CalcoloConto ( Frame ▁parent ) ▁{ ▁super (" Calcolo ▁del ▁Conto "); ▁padre ▁= ▁parent ; ▁padre . setEnabled ( false ); ▁setupPanel s (); ▁init (); ▁pack (); ▁} ▁void ▁setupPanel s () ▁{ ▁this . setFont ( Configurazione Sistema . font _ base ); ▁// Cre o ▁i ▁pulsanti ▁Annulla ▁= ▁new ▁Button (" ▁Annulla ▁"); ▁// Annulla . setFont ( new ▁Font (" Cour ier ", ▁Font . PL A IN , ▁12) ); ▁Visualizza ▁= ▁new ▁Button (" ▁ Calcola ▁"); ▁// Visualizza . setFont ( new ▁Font (" Cour ier ", ▁Font . PL A IN , ▁12) ); ▁Visualizza . setEnabled ( false ); ▁// Cre o ▁le ▁etichette ▁etichetta 1 ▁= ▁new ▁Label (" Selezionare ▁il ▁tipo ▁di ▁conto ▁che ▁si ▁desidera ▁calcola re : "); ▁etichetta 1. setFont ( Configurazione Sistema . font _ titolo ); ▁etichetta 2 ▁= ▁new ▁Label (" Conto ▁su ▁una ▁stanza : "); ▁etichetta 2. setFont ( Configurazione Sistema . font _ titolo ); ▁etichetta 3 ▁= ▁new ▁Label (" Conto ▁su ▁un ▁cliente : "); ▁etichetta 3. setFont ( Configurazione Sistema . font _ titolo ); ▁etichetta 4 ▁= ▁new ▁Label (" Conto ▁su ▁piu ' ▁stanze : "); ▁etichetta 4. setFont ( Configurazione Sistema . font _ titolo ); ▁stanza ▁= ▁new ▁Label (" Stanza ▁numero "); ▁cognome ▁= ▁new ▁Label (" Cognome "); ▁nome ▁= ▁new ▁Label (" Nome "); ▁stanza 1 ▁= ▁new ▁Label (" Stanza "); ▁stanza 2 ▁= ▁new ▁Label (" Stanze ▁ Numero "); ▁// Cre o ▁i ▁TextField ▁e ▁li ▁ rendo ▁non ▁edit abili ▁testo = new ▁TextField [6] ; ▁testo [0] ▁= ▁new ▁TextField ("", ▁4 ); ▁testo [1] ▁= ▁new ▁TextField ("", ▁20 ); ▁testo [2] ▁= ▁new ▁TextField ("", ▁20 ); ▁testo [3] ▁= ▁new ▁TextField ("", ▁4 ); ▁testo [4] ▁= ▁new ▁TextField ("", ▁30 ); ▁testo [5] ▁= ▁new ▁TextField ("", 10 ); ▁for ( int ▁i =0; i < 6; ++ i ) ▁testo [ i ]. setEditable ( false ); ▁// Cre o ▁un ▁Checkbox ▁ad ▁esclus ione ▁checkbox _ group ▁= ▁new ▁CheckboxGroup (); ▁checkboxes ▁= ▁new ▁Checkbox [4] ; ▁checkboxes [0] ▁= ▁new ▁Checkbox (" ▁Conto ▁su ▁una ▁stanza ", checkbox _ group , ▁false ); ▁checkboxes [1] ▁= ▁new ▁Checkbox (" ▁Conto ▁su ▁un ▁cliente ", checkbox _ group , ▁false ); ▁checkboxes [2] ▁= ▁new ▁Checkbox (" ▁Conto ▁su ▁piu ' stanze ", checkbox _ group , ▁false ); ▁checkboxes [3] ▁= ▁new ▁Checkbox (" ▁Partenza ▁anticipata ", ▁false ); ▁panel = new ▁Panel [5]; ▁for ( int ▁i =0; i <5; ++ i ) ▁{ ▁panel [ i ]= new ▁Panel (); ▁panel [ i ]. setLayout ( gridbag ); ▁} ▁// Cre o ▁il ▁pannello ▁in ▁alto ▁a ▁s inistra ▁ Utils . constrain ( panel [1] , ▁etichetta 1, ▁0, ▁0, ▁3, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁1.0, ▁ 0.0, ▁0, ▁0, ▁ 10, ▁0) ; ▁ Utils . constrain ( panel [1] , ▁checkboxes [0], ▁0, ▁1, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁1.0, ▁ 0.0, ▁0, ▁ 5, ▁0, ▁0) ; ▁ Utils . constrain ( panel [1] , ▁checkboxes [1] , ▁0, ▁2, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁1.0, ▁ 0.0, ▁0, ▁ 5, ▁0, ▁0) ; ▁ Utils . constrain ( panel [1] , ▁checkboxes [2] , ▁0, ▁3, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁1.0, ▁ 0.0, ▁0, ▁ 5, ▁0, ▁0) ; ▁ Utils . constrain ( panel [1] , ▁checkboxes [3] , ▁0, ▁ 4, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁1.0, ▁ 0.0, ▁0, ▁ 5, ▁0, ▁0) ; ▁ Utils . constrain ( panel [1] , ▁testo [5] , ▁1, ▁ 4, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁1.0, ▁ 0.0, ▁0, ▁ 5, ▁0, ▁0) ; ▁// Cre o ▁il ▁pannello ▁in ▁alto ▁a ▁d estra ▁ Utils . constrain ( panel [0], ▁Annulla , ▁0, ▁1, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁0.3 , ▁ 0.0, ▁20 , ▁0, ▁ 5, ▁20 ); ▁ Utils . constrain ( panel [0], ▁Visualizza , ▁0, ▁2, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁0.3 , ▁ 0.0, ▁ 5, ▁0, ▁0, ▁20 ); ▁// Cre o ▁il ▁pannello ▁conto ▁su ▁una ▁stanza ▁ Utils . constrain ( panel [2] , ▁etichetta 2, ▁0, ▁0, ▁2, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁1.0, ▁ 0.0, ▁0, ▁0, ▁ 10, ▁0) ; ▁ Utils . constrain ( panel [2] , ▁stanza , ▁0, ▁1, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁ 0.0, ▁ 0.0, ▁0, ▁ 5, ▁0, ▁20 ); ▁ Utils . constrain ( panel [2] , ▁testo [0], ▁1, ▁1, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁1.0, ▁ 0.0, ▁0, ▁0, ▁0, ▁0) ; ▁// Cre o ▁il ▁pannello ▁conto ▁su ▁un ▁cliente ▁ Utils . constrain ( panel [3] , ▁etichetta 3, ▁0, ▁0, ▁2, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁1.0, ▁ 0.0, ▁0, ▁0, ▁ 10, ▁0) ; ▁ Utils . constrain ( panel [3] , ▁cognome , ▁0, ▁1, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁ 0.0, ▁ 0.0, ▁0, ▁ 5, ▁0, ▁20 ); ▁ Utils . constrain ( panel [3] , ▁testo [1] , ▁1, ▁1, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁1.0, ▁ 0.0, ▁0, ▁0, ▁0, ▁0) ; ▁ Utils . constrain ( panel [3] , ▁nome , ▁0, ▁2, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . SOUTH WEST , ▁ 0.0, ▁ 0.0, ▁20 , ▁ 5, ▁0, ▁20 ); ▁ Utils . constrain ( panel [3] , ▁testo [2] , ▁1, ▁2, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . SOUTH WEST , ▁1.0, ▁ 0.0, ▁20 , ▁0, ▁0, ▁0) ; ▁ Utils . constrain ( panel [3] , ▁stanza 1, ▁ 4, ▁2, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁ 0.0, ▁ 0.0, ▁0, ▁ 5, ▁0, ▁20 ); ▁ Utils . constrain ( panel [3] , ▁testo [3] , ▁ 5, ▁2, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁1.0, ▁ 0.0, ▁0, ▁0, ▁0, ▁0) ; ▁// Cre o ▁il ▁pannello ▁conto ▁su ▁piu ' ▁stanze ▁ Utils . constrain ( panel [4] , ▁etichetta 4, ▁0, ▁0, ▁2, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁1.0, ▁ 0.0, ▁0, ▁0, ▁ 10, ▁0) ; ▁ Utils . constrain ( panel [4] , ▁stanza 2, ▁0, ▁1, ▁1, ▁1, ▁Grid BagConstraints . NONE , ▁Grid BagConstraints . NORTH WEST , ▁ 0.0, ▁ 0.0, ▁0, ▁ 5, ▁0, ▁20 ); ▁ Utils . constrain ( panel [4] , ▁testo [4] , ▁1, ▁1, ▁1, ▁1, ▁Grid BagConstraints . HORIZONTAL , ▁Grid BagConstraints . NORTH WEST , ▁1.0, ▁ 0.0, ▁0, ▁0, ▁0, ▁ 5); ▁// Attac co ▁i ▁pannelli ▁al ▁frame ▁this . setLayout ( gridbag ); ▁ Utils . constrain ( this , ▁panel [1] , ▁0, ▁0, ▁ 6, ▁ 4, ▁Grid BagConstraints . HORIZONTAL , ▁Grid BagConstraints . NORTH WEST , ▁1.0, ▁ 0.0, ▁ 5, ▁ 5, ▁ 5, ▁ 5); ▁ Utils . constrain ( this , ▁panel [0], ▁ 6, ▁0, ▁1, ▁ 4, ▁Grid BagConstraints . BOTH , ▁Grid BagConstraints . SOUTH EAST , ▁1.0, ▁ 0.0, ▁ 5, ▁ 5, ▁ 5, ▁ 5); ▁ Utils . constrain ( this , ▁panel [2] , ▁0, ▁ 4, ▁ 7, ▁2, ▁Grid BagConstraints . HORIZONTAL , ▁Grid BagConstraints . WEST , ▁1.0, ▁1.0, ▁ 5, ▁ 5, ▁ 5, ▁ 5); ▁ Utils . constrain ( this , ▁panel [3] , ▁0, ▁ 6, ▁ 7, ▁3, Grid BagConstraints . HORIZONTAL , ▁Grid BagConstraints . WEST , ▁1.0, ▁1.0, ▁ 5, ▁ 5, ▁ 5, ▁ 5); ▁ Utils . constrain ( this , panel [4] , ▁0, ▁ 9, ▁ 7, ▁2, Grid BagConstraints . HORIZONTAL , ▁Grid BagConstraints . WEST , ▁1.0, ▁1.0, ▁ 5, ▁ 5, ▁ 5, ▁ 5); ▁} ▁p ublic ▁void ▁init () ▁{ ▁checkboxes [0]. add ItemListener ( new ▁ ItemListener () ▁{ ▁p ublic ▁void ▁item S tateChanged ( ItemEvent ▁e ) ▁{ ▁if ( checkboxes [0]. getStat e ()) ▁{ ▁tipo _ conto ▁= ▁1; ▁testo [0]. setEditable ( true ); ▁Visualizza . setEnabled ( true ); ▁for ( int ▁i =1; i <5; ++ i ) ▁{ ▁testo [ i ]. setEditable ( false ); ▁testo [ i ]. setText (" "); ▁} ▁} ▁} ▁} ); ▁checkboxes [1]. add ItemListener ( new ▁ ItemListener () ▁{ ▁p ublic ▁void ▁item S tateChanged ( ItemEvent ▁e ) ▁{ ▁if ( checkboxes [1]. getStat e ()) ▁{ ▁tipo _ conto ▁= ▁2 ; ▁Visualizza . setEnabled ( true ); ▁for ( int ▁i =1; i <4 ; ++ i ) ▁testo [ i ]. setEditable ( true ); ▁testo [0]. setEditable ( false ); ▁testo [0]. setText (" "); ▁testo [4]. setEditable ( false ); ▁testo [4]. setText (" "); ▁} ▁} ▁} ); ▁checkboxes [2]. add ItemListener ( new ▁ ItemListener () ▁{ ▁p ublic ▁void ▁item S tateChanged ( ItemEvent ▁e ) ▁{ ▁if ( checkboxes [2]. getStat e ()) ▁{ ▁tipo _ conto ▁= ▁3; ▁Visualizza . setEnabled ( true ); ▁testo [4]. setEditable ( true ); ▁for ( int ▁i =0; i <4 ; ++ i ) ▁{ ▁testo [ i ]. setEditable ( false ); ▁testo [ i ]. setText (" "); ▁} ▁} ▁} ▁} ); ▁checkboxes [3]. add ItemListener ( new ▁ ItemListener () ▁{ ▁p ublic ▁void ▁item S tateChanged ( ItemEvent ▁e ) ▁{ ▁if ▁(! checkboxes [3]. getStat e ()) ▁{ ▁testo [5]. setEditable ( false ); ▁testo [5]. setText (" "); ▁} ▁else ▁{ ▁testo [5]. setEditable ( true ); ▁testo [5]. setText ( DateUtils . parse Date ( DateUtils . give String Of Date ( new ▁Date ())) ); ▁} ▁} ▁} ); ▁Annulla . a ddActionListener ( new ▁ActionListener () ▁{ ▁p ublic ▁void ▁actionPerformed ( ActionEvent ▁e ) ▁{ ▁dispose (); ▁padre . setEnabled ( true ); ▁} ▁} ); ▁Visualizza . a ddActionListener ( new ▁ActionListener () ▁{ ▁p ublic ▁void ▁actionPerformed ( ActionEvent ▁e ) ▁{ ▁start Visualizza (); ▁} ▁} ); ▁} ▁void ▁start Visualizza () ▁{ ▁if ▁(! errori ()) ▁{ ▁this . setEnabled ( false ); ▁if ▁( checkboxes [0]. getStat e ()) ▁startConto Stanza (); ▁else ▁{ ▁if ▁( checkboxes [1]. getStat e ()) ▁{ ▁startConto Singolo (); ▁} ▁else ▁startConto C omitiva (); ▁} ▁display Conto (); ▁} ▁} ▁void ▁display Conto () ▁{ ▁visual ▁= ▁new ▁Maschera Visualizzazione Conto ( testo [0]. getText (), testo [1]. getText (), ▁testo [2]. getText (), testo [3]. getText (), testo [4]. getText (), tipo _ conto ); ▁visual . setVisible ( true ); ▁visual . conto ▁= ▁this ; ▁} ▁boolean ▁p roblemi Stanza ( String ▁stanza ) ▁{ ▁Frame ▁msg ; ▁L istaSoggiornanti ▁L _ sogg ; ▁if ▁( ( stanza ) . equals ("") ▁) ▁{ ▁msg ▁= ▁new ▁Avviso Dialog ( this , ▁" ▁Inseri re ▁il ▁numero ▁di ▁stanza ▁"); ▁return ▁true ; ▁} ▁else ▁if ▁( ( Principale . db ) . read Stanza ( stanza ) ▁== ▁null ▁) ▁{ ▁msg ▁= ▁new ▁MessageDialog ( this , ▁" ▁La ▁stanza ▁"+ stanza +" ▁e ' ▁inesistente ! ▁"); ▁return ▁true ; ▁} ▁else ▁{ ▁L _ sogg ▁= ▁( Principale . db ) . foundSoggiornant i ( stanza , ▁false ); ▁if ▁( L _ sogg ▁== ▁null ) ▁{ ▁msg ▁= ▁new ▁MessageDialog ( this , ▁" ▁P roblemi ▁con ▁il ▁database ! ▁"); ▁return ▁true ; ▁} ▁else ▁if ▁( L _ sogg . length () ▁== ▁0) ▁{ ▁msg ▁= ▁new ▁MessageDialog ( this , ▁" ▁La ▁stanza ▁"+ stanza +" ▁non ▁e ' ▁attual mente ▁occupata ▁"); ▁return ▁true ; ▁} ▁} ▁return ▁false ; ▁} ▁// ▁controlla ▁che ▁nella ▁lista ▁non ▁vi ▁sia no ▁stanze ▁ripet ute ▁piu ' ▁volte ▁int ▁ch k Double () ▁{ ▁for ( int ▁i ▁= ▁0; ▁i < L _ st . length ; ▁i ++) ▁for ( int ▁j ▁= ▁0; ▁j < L _ st . length ; ▁j ++) ▁if ▁( ▁(! L _ st [ i ]. equals ("")) ▁&& ▁(! L _ st [ j ]. equals ("")) ▁&& ▁( i != j ) ▁&& ▁( L _ st [ i ]. equals ( L _ st [ j ])) ▁) ▁return ▁j ; ▁return ▁ -1; ▁} ▁Date [] ▁tornaDate Fine Magg ( String ▁elenco []) ▁{ ▁Date ▁data _ fine _ stanza ▁= ▁null ; ▁Date ▁fine _ sogg ▁= ▁null ; ▁Date ▁date _ fine _ loc [] ▁= ▁new ▁Date [ elenco . length ]; ▁for ▁( int ▁i ▁= ▁0; ▁i ▁< ▁elenco . length ; ▁i ++) ▁{ ▁L istaSoggiornanti ▁L _ sogg ▁= ▁( Principale . db ) . foundSoggiornant i ( elenco [ i ], ▁false ); ▁if ▁( L _ sogg ▁ != ▁null ) ▁{ ▁data _ fine _ stanza ▁= ▁new ▁Date ( 0, ▁0, ▁1 ); ▁for ▁( int ▁j ▁= ▁1; ▁j ▁<= ▁L _ sogg . length (); ▁j ++) ▁{ ▁fine _ sogg ▁= ▁L _ sogg . get Soggiornante ( j ) . getFine Sogg (); ▁if ▁( ▁ Utils . data 1 M aggiore Data 2( ▁fine _ sogg , ▁data _ fine _ stanza ▁) ▁) ▁data _ fine _ stanza ▁= ▁new ▁Date ( fine _ sogg . getYear (), ▁fine _ sogg . getMonth (), ▁fine _ sogg . getDate ()); ▁} ▁date _ fine _ loc [ i ] ▁= ▁data _ fine _ stanza ; ▁} ▁else ▁return ▁null ; ▁} ▁return ▁date _ fine _ loc ; ▁} ▁Date [] ▁tornaDate Inizio Min ( String ▁elenco []) ▁{ ▁Date ▁data _ inizio _ stanza ▁= ▁null ; ▁Date ▁inizio _ sogg ▁= ▁null ; ▁Date ▁date _ inizio _ loc [] ▁= ▁new ▁Date [ elenco . length ]; ▁for ▁( int ▁i ▁= ▁0; ▁i ▁< ▁elenco . length ; ▁i ++) ▁{ ▁L istaSoggiornanti ▁L _ sogg ▁= ▁( Principale . db ) . foundSoggiornant i ( elenco [ i ], ▁false ); ▁if ▁( L _ sogg ▁ != ▁null ) ▁{ ▁data _ inizio _ stanza ▁= ▁new ▁Date ( 30 00 , ▁0, ▁1 ); ▁for ▁( int ▁j ▁= ▁1; ▁j ▁<= ▁L _ sogg . length (); ▁j ++) ▁{ ▁inizio _ sogg ▁= ▁L _ sogg . get Soggiornante ( j ) . getInizio Sogg (); ▁if ▁( ▁ Utils . data 1 Min oreDat a 2( ▁inizio _ sogg , ▁data _ inizio _ stanza ▁) ▁) ▁data _ inizio _ stanza ▁= ▁new ▁Date ( inizio _ sogg . getYear (), ▁inizio _ sogg . getMonth (), ▁inizio _ sogg . getDate ()); ▁} ▁date _ inizio _ loc [ i ] ▁= ▁data _ inizio _ stanza ; ▁} ▁else ▁return ▁null ; ▁} ▁return ▁date _ inizio _ loc ; ▁} ▁boolean ▁aggiornamento Flag s E ffettuato ( String ▁elenco []) ▁{ ▁qualcun o _ tramite _ agenzia ▁= ▁false ; ▁qualcun o _ senza _ agenzia ▁= ▁false ; ▁Prenotazione ▁pren ; ▁for ▁( int ▁i ▁= ▁0; ▁i < elenco . length ; ▁i ++) ▁{ ▁L istaSoggiornanti ▁L _ sogg ▁= ▁( Principale . db ) . foundSoggiornant i ( elenco [ i ], ▁false ); ▁if ▁( L _ sogg ▁ != ▁null ) ▁{ ▁for ▁( int ▁j ▁= ▁1; ▁j ▁<= ▁L _ sogg . length (); ▁j ++) ▁{ ▁pren ▁= ▁( Principale . db ) . read Prenotazione ( ( L _ sogg . get Soggiornante ( j )). getId Prenotazione ()); ▁if ▁( pren ▁== ▁null ) ▁return ▁false ; ▁else ▁{ ▁if ▁( pren . getT ramite Agenzia () ▁== ▁Const . SI ) ▁qualcun o _ tramite _ agenzia ▁= ▁qualcun o _ tramite _ agenzia ▁|| ▁true ; ▁else ▁qualcun o _ senza _ agenzia ▁= ▁qualcun o _ tramite _ agenzia ▁|| ▁true ; ▁} ▁} ▁} ▁else ▁return ▁false ; ▁} ▁return ▁true ; ▁} ▁boolean ▁errori () ▁{ ▁Frame ▁msg ; ▁Soggiornante ▁sogg ▁= ▁new ▁Soggiornante (); ▁if ▁( checkboxes [0]. getStat e ()) ▁{ ▁if ▁( p roblemi Stanza ( testo [0]. getText ())) ▁return ▁true ; ▁L _ st ▁= ▁new ▁String [1] ; ▁L _ st [0] ▁= ▁new ▁String ( testo [0]. getText ()); ▁} ▁else ▁if ▁( checkboxes [1]. getStat e ()) ▁{ ▁L _ st ▁= ▁new ▁String [1] ; ▁L _ st [0] ▁= ▁new ▁String ( testo [3]. getText ()); ▁sogg ▁= ▁( Principale . db ) . foundSoggiornant e ( testo [3]. getText (), testo [2]. getText (), testo [1]. getText ()); ▁if ▁( sogg ▁== ▁null ) ▁{ ▁msg ▁= ▁new ▁Avviso Dialog ( this , ▁" ▁Nessun ▁soggiornante ▁presente ▁nella ▁stanza ▁"+ testo [3]. getText ()+ ▁" ▁ri spond e ▁al ▁nomi n ativo ▁inserito ! ▁"); ▁return ▁true ; ▁} ▁L istaSoggiornanti ▁L _ sogg ▁= ▁( Principale . db ) . foundSoggiornant i ( testo [3]. getText (), ▁false ); ▁if ▁( L _ sogg ▁== ▁null ) ▁{ ▁msg ▁= ▁new ▁MessageDialog ( this , ▁" ▁P roblemi ▁con ▁il ▁database ! ▁"); ▁return ▁true ; ▁} ▁if ▁( sogg . getP agato () ▁== ▁Const . SI ) ▁{ ▁msg ▁= ▁new ▁Avviso Dialog ( this , ▁" ▁Il ▁soggiornante ▁selezionato ▁o ▁ha ▁gia ' ▁ pagato ▁o ▁se ▁ne ▁e ' ▁gia ' ▁and ato ! ▁"); ▁return ▁true ; ▁} ▁else ▁{ ▁// ▁proced o ▁con ▁il ▁verificar e ▁se ▁il ▁cliente ▁e ' ▁l ' ultimo ▁rimasto ▁L istaSoggiornanti ▁sogg _ no _ pagato ▁= ▁new ▁L istaSoggiornanti (); ▁for ▁( int ▁i =1; ▁i <= L _ sogg . length (); ▁i ++) ▁if ▁( L _ sogg . get Soggiornante ( i ) . getP agato () ▁== ▁Const . NO ) ▁sogg _ no _ pagato . add Soggiornante ( L _ sogg . get Soggiornante ( i )); ▁if ▁( sogg _ no _ pagato . length () ▁== ▁1) ▁{ ▁msg ▁= ▁new ▁Avviso Dialog ( this , ▁" ▁Il ▁soggiornante ▁e ' ▁l ' ultimo ▁rimasto . ▁Sceglie re ▁' conto ▁per ▁stanza '! ▁"); ▁return ▁true ; ▁} ▁sogg _ x _ conto _ sing ▁= ▁sogg ; ▁} ▁} ▁else ▁if ▁( checkboxes [2]. getStat e ()) ▁{ ▁L _ st ▁= ▁ Utils . parse Stanze ( testo [4]. getText ()); ▁if ▁( L _ st ▁== ▁null ) ▁{ ▁msg ▁= ▁new ▁MessageDialog ( this , ▁" ▁Errore ▁nell ' elenco ▁delle ▁stanze . ▁Inseri re ▁le ▁stanze ▁nell ' elenco ▁nel ▁mod o ▁seguente : ▁10 1, 10 2, 103, . . . "); ▁return ▁true ; ▁} ▁else ▁{ ▁Stanza ▁room ; ▁for ▁( int ▁i ▁= ▁0; ▁i ▁< ▁L _ st . length ; ▁i ++) ▁if ▁( p roblemi Stanza ( L _ st [ i ])) ▁return ▁true ; ▁int ▁res ▁= ▁ch k Double (); ▁if ▁( ▁res ▁ != ▁-1) ▁{ ▁msg ▁= ▁new ▁MessageDialog ( this , ▁" ▁Errore ▁nell ' elenco ▁delle ▁stanze . ▁La ▁stanza ▁"+ L _ st [ re s ]+" ▁e ▁presente ▁piu ' ▁volte ▁nell ' elenco ! ▁"); ▁return ▁true ; ▁} ▁} ▁} ▁if ▁( checkboxes [0]. getStat e () ▁|| ▁checkboxes [2]. getStat e ()) ▁{ ▁date _ fine ▁= ▁tornaDate Fine Magg ( L _ st ); ▁date _ inizio ▁= ▁tornaDate Inizio Min ( L _ st ); ▁} ▁else ▁{ ▁Prenotazione ▁pren ▁= ▁( Principale . db ) . read Prenotazione ( sogg . getId Prenotazione ()); ▁if ▁( pren ▁ != ▁null ) ▁{ ▁date _ fine ▁= ▁new ▁Date [1] ; ▁date _ inizio ▁= ▁new ▁Date [1] ; ▁date _ fine [0] ▁= ▁sogg . getFine Sogg (); ▁date _ inizio [0] ▁= ▁sogg . getInizio Sogg (); ▁} ▁else ▁date _ fine ▁= ▁null ; ▁} ▁if ▁( date _ fine ▁== ▁null ▁|| ▁date _ inizio ▁== ▁null ) ▁{ ▁msg ▁= ▁new ▁MessageDialog ( this , ▁" ▁P roblemi ▁con ▁il ▁database ! ▁"); ▁return ▁true ; ▁} ▁// ▁la ▁variabil e ▁data _ fine ▁contiene ▁le ▁date ▁di ▁fine ▁corrette ▁data _ fine _ magg ▁= ▁new ▁Date ( 0, ▁0, ▁1 ); ▁for ▁( int ▁i =0; ▁i < date _ fine . length ; ▁i ++) ▁if ▁( Utils . data 1 M aggiore Data 2( date _ fine [ i ], ▁data _ fine _ magg )) ▁data _ fine _ magg ▁= ▁date _ fine [ i ]; ▁// ▁ora ▁la ▁variabil e ▁data _ fine _ magg ▁contiene ▁la ▁data ▁di ▁fine ▁maggiore ▁if ▁(! aggiornamento Flag s E ffettuato ( L _ st )) ▁{ ▁msg ▁= ▁new ▁MessageDialog ( this , ▁" ▁P roblemi ▁con ▁il ▁database ! ▁"); ▁return ▁true ; ▁} ▁// ▁da ▁ora ▁in ▁poi ▁le ▁flag s ▁per ▁l ' agenzia ▁conteng ono ▁valor i ▁significa ti vi ▁// ▁questo ▁if ▁deve ▁essere ▁ messo ▁prima ▁di ▁quell o ▁che ▁segue ▁if ▁( qualcun o _ tramite _ agenzia ▁&& ▁qualcun o _ senza _ agenzia ) ▁{ ▁msg ▁= ▁new ▁MessageDialog ( this , ▁" ▁L ' elenco ▁delle ▁stanze ▁include ▁stanze ▁commissionate ▁e ▁non ! ▁Proce dere ▁al ▁calcolo ▁separato . ▁"); ▁return ▁true ; ▁} ▁// ▁L ' if ▁che ▁segue ▁deve ▁essere ▁pos to ▁do po ▁a ▁quell o ▁che ▁precede ▁if ▁( checkboxes [2]. getStat e () ▁&& ▁qualcun o _ tramite _ agenzia ) ▁{ ▁msg ▁= ▁new ▁MessageDialog ( this , ▁" ▁Il ▁conto ▁comitiva ▁non ▁e ' ▁possibile ▁per ▁le ▁agenzie ! ▁"); ▁return ▁true ; ▁} ▁// ▁se ▁a rrivo ▁qui ▁significa ▁che ▁si ▁pu o ' ▁fare ▁il ▁conto ▁normale , ▁// ▁rimane ▁da ▁verificar e ▁se ▁si ▁desidera ▁fare ▁una ▁partenza ▁anticipata ▁// ▁e ▁in ▁tal ▁cas o ▁verificar e ▁che ▁la ▁data ▁inserita ▁sia ▁corretta ! ▁if ▁( ▁( checkboxes [3]. getStat e ()) ▁&& ▁( DateUtils . data Corrett a ( testo [5]. getText ())) ▁) ▁{ ▁Date ▁data ▁= ▁ DateUtils . convert Date ( testo [5]. getText ()); ▁Date ▁data _ oggi ▁= ▁new ▁Date (); ▁// ▁controllo ▁che ▁la ▁data ▁di ▁partenza ▁anticipata ▁abbia ▁sen so : ▁// ▁1) ▁controllo ▁che ▁il ▁cliente ▁abbia ▁soggiorna to ▁al mento ▁un ▁giorno ▁for ▁( int ▁i =0; ▁i < date _ inizio . length ; ▁i ++) ▁if ▁( Utils . data 1 M aggiore Data 2( date _ inizio [ i ], ▁ DateUtils . giorno Prima Di ( data ))) ▁{ ▁msg ▁= ▁new ▁MessageDialog ( this , ▁" ▁I ▁clienti ▁devo no ▁soggiorna re ▁almeno ▁un ▁giorno ▁prima ▁di ▁partire ! ▁"); ▁return ▁true ; ▁} ▁// ▁2) ▁controllo ▁che ▁la ▁partenza ▁anticipata ▁non ▁sia ▁prima ▁di ▁oggi ▁if ▁( Utils . data 1 Min oreDat a 2( data , ▁data _ oggi )) ▁{ ▁msg ▁= ▁new ▁Avviso Dialog ( this , ▁" ▁La ▁data ▁non ▁pu o ' ▁essere ▁precedente ▁a ▁quell a ▁odierna ! ▁"); ▁testo [5]. setText ( DateUtils . parse Date ( DateUtils . give String Of Date ( data _ oggi ))); ▁return ▁true ; ▁} ▁else ▁// ▁3) ▁controllo ▁che ▁il ▁fine ▁soggiorno ▁ anticipato ▁( ossi a ▁il ▁giorno ▁prima ▁della ▁// ▁partenza ▁anticipata ) ▁non ▁sia ▁do po ▁il ▁fine ▁soggiorno ▁effettivo ▁for ▁( int ▁i =0; ▁i < date _ fine . length ; ▁i ++) ▁if ▁( Utils . data 1 M aggiore Data 2( data , ▁date _ fine [ i ])) ▁{ ▁msg ▁= ▁new ▁Avviso Dialog ( this , ▁" ▁ Non ▁si ▁t ratta ▁di ▁una ▁partenza ▁anticipata ▁per ▁la ▁stanza ▁"+ L _ st [ i ]+" ▁con ▁ tale ▁data ! ▁"); ▁testo [5]. setText ( DateUtils . parse Date ( DateUtils . give String Of Date ( data _ oggi ))); ▁return ▁true ; ▁} ▁fine _ sogg _ anticipato ▁= ▁ DateUtils . giorno Prima Di ( data ); ▁} ▁else ▁{ ▁if ▁( ▁( checkboxes [3]. getStat e ()) ▁&& ▁! DateUtils . data Corrett a ( testo [5]. getText ())) ▁{ ▁msg ▁= ▁new ▁MessageDialog ( this , ▁" ▁La ▁data ▁di ▁partenza ▁anticipata ▁e ' ▁errata ! ▁"); ▁return ▁true ; ▁} ▁else ▁{ ▁// ▁il ▁checkboxes [3] ▁non ▁e ' ▁attivo ▁fine _ sogg _ anticipato ▁= ▁data _ fine _ magg ; ▁if ▁( qualcun o _ tramite _ agenzia ▁&& ▁checkboxes [1]. getStat e ()) ▁{ ▁msg ▁= ▁new ▁MessageDialog ( this , ▁" ▁Il ▁cliente ▁e ' ▁in ▁una ▁stanza ▁di ▁agenzia ! ▁Se ▁deve ▁and arse ne ▁sceglie re ▁' partenza ▁anticipata ' . ▁"); ▁return ▁true ; ▁} ▁} ▁} ▁return ▁false ; ▁} ▁// ▁errori ▁void ▁startConto Stanza () ▁{ ▁Frame ▁msg ; ▁if ▁(! qualcun o _ tramite _ agenzia ) ▁{ ▁if ▁( checkboxes [3]. getStat e ()) ▁ CalcoloConto . calcolaConto Stanza ( testo [0]. getText (), ▁1, ▁false , ▁fine _ sogg _ anticipato ); ▁else ▁ CalcoloConto . calcolaConto Stanza ( testo [0]. getText (), ▁1, ▁false , ▁null ); ▁} ▁else ▁{ ▁ CalcoloConto . calcolaConto Stanza Agenzia ( testo [0]. getText ()); ▁} ▁} ▁void ▁startConto Singolo () ▁{ ▁if ▁( qualcun o _ tramite _ agenzia ) ▁{ ▁Frame ▁msg ; ▁Date ▁fine _ effettiva ; ▁if ▁( checkboxes [3]. getStat e ()) ▁fine _ effettiva ▁= ▁fine _ sogg _ anticipato ; ▁else ▁fine _ effettiva ▁= ▁data _ fine _ magg ; ▁if ▁( ▁ Utils . data 1 Min oreDat a 2( fine _ effettiva , ▁new ▁Date ()) ▁) ▁msg ▁= ▁new ▁AskChiudi S ingoloConAgenzia ( this ); ▁else ▁msg ▁= ▁new ▁MessageDialog ( this , ▁" ▁La ▁data ▁e ' ▁pos terio re ▁ad ▁oggi : ▁non ▁e ' ▁possibile ▁chiudere ! ▁"); ▁return ; ▁} ▁else ▁if ▁( ▁( checkboxes [3]. getStat e ()) ▁) ▁ CalcoloConto . calcolaConto Singolo ( sogg _ x _ conto _ sing , ▁fine _ sogg _ anticipato ); ▁else ▁ CalcoloConto . calcolaConto Singolo ( sogg _ x _ conto _ sing , ▁null ); ▁} ▁void ▁startConto C omitiva () ▁{ ▁if ▁( ▁( checkboxes [3]. getStat e ()) ▁) ▁ CalcoloConto . calcolaConto C omitiva ( L _ st , ▁fine _ sogg _ anticipato ); ▁else ▁ CalcoloConto . calcolaConto C omitiva ( L _ st , ▁null ); ▁} ▁void ▁ startChiudi S ingoloConAgenzia () ▁{ ▁if ▁( checkboxes [3]. getStat e ()) ▁{ ▁Date ▁new _ data ▁= ▁ DateUtils . convert Date ( testo [5]. getText ()); ▁new _ data ▁= ▁ DateUtils . giorno Prima Di ( new _ data ); ▁( Principale . db ) . anticipa Fine Sogg ( sogg _ x _ conto _ sing . getNumStanz a (), ▁sogg _ x _ conto _ sing . getId Soggiornante (), ▁new _ data ); ▁} ▁( Principale . db ) . re verse P agato ( sogg _ x _ conto _ sing . getNumStanz a (), ▁sogg _ x _ conto _ sing . getId Soggiornante ()); ▁for ▁( int ▁i =0; ▁i < testo . length -1; ▁i ++) ▁testo [ i ]. setText (" "); ▁} ▁}